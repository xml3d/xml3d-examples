(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var blast = require("blast");
var jpath = require("jpath");
var abops = require("abops");

var normal = (1 << 0);
var tangent = (1 << 1);
var texcoord = (1 << 2);
var color = (1 << 3);
var transform = (1 << 4);

function isLittleEndianArchitecture() {
    // DataView#getUint16 will read 1 on big-endian systems.
    return new DataView(new Uint16Array([256]).buffer).getUint16(0, true) === 256;
};

 function flipEndianessIfNecessary(typedArray, littleEndian) {
    if (littleEndian !== isLittleEndianArchitecture())
        return abops.flipEndianness(typedArray);
    return typedArray;
};

function decodeAssimpMesh(buffer, littleEndian) {
    var view = new DataView(buffer);
    var offset = 0;
    var vertexCount = view.getUint32(offset, littleEndian);
    offset += 4;
    var attribs = view.getUint8(offset);
    offset += 4;

    var mesh = {
        position: flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 3), littleEndian)
    };
    offset += vertexCount * 3 * mesh.position.BYTES_PER_ELEMENT;

    if (attribs & normal) {
        mesh.normal = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 3), littleEndian);
        offset += vertexCount * 3 * mesh.normal.BYTES_PER_ELEMENT;
    }
    if (attribs & tangent) {
        mesh.tangent = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 3), littleEndian);
        offset += vertexCount * 3 * mesh.tangent.BYTES_PER_ELEMENT;
    }
    if (attribs & texcoord) {
        mesh.texcoord = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 2), littleEndian);
        offset += vertexCount * 2 * mesh.texcoord.BYTES_PER_ELEMENT;
    }
    if (attribs & color) {
        mesh.color = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 4), littleEndian);
        offset += vertexCount * 4 * mesh.color.BYTES_PER_ELEMENT;
    }
    if (attribs & transform) {
        mesh.meshTransform = flipEndianessIfNecessary(new Float32Array(buffer, offset, 16), littleEndian);
        offset += 16 * mesh.meshTransform.BYTES_PER_ELEMENT;
    }

    mesh.index = flipEndianessIfNecessary(new Uint32Array(buffer, offset), littleEndian);

    return mesh;
};

var BlastFormatHandler = function() {
    XML3D.base.BinaryFormatHandler.call(this);
};

XML3D.createClass(BlastFormatHandler, XML3D.base.BinaryFormatHandler);

BlastFormatHandler.prototype.isFormatSupported = function(response, responseType, mimetype) {
    if (!(response instanceof ArrayBuffer))
        return false;
    return true;
};

BlastFormatHandler.prototype.getFormatData = function(response, responseType, mimetype, callback) {
    var xflowData = [];
    var streamReceiver = new blast.StreamReceiver({
        async: false
    });
    var errorCallback = callback.bind(undefined, false);
    streamReceiver.end(response);
    streamReceiver
        .on("error", errorCallback)
        .pipe(new blast.Dechunker({ async: false }))
        .on("error", errorCallback)
        .pipe(new blast.ValueDecoder({
            async: false,
            decodingSpecificationMap: {
                "http://localhost:9090/codecs/assimpMesh": decodeAssimpMesh
            }
        }))
        .on("error", errorCallback)
        .on("data", function (decodedData) {
            jpath.evaluate(decodedData.path, xflowData).forEach(function (result) {
                decodedData.metadata.forEach(function (pathTypeMap) {
                    jpath.evaluate(pathTypeMap.path, decodedData.value).definedResults.forEach(function (result) {
                        var xflowDataDescription = {
                            type: pathTypeMap.type,
                            value: result.value
                        };
                        if (result.isRoot)
                            decodedData.value = xflowDataDescription;
                        else
                            result.value = xflowDataDescription;
                    });
                });
                if (result.isRoot)
                    xflowData = decodedData.value;
                else
                    result.value = decodedData.value;
            });
        })
        .on("finish", function () {
            callback(true, xflowData);
        });
};

BlastFormatHandler.prototype.getFragmentData = function (data, path) {
    if (!path)
        return data;
    return jpath.evaluate(path, data).definedResults.length > 0 ? jpath.evaluate(path, data).definedResults[0].value : null;
};

var blastFormatHandler = new BlastFormatHandler();
XML3D.base.registerFormat(blastFormatHandler);

var BlastDataAdapter = function (data) {
    if (data.assetMeshes)
        this._asset = createAsset(data);
    else
        this._xflowNode = createXflowDataNode(data);
};

function createXflowDataNode (data) {
    var xflowDataNode = XML3D.data.xflowGraph.createDataNode();

    Object.keys(data).forEach(function (attributeName) {
        var attribute = data[attributeName];
        if (attribute)
            xflowDataNode.appendChild(createInputNode(attributeName, attribute.type, attribute.value));
    });

    return xflowDataNode;
}

function createInputNode(name, type, typedArray) {
    var inputNode = XML3D.data.xflowGraph.createInputNode();
    inputNode.name = name;
    inputNode.data = new Xflow.BufferEntry(XML3D.data.BUFFER_TYPE_TABLE[type], typedArray);
    return inputNode;
}

function createAsset(data) {
    var asset = new XML3D.base.Asset();
    Object.keys(data.assetMeshes).forEach(function (assetMeshIdx) {
        var assetMeshData = data.assetMeshes[assetMeshIdx];
        var assetMesh = new XML3D.base.SubData(XML3D.data.xflowGraph.createDataNode(), createXflowDataNode(assetMeshData));
        assetMesh.setMeshType("triangles");
        asset.appendChild(assetMesh);
    });
    return asset;
}

BlastDataAdapter.prototype.getXflowNode = function() {
    return this._xflowNode;
};

BlastDataAdapter.prototype.getAsset = function() {
    return this._asset;
};

var BlastFactory = function(){
    XML3D.base.AdapterFactory.call(this, XML3D.data);
};

XML3D.createClass(BlastFactory, XML3D.base.AdapterFactory);

BlastFactory.prototype.aspect = XML3D.data;
BlastFactory.prototype.createAdapter = function(mesh) {
    return new BlastDataAdapter(mesh);
};

XML3D.base.resourceManager.addBinaryExtension(".blast");
XML3D.base.resourceManager.addBinaryContentType("model/vnd.xml3d.data+blst");
XML3D.base.resourceManager.addBinaryContentType("model/vnd.xml3d.model+blst");
blastFormatHandler.registerFactoryClass(BlastFactory);

},{"abops":2,"blast":9,"jpath":90}],2:[function(require,module,exports){
"use strict";

/**
 * Returns a Uint8Array for the given ArrayBuffer.
 * If a ArrayBufferView or a DataView is given, the underlying buffer will be used and the set
 * offset and length will be respected.
 *
 * @private
 * @function toUint8Array
 * @param {ArrayBufferView|ArrayBuffer} arrayBuffer The ArrayBuffer or a view into an ArrayBuffer for which to create a Uint8Array view.
 * @returns {Uint8Array} A Uint8Array referencing the given ArrayBuffer.
 */
function toUint8Array(arrayBuffer, offset, length) {
	offset = +offset || 0;
	length = +length;
	if (typeof arrayBuffer.BYTES_PER_ELEMENT !== "undefined" || arrayBuffer instanceof DataView) {
		return new Uint8Array(arrayBuffer.buffer, offset + arrayBuffer.byteOffset, arrayBuffer.byteLength - offset);
	}
	else {
		return new Uint8Array(arrayBuffer, offset, length || arrayBuffer.byteLength - offset);
	}
}

/**
 * Concatenates a variable list of ArrayBuffers.
 * If one of the arguments is a DataView or an `ArrayBufferView` the underlying buffer will be used and
 * the set offset and length will be respected.
 *
 * @public
 * @function concat
 * @param {ArrayBuffer...|ArrayBufferView...} buffers A variable list of plain ArrayBuffers or ArrayBufferViews.
 * @returns {ArrayBuffer} A new ArrayBuffer as the result of concatenating the given buffers.
 */
exports.concat = function () {
	if (arguments.length === 1)
		return toUint8Array(arguments[0]).buffer;
	else
		var arrayBufferList = Array.prototype.slice.call(arguments);

    // Get a list of all buffers and their total size
    var totalSize = 0;
    var byteBuffers = arrayBufferList.map(function (arrayBuffer) {
        // If a `DataView` or a typed array was passed instead of a plain `ArrayBuffer`
        // the underlying buffer will be used instead.
        var byteBuffer = toUint8Array(arrayBuffer);
        totalSize += byteBuffer.length;
        return byteBuffer;
    }).filter(function (byteBuffer) {
            return byteBuffer.length > 0;
        });

    if (byteBuffers.length === 0)
        return new ArrayBuffer(0);

    if (byteBuffers.length === 1)
        return byteBuffers[0].buffer;

	// This will contain the final concatenated buffer.
    var concatBuffer = new Uint8Array(totalSize);

    var offset = 0;
    byteBuffers.forEach(function (byteBuffer) {
        concatBuffer.set(byteBuffer, offset);
        offset += byteBuffer.length;
    });

    return concatBuffer.buffer;
};

/**
 * Flips the endianness of the given TypedArray in-place.
 *
 * @public
 * @function flipEndianness
 * @param {Typed Array} typedArray The typed array for which the endianness should be flipped.
 */
exports.flipEndianness = function (typedArray) {
	// Uint8ClampedArray is a rather new part of the typed array specification and not fully supported by
	// all browsers.
	var Uint8ClampedArrayType;
	if (typeof Uint8ClampedArray === "undefined")
		Uint8ClampedArrayType = function dummy() {};
	else
		Uint8ClampedArrayType = Uint8ClampedArray;

	if (typedArray instanceof Int8Array || typedArray instanceof Uint8Array || typedArray instanceof Uint8ClampedArrayType)
        return typedArray;

    var byteArray = new Uint8Array(typedArray.buffer, typedArray.offset, typedArray.byteLength);
    for (var i = 0; i < typedArray.byteLength; i += typedArray.BYTES_PER_ELEMENT) {
        var leftIdx = i;
        var rightIdx = i + typedArray.BYTES_PER_ELEMENT - 1;
	    // Walk from left and right and swap bytes.
        while (leftIdx < rightIdx) {
            var tmp = byteArray[leftIdx];
            byteArray[leftIdx] = byteArray[rightIdx];
            byteArray[rightIdx] = tmp;
            ++leftIdx;
            --rightIdx;
        }
    }

    return typedArray;
};

// # String handling

// JavaScript string are UTF-16 encoded.
// To handle conversion into different unicode encodings, mainly UTF-8, we convert JavaScript string
// into an array of unicode code points that can easily converted into different encodings.

/**
 * Converts the given JavaScript string into an array of unicode code points.
 *
 * @private
 * @function stringToUnicodeCodePoints
 * @param {string} string The string to convert.
 * @returns {number[]} The array of unicode code points of the given string.
 */
function stringToUnicodeCodePoints(string) {
	var output = [];
	var	counter = 0;
	var length = string.length;
	var value;
	var extra;

	while (counter < length) {
		// JavaScripts String#charCodeAt function returns values less than 65536.
		// Higher code points are represented using so called surrogate pairs.
		// This means that we have to examine the next character to get the real unicode code point value.
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// High surrogate => there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// Unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Converts an array of unicode codepoints into a JavaScript string.
 *
 * @private
 * @function unicodeCodePointsToString
 * @param {number[]} codePoints An array of unicode code points.
 * @returns {string} The string represented by the given code points.
 */
function unicodeCodePointsToString(codePoints) {
	return codePoints.map(function(codePoint) {
		var output = '';
		if (codePoint > 0xFFFF) {
			codePoint -= 0x10000;
			output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
			codePoint = 0xDC00 | codePoint & 0x3FF;
		}
		output += String.fromCharCode(codePoint);
		return output;
	}).join('');
}

/**
 * Converts the given string into a series of of UTF-8 code units.
 *
 * @private
 * @function utf8encode
 * @param {string} string The string to encode.
 * @returns {number[]} An array of UTF-8 code units for the given string.
 */
function utf8encode(string) {
	var codePoints = stringToUnicodeCodePoints(string);

	// UTF-8 is a variable length encoding that actually supports up to six bytes per character.
	// However, these characters are in the private unicode range and can therefore never occur in JavaScript.
    var utf8CodeUnits = [];
    for (var idx = 0; idx < codePoints.length; ++idx) {
        var codePoint = codePoints[idx];
        if (codePoint < 0x0080)
            utf8CodeUnits.push(codePoint & 0xFF);
        else if (codePoint < 0x0800) {
            utf8CodeUnits.push(0xC0 + (codePoint >>> 6));
            utf8CodeUnits.push(0x80 + (codePoint & 0x3F));
        }
        else if (codePoint < 0x10000) {
            utf8CodeUnits.push(0xe0 + (codePoint >>> 12));
            utf8CodeUnits.push(0x80 + ((codePoint >>> 6) & 0x3f));
            utf8CodeUnits.push(0x80 + (codePoint & 0x3f));
        }
        else {
            utf8CodeUnits.push(0xf0 + (codePoint >>> 18));
            utf8CodeUnits.push(0x80 + ((codePoint >>> 12) & 0x3f));
            utf8CodeUnits.push(0x80 + ((codePoint >>> 6) & 0x3f));
            utf8CodeUnits.push(0x80 + (codePoint & 0x3f));
        }
    }
    return utf8CodeUnits;
}

/**
 * Decodes a given series of UTF-8 code units into a string.
 *
 * @private
 * @function utf8decode
 * @param {number[]} utf8CodeUnits The UTF-8 code units.
 * @returns {string} The decoded string.
 */
function utf8decode(utf8CodeUnits) {
	var codePoints =  [];
	var idx = 0;
	while (idx < utf8CodeUnits.length) {
		var codeUnit = utf8CodeUnits[idx];
		// We ignore five and six byte characters!
		if (codeUnit > 0xef && codeUnit < 0xf8) {
			codePoints.push((utf8CodeUnits[idx] - 0xf0 << 18) + (utf8CodeUnits[idx + 1] - 0x80 << 12) + (utf8CodeUnits[idx + 2] - 0x80 << 6) + (utf8CodeUnits[idx + 3] - 0x80));
			idx += 4;
		} else if (codeUnit > 0xdf && codeUnit < 0xf0) {
			codePoints.push((utf8CodeUnits[idx] - 0xe0 << 12) + (utf8CodeUnits[idx + 1] - 0x80 << 6) + (utf8CodeUnits[idx + 2] - 0x80));
			idx += 3;
		} else if (codeUnit > 0xbf && codeUnit < 0xe0) {
			codePoints.push((utf8CodeUnits[idx] - 0xc0 << 6) + (utf8CodeUnits[idx + 1] - 0x80));
			idx += 2;
		} else {
			codePoints.push(utf8CodeUnits[idx]);
			idx += 1;
		}
	}

	return unicodeCodePointsToString(codePoints);
}

/**
 * Returns the size in bytes needed to write the given string with the given encoding into a buffer.
 * Currently only ASCII and UTF-8 encoding is supported.
 *
 * @public
 * @function byteSizeForString
 * @param {string} string The string for which to calculate the size.
 * @param {string} [encoding = "UTF-8"] The encoding to use.
 * @returns {number} The size in bytes needed to store the given string in the given encoding.
 */
exports.byteSizeForString = function (string, encoding) {
	var codePoints = stringToUnicodeCodePoints(string);
	encoding = encoding ? encoding.toLowerCase() : "utf-8";

	switch (encoding) {
		case "ascii":
			return codePoints.length;
		case "utf8":
		case "utf-8":
			return codePoints.reduce(function (byteSize, codePoint) {
				return byteSize + (codePoint < 0x0080 ? 1 : (codePoint < 0x0800 ? 2 : (codePoint < 0x10000 ? 3 : 4)));
			}, 0);
	}
};

/**
 * Writes the given string using the given encoding at the specified offset into the buffer.
 * If littleEndian is true, multi-byte values will be written in littleEndian format.
 * Currently only ASCII and UTF-8 encoding is supported which makes endianness a non issue.
 *
 * @public
 * @function setString
 * @param {ArrayBuffer|TypedArray|DataView} arrayBuffer The buffer where the string should be written into.
 * @param {number} offset The offset in bytes at which the string should begin inside the buffer.
 * @param {string} string The string to write.
 * @param {string} [encoding = "UTF-8"] The encoding to use.
 * @param {boolean} [littleEndian = false] If true for multi byte characters will be written in little endian format.
 */
exports.setString = function (arrayBuffer, offset, string, encoding, littleEndian) {
    var bytes = toUint8Array(arrayBuffer, offset);
	encoding = encoding ? encoding.toLowerCase() : "utf-8";

	switch (encoding) {
		case "ascii":
			bytes.set(stringToUnicodeCodePoints(string).map(function (codePoint) { return codePoint % 128; }));
			break;
		case "utf8":
		case "utf-8":
			bytes.set(utf8encode(string));
			break;
	}
};

/**
 * Writes the given string into the given buffer at the chosen offset.
 * The string will be written using ASCII encoding and succeeded by a NUL byte.
 *
 * @public
 * @function setCString
 * @param {ArrayBufferView|ArrayBuffer} arrayBuffer The buffer to write to.
 * @param {number} offset The offset in bytes for the string to begin inside the buffer.
 * @param {string} string The string to write.
 */
exports.setCString = function(arrayBuffer, offset, string) {
    var lastCharacterIdx = offset + this.byteSizeForString(string, "ascii");
    this.setString(arrayBuffer, offset, string, "ascii");
    var bytes = toUint8Array(arrayBuffer, offset);
	bytes[lastCharacterIdx] = 0;
};

/**
 * Reads the given string from the given buffer starting at offset, reading length bytes, using the specified encoding.
 * If littleEndian is true, multi-byte values are expected to bew in littleEndian format.
 * Currently only ASCII and UTF-8 encoding is supported which makes endianness a non issue.
 *
 * @public
 * @function getString
 * @param {ArrayBufferView|ArrayBuffer} arrayBuffer The buffer to read from.
 * @param {number} offset The offset in bytes at which to start reading.
 * @param {number} length The number of bytes to read.
 * @param {string} encoding The encoding of the string.
 * @param {boolean} [littleEndian = false] If true multi-byte characters are expected to be in little endian format.
 * @return {string} The string read from the buffer.
 */
exports.getString = function (arrayBuffer, offset, length, encoding, littleEndian) {
	// Check if length is omitted and encoding is set.
	if (typeof length === "string") {
		encoding = length;
		length = undefined;
	}

	encoding = encoding ? encoding.toLowerCase() : "utf-8";

	var bytes = Array.prototype.slice.call(toUint8Array(arrayBuffer, offset, length));

	switch (encoding) {
		case "ascii":
			return String.fromCharCode.apply(null, bytes.map(function (byte) { return byte % 128; }));
		case "utf8":
		case "utf-8":
			return utf8decode(bytes);
	}
};

/**
 * Reads a NUL terminated ASCII encoded string from the given buffer starting at the given offset.
 *
 * @public
 * @function getCString
 * @param {ArrayBufferView|ArrayBuffer} arrayBuffer The buffer to read from.
 * @param {number} offset The offset in bytes to start reading.
 * @return {string} string The read string.
 */
exports.getCString = function (arrayBuffer, offset) {
	var bytes = toUint8Array(arrayBuffer, offset);

    var asciiCodeUnits = [];
    for (var idx = 0; idx < bytes.byteLength; ++idx) {
        var c = bytes[idx];
        if (c === 0x00)
            break;
	    asciiCodeUnits.push(c);
    }
    return String.fromCharCode.apply(null, asciiCodeUnits);
};

/**
 * Creates an ArrayBuffer filled with the given string.
 * The string will be ASCII encoded and succeeded by a NUL character.
 *
 * @param {string} string The string for which a buffer should be created.
 * @return {ArrayBuffer} An ArrayBuffer containing the given string.
 */
exports.bufferForCString = function (string) {
	// Add one byte for the NUL character
	var buffer = new ArrayBuffer(this.byteSizeForString(string, "ascii") + 1);
	this.setCString(buffer, 0, string);
	return buffer;
};

/**
 * Creates an ArrayBuffer filled with the given string using the given encoding.
 * If littleEndian is true, multi-byte values will be written in littleEndian format.
 * Currently only ASCII and UTF-8 encoding is supported which makes endianness a non issue.
 *
 * @public
 * @function bufferForString
 * @param {string} string The string to for which a buffer should be created.
 * @param {string} encoding The encoding to use.
 * @param {bool} [littleEndian = false] If true multi-byte characters will be written in little-endian format.
 * @returns {ArrayBuffer} An ArrayBuffer containing the given string.
 */
exports.bufferForString = function (string, encoding, littleEndian) {
	var buffer = new ArrayBuffer(this.byteSizeForString(string, encoding));
    this.setString(buffer, 0, string, encoding, littleEndian);
    return buffer;
};

},{}],3:[function(require,module,exports){
"use strict";

function worker() {
    self.addEventListener("message", function (event) {
        downloadDecodingFunctionality(event.data.decodingSpecification);
        decodeData(event.data.buffer, event.data.littleEndian);
    });

    function downloadDecodingFunctionality(url) {
        self.module = {};
        self.module.exports = {};
        self.exports = self.module.exports;

        importScripts(url);
        var decodingFunction;
        if (typeof module.exports === "function")
            decodingFunction = self.module.exports;
        else if (typeof exports === "object")
            decodingFunction = self.module.exports.decode;
        else if (typeof decode === "function")
            decodingFunction = decode;
        else
            throw new Error("Could not find decoding function");
        self.decodingFunction = wrappDecodingFunction(decodingFunction);
    }

    function wrappDecodingFunction(decodingFunction) {
        var arity = decodingFunction.length;
        // Variable argument list means we consider this function to be async. and to expect
        // an ArrayBuffer, offset, length and endianness as parameter.
        if (arity === 0)
            return decodingFunction;
        // An arity of two means we have a sync. function taking a DataView and the endianness.
        if (arity === 2)
            return function (buffer, littleEndian, callback) {
                try {
                    var result = decodingFunction(buffer, littleEndian);
                    callback(null, result);
                } catch (e) {
                    callback(e, null);
                }
            };
        if (arity === 3)
            return  decodingFunction;

        new Error("Malformed decoding function");
    }

    function decodeData(buffer, littleEndian) {
        self.decodingFunction(buffer, littleEndian, function (error, result) {
            if (error)
                throw error;

            self.postMessage(result);
        });
    }
}

function DecodingWorkerPool(poolSize) {
    this._poolSize = poolSize || 4;
    this._pool = [];
    this._taskQueue = [];

    this._fillPool();
}

DecodingWorkerPool.prototype.scheduleTask = function (decodingTask, callback) {
    this._taskQueue.push({
        decodingTask: decodingTask,
        callback: callback
    });
    this._processQueue();
};

DecodingWorkerPool.prototype._processQueue = function () {
    if (this._pool.length === 0 || this._taskQueue.length === 0)
        return;

    var taskInfo = this._taskQueue.shift();
    var worker = this._pool.shift();
    var self = this;

    worker.onmessage = function (event) {
        self._pool.push(this);
        taskInfo.callback(null, event.data);
        self._processQueue();
    };

    worker.onerror = function (event) {
        self._pool.push(this);
        taskInfo.callback(event);
        event.preventDefault();
        self._processQueue();
    };

    worker.postMessage(taskInfo.decodingTask, [taskInfo.decodingTask.buffer]);
};

DecodingWorkerPool.prototype._fillPool = function () {
    for (var i = 0; i < this._poolSize; ++i)
        this._pool.push(this._createWorker());
};

DecodingWorkerPool.prototype._createWorker = function () {
    var str = worker.toString() + "\nworker();";
    return new Worker(URL.createObjectURL(new Blob([str], { type: "application/javascript"} )));
};

exports = module.exports = DecodingWorkerPool;

},{}],4:[function(require,module,exports){
"use strict";

var DecodingWorkerPool = require("./decoding_worker_pool");

var pool = new DecodingWorkerPool();
exports = module.exports = function (decodingSpecification, buffer, littleEndian, callback) {
    pool.scheduleTask({
        decodingSpecification: decodingSpecification,
        buffer: buffer,
        littleEndian: littleEndian
    }, callback)
};


},{"./decoding_worker_pool":3}],5:[function(require,module,exports){
// # Chunk

// A `chunk` is an independent part of a blast stream that can be processed by the client individually and without
// any information of other chunks in the stream except for the preamble.
// A `chunk` may contain multiple encodedValues from the original object.
// However, it will never contain partiall data such that another `chunk` is necessary to decode a value.

// ## Structure

// A chunk has the following binary structure.
//
// Octets 0--3: Overall chunks size (OCS).
// Octets 4--7: Header definition size (HS).
// Octets 8--8+<HS>: Definitions of the payload in this chunk.
// Octets: 9+<HS>--<OCS>: Payload.

// ### Header definition

// A chunks header definition is an array of key-value pairs.
// In JavaScript this simply maps to objects.
// The header definition of each chunk is encoded and can be decoded using the procedure
// specified in the preamble of the stream.
// Each definition is structured as follows:

// - path: A JPath specifying the original path of the value in the
// - offset: Byte offset from the beginning of the chunk's payload where the encoded data starts.
// - size: Byte length of the encoded data.
// - decodingSpecification: A URL that uniquely identifies the decoding procedure necessary to decode the data
// defined in this entry.
// - metadata: Possible metadata associated with this value.

// ### Payload

// A chunks payload is a flat `ArrayBuffer` of arbitrary size.
// It contains all encodedData specified in the header definitions.
// The size of each chunk's payload can be calculated as:
// <OCS>-9+<HS>.

// ### Signal End Of Stream

// A special chunk, the signal end of stream chunk, contains no payload and thus no header definitions.
// This chunk signals the receiver the end of the stream.
// It is therefore not valid to call a chunks toBuffer method if no payload was added beforehand.

"use strict";

var BlastError = require("./error");

// Constructs a new chunk that can be filled with data.
// A newly constructed chunk will have a payload of size 0 and a header definition size of 0.
// It is invalid to call toBuffer on a fresh chunk!
function Chunk() {
    this._headerDefinitions = [];

    this._payload = [];
    this._currentOffset = 0;
}

Object.defineProperties(Chunk.prototype, {
    payload: {
        get: function () {
          return this._payload;
        }
    },
    payloadSize: {
        get: function () {
            return this._currentOffset;
        }
    },
    headerDefinitions: {
        get: function () {
            return this._headerDefinitions;
        }
    }
});

//Adds the given payload to the chunk.
// A header definition entry will be generated with the given path, the decodingSpecification and metadata.
Chunk.prototype.add = function (encodedData) {
    if (!Array.isArray(encodedData.encodedValue))
        encodedData.encodedValue = [encodedData.encodedValue];

    encodedData.encodedValue = encodedData.encodedValue.map(function (typedArrayOrBuffer) {
         if (typedArrayOrBuffer.buffer)
            return typedArrayOrBuffer.buffer;

        return typedArrayOrBuffer;
    });

    var size = encodedData.encodedValue.reduce(function (currentSize, buffer) {
        return currentSize + length(buffer);
    }, 0);

    this._payload = this._payload.concat(encodedData.encodedValue);
    this._headerDefinitions.push({
        path: encodedData.path,
        offset: this._currentOffset,
        size: size,
        decodingSpecification: encodedData.decodingSpecification,
        metadata: encodedData.metadata
    });
    this._currentOffset += size;
};

function length(buffer) {
	return typeof buffer.byteLength !== "undefined" ? buffer.byteLength : buffer.length;
}

exports = module.exports = Chunk;


},{"./error":8}],6:[function(require,module,exports){
// # Chunker

// The `Chunker` represents the second step in the blast pipeline and is a NodeJS transform stream.
// It takes encodedData and transforms them into blast chunks.

"use strict"

var util = require("util");
var Transform = require("stream").Transform;

var Chunk = require("./chunk");
var callImmediate = require("./util/call_immediate");

// Constructs a Chunker.
// `chunkSize` may specify the size of a chunk in bytes.
// This size, however, is only a softlimit and chunks may contain more or less bytes depending on the size of
// individual values.
function Chunker(options) {
	Transform.call(this, {
		objectMode: true
	});

    this._chunk = new Chunk();

    options = options || {};
    this._chunkSize = options.chunkSize || (1 << 30);
    this._async = typeof options.async !== "undefined" ? options.async : true;
}

util.inherits(Chunker, Transform);

Chunker.prototype._transform = function (encodedData, _, callback) {
    callImmediate(this._appendToChunk.bind(this, encodedData, callback), this._async);
};

Chunker.prototype._appendToChunk = function (encodedData, callback) {
	this._chunk.add(encodedData);
    if (this._chunk.payloadSize > this._chunkSize) {
        this.push(this._chunk);
        this._chunk = new Chunk();
    }
    callback();
};

Chunker.prototype._flush = function (callback) {
    if (this._chunk.payloadSize > 0) {
        var self = this;
        callImmediate(function () {
            self.push(self._chunk);
            callback();
        }, this._async);
    } else {
        callback();
    }
};

exports = module.exports = Chunker;

},{"./chunk":5,"./util/call_immediate":17,"stream":72,"util":80}],7:[function(require,module,exports){
"use strict"

var util = require("util");
var Transform = require("stream").Transform;

var callImmediate = require("./util/call_immediate");

function Dechunker(options) {
    Transform.call(this, {
        objectMode: true
    });

    options = options || {};

    this._async = typeof options.async !== "undefined" ? options.async : true;
}

util.inherits(Dechunker, Transform);

Dechunker.prototype._transform = function (chunk, _, callback) {
    var self = this;
    callImmediate(function () {
        // Chunks generated by the chunker have an array of ArrayBuffers as payload.
        // Chunks received by the stream receiver, however, only have a single payload ArrayBuffer.
        if (!Array.isArray(chunk.payload))
            chunk.payload = [chunk.payload];

        chunk.headerDefinitions.forEach(function (headerDefinition) {
            var offset = headerDefinition.offset;
            var buffer = chunk.payload[0];

            // Find the buffer for the given offset
            var sizeOfPreviousBuffers = chunk.payload[0].byteLength;
            for (var i = 1; i < chunk.payload.length; ++i) {
                if (offset <= sizeOfPreviousBuffers + chunk.payload[i].byteLength) {
                    buffer = chunk.payload[i];
                    offset = offset - sizeOfPreviousBuffers;
                }
                sizeOfPreviousBuffers += chunk.payload[i].byteLength;
            }

            if (!buffer)
                return self.emit("eror", new Error("Could not find a buffer for the given offset!"));

            self.push({
                encodedValue: buffer.slice(offset, offset + headerDefinition.size),
                path: headerDefinition.path,
                decodingSpecification: headerDefinition.decodingSpecification,
                metadata: headerDefinition.metadata,
                littleEndian: chunk.littleEndian
            });
        });
        callback();
    }, this._async);
};

exports = module.exports = Dechunker;

},{"./util/call_immediate":17,"stream":72,"util":80}],8:[function(require,module,exports){
"use strict";

var util = require("util");

function BlastError(message, stackStartFunction) {
	this.message = message;
};

util.inherits(BlastError, Error);

BlastError.prototype.name = "Blast Error";

exports = module.exports = BlastError;

},{"util":80}],9:[function(require,module,exports){
"use strict";

exports.ObjectEncoder = require("./object_encoder");
exports.Chunker = require("./chunker");
exports.StreamGenerator = require("./stream_generator");
exports.StreamReceiver = require("./stream_receiver");
exports.Dechunker = require("./dechunker");
exports.ValueDecoder = require("./value_decoder");
exports.ObjectAssembler = require("./object_assembler");

exports.Preamble = require("./preamble");
exports.Chunk = require("./chunk");

exports.Error = require("./error");

exports.wrapSyncFunction = require("./util/wrap_sync_function");
exports.isLittleEndianArchitecture = require("./util/is_little_endian_architecture");

},{"./chunk":5,"./chunker":6,"./dechunker":7,"./error":8,"./object_assembler":11,"./object_encoder":12,"./preamble":13,"./stream_generator":15,"./stream_receiver":16,"./util/is_little_endian_architecture":18,"./util/wrap_sync_function":19,"./value_decoder":20}],10:[function(require,module,exports){
(function (__dirname){
"use strict";

var child = require("child_process");

exports = module.exports = function (decodingSpecification, buffer, littleEndian, callback) {
    var c = child.fork(__dirname + "/child_module");
    c.on("message", function (message) {
        switch (message.type) {
            case "result":
                callback(null, new Uint8Array(message.result).buffer);
                break;
            default:
                break;
        }
    });
    c.on("error", function (error) {
	    c.disconnect();
        callback(error);
    });

    c.send({
        decodingSpecification: decodingSpecification,
        buffer: buffer,
	    littleEndian: littleEndian
    });
};


}).call(this,"/../node_modules/blast/lib/node")
},{"child_process":63}],11:[function(require,module,exports){
"use strict"

var util = require("util");
var Transform = require("stream").Transform;

var jpath = require("jpath");

var callImmediate = require("./util/call_immediate");

function ObjectAssembler(options) {
    Transform.call(this, {
        objectMode: true
    });

    this._decodedObject = {};
    options = options || {};

    this._async = typeof options.async !== "undefined" ? options.async : true;
}

util.inherits(ObjectAssembler, Transform);

ObjectAssembler.prototype._transform = function (decodedData, _, callback) {
    var self = this;
    callImmediate(function () {
        jpath.evaluate(decodedData.path, self._decodedObject).forEach(function (result) {
            if (result.isRoot)
                self._decodedObject = decodedData.value;
            else
                result.value = decodedData.value;
        });
        callback();
    }, this._async);
};

ObjectAssembler.prototype._flush = function (callback) {
    var self = this;
    callImmediate(function () {
        self.push(self._decodedObject);
        callback();
    }, this._async);
};

exports = module.exports = ObjectAssembler;

},{"./util/call_immediate":17,"jpath":49,"stream":72,"util":80}],12:[function(require,module,exports){
// # ObjectEncoder

// An `ObjectEncoder` is a NodeJS transform stream that transforms a given object using the specified encoders.
// Encoders are mapped to values using JPath expressions.
// ```javascript
// {
//		path: /selector
//		encoder: encoderForValueAtPath
// }
// ```
// An array of these mappings is passed to the write functions as the second argument.
// Only values that are selected by the JPath expressions are transformed.
// The path-encoder mapping can optionally include also metadata that is not encoded unconditionally
// forwarded through the stream.


// ## Encoder

// An encoder is an object that provides the following interface:

// - A function `encode` that given a value returns an `ArrayBuffer`.
// This function is called with two arguments, the value to encode and a boolean specifying if the resulting buffer
// should be in little-endian (`true`) or big-endian (`false`) format.
// Endiannes is specified with using a boolean that corresponds to the interface of the DataView in the
// TypedArray specification and can savely be passed as the second argument to all `DataView#get` and `DataView#set` methods.
// Optionally the function can take a third argument, a callback, in case the encoding is asynchronous.
// An `encode` function that takes three or a variable number of argument is considered to be asynchronous.
// The provided callback expects two parameters:
//
// 1. An error object in case anything went wrong.
// 2. The `ArrayBuffer` containing the encoded value.
//
// If the function is synchronous, errors shoud be reported by throwing an exception.
//
// - A property `decodingSpecification` that contains a URL that uniquely identifies the decoding procedure
// necessary to decode the original data from the `ArrayBuffer` returned by the `encode` function.
// This URL maybe queried for a decoding implementation at the client side using an HTTP-GET request
// with an accept-header: "application/javascript".

"use strict";

var util = require("util");
var Transform = require('stream').Transform;

var async = require("async");
var jpath = require("jpath");

var isLittleEndianArchitecture = require("./util/is_little_endian_architecture");
var wrapSyncFunction = require("./util/wrap_sync_function");
var callImmediate = require("./util/call_immediate");

// Creates an ObjectEncoder instance.
// If littleEndian is undefined the current system architecture's endianness will be used.
// The given value for littleEndian will be forwarded to all encoders.
function ObjectEncoder(options) {
	Transform.call(this, {
		objectMode: true
	});

    options = options || {};

    this._littleEndian = typeof options.littleEndian !== "undefined" ? options.littleEndian : isLittleEndianArchitecture();
    this._async = typeof options.async !== "undefined" ? options.async : true;
}

util.inherits(ObjectEncoder, Transform);

// Starts the encoding of the given object considering the given path encoder mappings.
// We do not start the encoding process directly, but delay encoding using setImmediate.
// Encoding will start as soon as the VM has retaken control and completed other pending operations.
// This is important to mimic the behavior of all NodeJS streams that are asynchronous.
// The user can now register event listeners after calling write/end without risking to
// miss events since the actual encoding will start as early as the users current control flow ends.
ObjectEncoder.prototype._transform = function (objectToEncode, selectorOptions, callback) {
    callImmediate(this._encode.bind(this, objectToEncode, selectorOptions, callback), this._async);
};

ObjectEncoder.prototype._encode = function (objectToEncode, selectorOptions, callback) {
    var self = this;
    var unmatchedParts = objectToEncode;
    var selectorOptionsCount = selectorOptions.length;
    var currentSelectorIdx = 0;
	async.eachSeries(selectorOptions, function (options, callback) {
		var results = jpath.evaluate(options.path, unmatchedParts)
		async.each(results.definedResults, function (result, callback) {
			var encoder = options.encoder;
			wrapSyncFunction(encoder.encode.bind(encoder))(result.value, self._littleEndian, function (error, encodedValue) {
				if (error)
					return self.emit("error", error);
				self.push({
                    encodedValue: encodedValue,
					path: result.path,
					decodingSpecification: encoder.decodingSpecification,
					metadata: options.metadata
				});
				callback();
			});
		}, callback);
        ++currentSelectorIdx;
        // Only evaluate unmatched part if there is another selector following
//        if (currentSelectorIdx < selectorOptionsCount)
//		    unmatchedParts = jpath.extractUncoveredParts(options.path, unmatchedParts);

	}, callback);
};

exports = module.exports = ObjectEncoder;

},{"./util/call_immediate":17,"./util/is_little_endian_architecture":18,"./util/wrap_sync_function":19,"async":22,"jpath":49,"stream":72,"util":80}],13:[function(require,module,exports){
// # Preamble

// The preamble of a blast octet stream comprises the following components:
//
// - Signature: A uint32 value equal to `0x626C7374` (ASCII encoded "blst").
// This signature value is for identification as well as endianness detection of the incoming stream.
// - Major Version: A uint8 value that specifies the major version of the incoming stream's format.
// - Minor Version: A uint8 value that specifies the minor version of the incoming stream;s format.
// - Header Decoding Specification: A NUL "\0" terminated ASCII encoded string that specifies the decoding procedure to
// encode a chunks header information.

"use strict";

var abops = require("abops");

var Preamble = {};

// ASCII blst
Object.defineProperties(Preamble, {
	/**
	 * The signature bytes that can be used to identify the octet stream and its endianness.
	 *
	 * @public
	 * @property signature
	 * @constant
	 * @type {uint32}
	 */
	signature: {
		get: function () {
			return 0x626C7374;
			// ASCII blst
		}
	},
	/**
	 * Minor version number
	 *
	 * Size: 1 Octets
	 * @public
	 * @property majorVersion
	 * @constant
	 * @type {int}
	 */
	majorVersion: {
		get: function () {
			return 0x00;
		}
	},
	/**
	 * Minor version number
	 *
	 * Size: 1 Octets
	 * @public
	 * @property minorVersion
	 * @constant
	 * @type {int}
	 */
	minorVersion: {
		get: function () {
			return 0x01;
		}
	}
});

/**
 * Constructs a blast preamble buffer containing the binary representation of the preamble in the given endianness.
 * This includes 4 octets signature bytes + 1 octet major version number + 1 octet minor version number + variable length
 * ASCII encoded NUL terminated URL for the header decoding specification.
 *
 *
 * @public
 * @function createPreambleBuffer
 * @param {string} headerDecodingSpecification A URL that uniquely identifies the decoding procedure to decode the header
 * information of the chunks in the stream.
 * @param {bool} [littleEndian = false] If true the buffer will be written in little-endian format.
 * @return {ArrayBuffer} An ArrayBuffer containing the preamble octet stream.
 */
Preamble.buffer = function (headerDecodingSpecification, littleEndian) {
	// The size of the buffer:
	// 4 octet signature + 1 octet minor version + 1 octet major version + HeaderDecoderURL as ascii + NULL byte
	var urlSize = abops.byteSizeForString(headerDecodingSpecification, "ascii") + 1;
	var bufferSize = 4 + 1 + 1 + urlSize;
	var bufferView = new DataView(new ArrayBuffer(bufferSize));
	var bufferOffset = 0;

	bufferView.setUint32(bufferOffset, Preamble.signature, littleEndian);
	bufferOffset += 4;

	bufferView.setUint8(bufferOffset, Preamble.majorVersion);
	bufferOffset += 1;

	bufferView.setUint8(bufferOffset, Preamble.minorVersion);
	bufferOffset += 1;

    abops.setCString(bufferView, bufferOffset, headerDecodingSpecification);

	return bufferView.buffer;
};

exports = module.exports = Preamble;

},{"abops":21}],14:[function(require,module,exports){
(function (process){
"use strict";

if (process.browser)
    exports = module.exports = require("./browser/run_external_decoding");
else
    exports = module.exports = require("./node/run_external_decoding");

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./browser/run_external_decoding":4,"./node/run_external_decoding":10,"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69}],15:[function(require,module,exports){
(function (process,Buffer){
// # StreamGenerator

// Generates the final output stream that can be sent over the wire.
// It takes chunks as generated by the Chunker and calls their toBuffer method.
// This buffer is then emitted in the data event.
// It also generates the preamble of the stream.
// For convinience it differentiates between NodeJS and Browser environment.
// In NodeJS the buffers are NodeJS buffers that can be piped into a server's response object.

"use strict"

var util = require("util");
var Transform = require("stream").Transform;

var jsonCodec = require("blast-codecs").json;

var BlastError = require("./error");
var Preamble = require("./preamble");
var Chunk = require("./chunk");
var wrapSyncFunction = require("./util/wrap_sync_function");
var isLittleEndianArchitecture = require("./util/is_little_endian_architecture");
var callImmediate = require("./util/call_immediate");

function StreamGenerator(options) {
    Transform.call(this);

    this._writableState.objectMode = true;
    this._readableState.objectMode = false;

    options = options || {};

    this._headerEncoder = options.headerEncoder || {
		encode: wrapSyncFunction(jsonCodec.encode.bind(jsonCodec)),
		decodingSpecification: "http://www.blast-format.com/0.1/headerDecodingSpecification/"
	};
	this._littleEndian = typeof options.littleEndian !== "undefined" ? options.littleEndian : isLittleEndianArchitecture();
    this._async = typeof options.async !== "undefined" ? options.async : true;
}

util.inherits(StreamGenerator, Transform);

StreamGenerator.prototype._transform = function (chunk, _, callback) {
	if (!this._preamblePushed)
        callImmediate(this._pushPreamble.bind(this), this._async);
    callImmediate(this._encodeChunk.bind(this, chunk, callback), this._async);
};

StreamGenerator.prototype._pushPreamble = function () {
	this._pushBuffer(Preamble.buffer(this._headerEncoder.decodingSpecification, this._littleEndian));
	this._preamblePushed = true;
};

StreamGenerator.prototype._encodeChunk = function (chunk, callback) {
	var self = this;
    this._headerEncoder.encode(chunk.headerDefinitions, this._littleEndian, function (error, headerDefinitionsBuffer) {
        if (error)
            return self.emit("error", error);

        var headerSize = headerDefinitionsBuffer.byteLength;

        // The overall buffer contains not only the header and the payload,
        // but 4 bytes for the header size and 4 bytes for the overall chunk size;
        var overallChunkSize = 4 + 4 + headerSize + chunk.payloadSize;
        var sizeBuffer = new ArrayBuffer(8);
        var sizeView = new DataView(sizeBuffer);

        sizeView.setUint32(0, overallChunkSize, self._littleEndian);
        sizeView.setUint32(4, headerSize, self._littleEndian);
        self._pushBuffer(sizeBuffer);
        self._pushBuffer(headerDefinitionsBuffer);
        chunk.payload.forEach(self._pushBuffer.bind(self));
        callback();
    });
};

StreamGenerator.prototype._pushBuffer = function (buffer) {
	this.push(toBuffer(buffer));
};

StreamGenerator.prototype._flush = function (callback) {
    var self = this;
    callImmediate(function () {
        self._pushBuffer(new ArrayBuffer(4));
        callback();
    }, this._async);
};

function toBuffer(buffer) {
	if (process.browser) {
		if (buffer instanceof ArrayBuffer)
			return buffer;
		else
			return buffer.toArrayBuffer();
	}

	if (buffer instanceof ArrayBuffer)
		return new Buffer(new Uint8Array(buffer));
	else
		return buffer;

}

exports = module.exports = StreamGenerator;

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),require("buffer").Buffer)
},{"./chunk":5,"./error":8,"./preamble":13,"./util/call_immediate":17,"./util/is_little_endian_architecture":18,"./util/wrap_sync_function":19,"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69,"blast-codecs":29,"buffer":64,"stream":72,"util":80}],16:[function(require,module,exports){
"use strict";

var util = require("util");
var Transform = require("stream").Transform;

var abops = require("abops");
var jsonCodec = require("blast-codecs").json;

var BlastError = require("./error");
var Preamble = require("./preamble");
var wrapSyncFunction = require("./util/wrap_sync_function");
var isLittleEndianArchitecture = require("./util/is_little_endian_architecture");
var callImmediate = require("./util/call_immediate");

function StreamReceiver(options) {
	Transform.call(this);

	this._writableState.objectMode = false;
	this._readableState.objectMode = true;

	this._preambleReceived = false;
	this._lastChunkReceived = false;
	this._littleEndian = undefined;
	this._headerDecoder = jsonCodec;

	this._buffer = new ArrayBuffer(0);
	this._currentBufferOffset = 0;

    options = options || {};
    this._async = typeof options.async !== "undefined" ? options.async : true;
}

util.inherits(StreamReceiver, Transform);

StreamReceiver.prototype._transform = function (data, _, callback) {
    callImmediate(this._decode.bind(this, data, callback), this._async);
};

StreamReceiver.prototype._decode = function (dataBuffer, callback) {
	// We do not expect that `dataBuffer` is a complete chunk or preamble.
	// If we haven't received a preamble yet, we expect the first data to either be the complete or at least a part of
	// the preamble.
	this._buffer = abops.concat(this._buffer, dataBuffer);
	if (!this._preambleReceived) {
		var bytesRead = this._decodePreamble(new DataView(this._buffer));
		// If bytes were read we received a complete preamble.
		if (bytesRead !== 0) {
			this._preambleReceived = true;
			this._currentBufferOffset = bytesRead;
		}
	}

	// If the last chunk (Null Chunk) was already received there cannot be more data
	if (this._lastChunkReceived)
		return this.emit("error", new BlastError("Last chunk already received!"));

	// We can only start decoding a chunk if the preamble was already received and if at least 4 Bytes can be read to get the chunks size.
	if (!this._preambleReceived || this._currentBufferOffset + 4 > this._buffer.byteLength)
        return callback();

	// We try to decode chunks until nothing can be read or the buffer is empty.
	var bytesRead;
	do {
		bytesRead = this._decodeChunk(new DataView(this._buffer, this._currentBufferOffset));
		// This is save. If bytesRead is zero nothing happens.
		this._currentBufferOffset += bytesRead;
	} while (bytesRead > 0 && this._currentBufferOffset < this._buffer.byteLength && !this._lastChunkReceived);

	// Discard current buffer if read completely.
	if (this._currentBufferOffset === this._buffer.byteLength) {
		this._buffer = new ArrayBuffer(0);
		this._currentBufferOffset = 0;
	}
    callback();
};

StreamReceiver.prototype._decodePreamble = function (bufferView) {
	// We know that every preamble has to have at least
	// 4 Byte Signature + 2 Byte Version information + 5 Byte Header decoding specification and null byte.
	// We can assume 5 byte for the header decoding specification because a URL has to have at least 4 characters to be valid,
	// One character domain name plus a dot and min. two characters tld.
	if (bufferView.byteLength < 11)
		return 0;

	var signature = bufferView.getUint32(0);
	// If the signature byte does not match we flip endianness.
	if (signature === Preamble.signature)
		this._littleEndian = false;
	else if (flipEndiannessInt32(signature) === Preamble.signature)
		this._littleEndian = true;
	else
		return this.emit("error", new BlastError("Could not identify preamble! Signature bytes do not match!"));

	this._majorVersion = bufferView.getUint8(4);
	this._minorVersion = bufferView.getUint8(5);
	var offset = 6;
    this._headerDecodingSpecification = abops.getCString(bufferView, offset);
    // One byte for the NUL char
    offset += this._headerDecodingSpecification.length + 1;

	if (offset > 6)
		return offset;

	return 0;
};

function flipEndiannessInt32(n) {
	return ((n >> 24) & 0xff) | ((n << 8) & 0xff0000) | ((n >> 8) & 0xff00) | ((n << 24) & 0xff000000);
}

StreamReceiver.prototype._decodeChunk = function (bufferView) {
	var chunkSize = bufferView.getUint32(0, this._littleEndian);

	if (bufferView.byteLength < chunkSize)
		return 0;

	// Last chunk has size 0.
	if (chunkSize === 0) {
        this._lastChunkReceived = true;
        return 4;
    }

	var headerSize = bufferView.getUint32(4, this._littleEndian);
	var headerDefinitions = this._headerDecoder.decode(bufferView.buffer.slice(bufferView.byteOffset + 8, bufferView.byteOffset + 8 + headerSize));
	var payloadOffset = 8 + headerSize;

    // Adjust the offset such that we can share a single ArrayBuffer.
    headerDefinitions.forEach(function (definition) {
        definition.offset += bufferView.byteOffset + payloadOffset;
    });

    this.push({
        payload: bufferView.buffer,
        headerDefinitions: headerDefinitions,
        littleEndian: this._littleEndian
    });

	return chunkSize;
};


exports = module.exports = StreamReceiver;

},{"./error":8,"./preamble":13,"./util/call_immediate":17,"./util/is_little_endian_architecture":18,"./util/wrap_sync_function":19,"abops":21,"blast-codecs":29,"stream":72,"util":80}],17:[function(require,module,exports){
"use strict";

require("setimmediate");

exports = module.exports = function (fn, async) {
    if (async)
        setImmediate(fn);
    else
        fn();
};

},{"setimmediate":62}],18:[function(require,module,exports){
"use strict"

exports = module.exports = function () {
    // DataView#getUint16 will read 1 on big-endian systems.
    return new DataView(new Uint16Array([256]).buffer).getUint16(0, true) === 256;
};


},{}],19:[function(require,module,exports){
"use strict";

exports = module.exports = function (fn) {
    var arity = fn.length;
    // Variable argument list means we consider this function to be async.
    if (arity === 0)
        return fn;
    // An arity of two means we have a sync. function, so we wrap it.
    if (arity === 2)
        return function (dataOrBuffer, littleEndian, callback) {
            try {
                var result = fn(dataOrBuffer, littleEndian);
                callback(null, result);
            } catch (e) {
                callback(e, null);
            }
        };
    if (arity === 3)
        return fn;

    new Error("Malformed decoding function");
};

},{}],20:[function(require,module,exports){
"use strict"

var util = require("util");
var Transform = require("stream").Transform;

var runExternalDecoding = require("./run_external_decoding");
var wrapSyncFunction = require("./util/wrap_sync_function");
var callImmediate = require("./util/call_immediate");

function ValueDecoder(options) {
    Transform.call(this, {
        objectMode: true
    });
    options = options || {};
    this._decodingSpecificationMap = options.decodingSpecificationMap || {};
    this._async = typeof options.async !== "undefined" ? options.async : true;
}

util.inherits(ValueDecoder, Transform);

ValueDecoder.prototype._transform = function (encodedData, _, callback) {
    var self = this;
    callImmediate(function () {
        var decodeFunction = runExternalDecoding.bind(undefined, encodedData.decodingSpecification);

        var codec = self._decodingSpecificationMap[encodedData.decodingSpecification]
        if (codec)
            decodeFunction = wrapSyncFunction(codec.decode ? codec.decode : codec);
        decodeFunction(encodedData.encodedValue, encodedData.littleEndian, function (error, decodedValue) {
            if (error)
                return self.emit("error", error);

            self.push({
                value: decodedValue,
                path: encodedData.path,
                metadata: encodedData.metadata
            });
            callback();
        });
    }, this._async);
};

exports = module.exports = ValueDecoder;

},{"./run_external_decoding":14,"./util/call_immediate":17,"./util/wrap_sync_function":19,"stream":72,"util":80}],21:[function(require,module,exports){
module.exports=require(2)
},{}],22:[function(require,module,exports){
(function (process){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69}],23:[function(require,module,exports){
"use strict";

var abops = require("abops");

var flipEndianessIfNecessary = require("../util/flip_endianness_if_necessary");

var normal = (1 << 0);
var tangent = (1 << 1);
var texcoord = (1 << 2);
var color = (1 << 3);

exports.encode = function (mesh, littleEndian) {
    var vertexCount = mesh.position.length / 3.0;
    var attribs = 0;

    var buffers = [flipEndianessIfNecessary(mesh.position, littleEndian)];

    if (mesh.normal) {
        attribs |= normal;
        buffers.push(flipEndianessIfNecessary(mesh.normal, littleEndian))
    }
    if (mesh.tangent) {
        attribs |= tangent;
        buffers.push(flipEndianessIfNecessary(mesh.tangent, littleEndian));
    }
    if (mesh.texcoord) {
        attribs |= texcoord;
        buffers.push(flipEndianessIfNecessary(mesh.texcoord, littleEndian));
    }
    if (mesh.color) {
        attribs |= color;
        buffers.push(flipEndianessIfNecessary(mesh.color, littleEndian));
    }
    buffers.push(flipEndianessIfNecessary(mesh.index, littleEndian));

    // 3 bytes padding to align following buffer to 4 byte boundaries as neccessary.
    buffers.unshift(new ArrayBuffer(3));
    buffers.unshift(new Uint8Array([attribs]));

    buffers.unshift(flipEndianessIfNecessary(new Uint32Array([vertexCount]), littleEndian));

    return buffers;
};

exports.decode = function (buffer, littleEndian) {
    var view = new DataView(buffer);
    var offset = 0;
    var vertexCount = view.getUint32(offset, littleEndian);
    offset += 4;
    var attribs = view.getUint8(offset);
    offset += 4;

    var mesh = {
        position: flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 3), littleEndian)
    };
    offset += vertexCount * 3 * mesh.position.BYTES_PER_ELEMENT;

    if (attribs & normal) {
        mesh.normal = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 3), littleEndian);
        offset += vertexCount * 3 * mesh.normal.BYTES_PER_ELEMENT;
    }
    if (attribs & tangent) {
        mesh.tangent = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 3), littleEndian);
        offset += vertexCount * 3 * mesh.tangent.BYTES_PER_ELEMENT;
    }
    if (attribs & texcoord) {
        mesh.texcoord = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 2), littleEndian);
        offset += vertexCount * 2 * mesh.texcoord.BYTES_PER_ELEMENT;
    }
    if (attribs & color) {
        mesh.color = flipEndianessIfNecessary(new Float32Array(buffer, offset, vertexCount * 4), littleEndian);
        offset += vertexCount * 4 * mesh.color.BYTES_PER_ELEMENT;
    }

    mesh.index = flipEndianessIfNecessary(new Uint32Array(buffer, offset), littleEndian);

    return mesh;
};

},{"../util/flip_endianness_if_necessary":30,"abops":32}],24:[function(require,module,exports){
// # JSON Codec

// This simple codec simply uses `JSON.stringify` and `JSON.parse` to encode and decode the given data.

"use strict";

var abops = require("abops");

/**
 * Encodes the given value using JSON.stringify.
 * This string representation will be written into an ArrayBuffer using UTF-8 encoding.
 * The second dummy parameter is only for compatibility with the core library that expects
 * encoders to provide a little-endian parameter to specify the format in which multi-byte values will
 * be written into a buffer.
 * Since we write UTF-8 encoded strings endianness is irrelevant.
 *
 * @public
 * @function encode
 * @param {Mixed} object The value to encode.
 * @returns {ArrayBuffer} An ArrayBuffer containing the UTF-8 encoded string representation of the given value.
 */
exports.encode = function (object, _) {
    return abops.bufferForString(JSON.stringify(object));
};

/**
 * Decodes the given DataView using JSON.parse.
 * It reads the UTF-8 encoded string referenced by the DataView and parses that string assuming that
 * it is a string serialization produced by JSON.stringify or something equivalent.
 *
 * @param {DataView} view The DataView that specifies the buffer and the range from which the string representation will be extracted.
 * @returns {Mixed}
 */
exports.decode = function (buffer, _) {
    return JSON.parse(abops.getString(buffer, 0, "utf-8"));
};

},{"abops":32}],25:[function(require,module,exports){
"use strict";

var o3dgc = require("o3dgc");

var flipEndianessIfNecessary = require("../util/flip_endianness_if_necessary");

exports.encode = function (mesh, littleEndian) {
    return o3dgc.toBuffer({
        position: flipEndianessIfNecessary(mesh.position, littleEndian),
        normal: mesh.normal ? flipEndianessIfNecessary(mesh.normal, littleEndian) : undefined,
        tangent: mesh.tangent ? flipEndianessIfNecessary(mesh.tangent, littleEndian) : undefined,
        texcoord: mesh.texcoord ? flipEndianessIfNecessary(mesh.texcoord, littleEndian) : undefined,
        color: mesh.color ? flipEndianessIfNecessary(mesh.color, littleEndian) : undefined,
        index: flipEndianessIfNecessary(mesh.index, littleEndian)
    }, true);
};

exports.decode = function (buffer, littleEndian) {
    var mesh = o3dgc.fromBuffer(buffer);

    mesh.position = flipEndianessIfNecessary(mesh.position, littleEndian);
    mesh.index = flipEndianessIfNecessary(mesh.index, littleEndian);
    if (mesh.normal)
        mesh.normal = flipEndianessIfNecessary(mesh.normal, littleEndian);
    if (mesh.tangent)
        mesh.tangent = flipEndianessIfNecessary(mesh.tangent, littleEndian);
    if (mesh.texcoord)
        mesh.texcoord = flipEndianessIfNecessary(mesh.texcoord, littleEndian);
    if (mesh.color)
        mesh.color = flipEndianessIfNecessary(mesh.color, littleEndian);

    return mesh;
};

},{"../util/flip_endianness_if_necessary":30,"o3dgc":33}],26:[function(require,module,exports){
"use strict";

var o3dgc = require("o3dgc");

var flipEndianessIfNecessary = require("../util/flip_endianness_if_necessary");

exports.encode = function (mesh, littleEndian) {
    return o3dgc.toBuffer({
        position: flipEndianessIfNecessary(mesh.position, littleEndian),
        normal: mesh.normal ? flipEndianessIfNecessary(mesh.normal, littleEndian) : undefined,
        tangent: mesh.tangent ? flipEndianessIfNecessary(mesh.tangent, littleEndian) : undefined,
        texcoord: mesh.texcoord ? flipEndianessIfNecessary(mesh.texcoord, littleEndian) : undefined,
        color: mesh.color ? flipEndianessIfNecessary(mesh.color, littleEndian) : undefined,
        index: flipEndianessIfNecessary(mesh.index, littleEndian)
    });
};

exports.decode = function (buffer, littleEndian) {
    var mesh = o3dgc.fromBuffer(buffer);

    mesh.position = flipEndianessIfNecessary(mesh.position, littleEndian);
    mesh.index = flipEndianessIfNecessary(mesh.index, littleEndian);
    if (mesh.normal)
        mesh.normal = flipEndianessIfNecessary(mesh.normal, littleEndian);
    if (mesh.tangent)
        mesh.tangent = flipEndianessIfNecessary(mesh.tangent, littleEndian);
    if (mesh.texcoord)
        mesh.texcoord = flipEndianessIfNecessary(mesh.texcoord, littleEndian);
    if (mesh.color)
        mesh.color = flipEndianessIfNecessary(mesh.color, littleEndian);

    return mesh;
};

},{"../util/flip_endianness_if_necessary":30,"o3dgc":33}],27:[function(require,module,exports){
"use strict";

var openctm = require("openctm");

var flipEndianessIfNecessary = require("../util/flip_endianness_if_necessary");

exports.encode = function (mesh, littleEndian) {
    return openctm.toBuffer({
        position: flipEndianessIfNecessary(mesh.position, littleEndian),
        normal: mesh.normal ? flipEndianessIfNecessary(mesh.normal, littleEndian) : undefined,
        tangent: mesh.tangent ? flipEndianessIfNecessary(mesh.tangent, littleEndian) : undefined,
        texcoord: mesh.texcoord ? flipEndianessIfNecessary(mesh.texcoord, littleEndian) : undefined,
        color: mesh.color ? flipEndianessIfNecessary(mesh.color, littleEndian) : undefined,
        index: flipEndianessIfNecessary(mesh.index, littleEndian)
    });
};

exports.decode = function (buffer, littleEndian) {
    var mesh = openctm.fromBuffer(buffer);

    mesh.position = flipEndianessIfNecessary(mesh.position, littleEndian);
    mesh.index = flipEndianessIfNecessary(mesh.index, littleEndian);
    if (mesh.normal)
        mesh.normal = flipEndianessIfNecessary(mesh.normal, littleEndian);
    if (mesh.tangent)
        mesh.tangent = flipEndianessIfNecessary(mesh.tangent, littleEndian);
    if (mesh.texcoord)
        mesh.texcoord = flipEndianessIfNecessary(mesh.texcoord, littleEndian);
    if (mesh.color)
        mesh.color = flipEndianessIfNecessary(mesh.color, littleEndian);

    return mesh;
};

},{"../util/flip_endianness_if_necessary":30,"openctm":36}],28:[function(require,module,exports){
"use strict";

exports.encode = function (buffer, littleEndian) {
	return buffer;
};

exports.decode = function (buffer, littleEndian) {
	return buffer;
};

},{}],29:[function(require,module,exports){
(function (process){
"use strict";

exports.json = require("./codecs/json");
exports.passthrough = require("./codecs/passthrough");
exports.assimpMesh = require("./codecs/assimp_mesh");
exports.openctm = require("./codecs/openctm");
exports.o3dgc = require("./codecs/o3dgc");
exports.o3dgcASCII = require("./codecs/o3dgc_ascii");

exports.isLittleEndianArchitecture = require("./util/is_little_endian_architecture");

if (!process.browser)
    exports.serveCodecs = require("./util/" + "append_routes");

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./codecs/assimp_mesh":23,"./codecs/json":24,"./codecs/o3dgc":25,"./codecs/o3dgc_ascii":26,"./codecs/openctm":27,"./codecs/passthrough":28,"./util/is_little_endian_architecture":31,"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69}],30:[function(require,module,exports){
"use strict";

var abops = require("abops");
var isLittleEndianArchitecture = require("./is_little_endian_architecture");

exports = module.exports = function (typedArray, littleEndian) {
    if (littleEndian !== isLittleEndianArchitecture())
        return abops.flipEndianness(typedArray);
    return typedArray;
};

},{"./is_little_endian_architecture":31,"abops":32}],31:[function(require,module,exports){
module.exports=require(18)
},{}],32:[function(require,module,exports){
module.exports=require(2)
},{}],33:[function(require,module,exports){
(function (process){
if (!process.browser)
	exports.toBuffer = require("./build/Release/" + "o3dgc");

exports.fromBuffer = require("./lib/from_buffer");


}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./lib/from_buffer":34,"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69}],34:[function(require,module,exports){
"use strict";

var o3dgc = require("./o3dgc");

exports = module.exports = function (data) {
	var stream = new o3dgc.BinaryStream(data);

	var decoder = new o3dgc.SC3DMCDecoder();
	var ifs = new o3dgc.IndexedFaceSet();
	decoder.DecodeHeader(ifs, stream);

    var mesh = {};
	mesh.index = new Uint32Array(3 * ifs.GetNCoordIndex())
	ifs.SetCoordIndex(mesh.index);

    mesh.position = new Float32Array(3 * ifs.GetNCoord());
	ifs.SetCoord(mesh.position);

    if (ifs.GetNNormal() > 0) {
	    mesh.normal = new Float32Array(3 * ifs.GetNNormal());
	    ifs.SetNormal(mesh.normal);
    }

    var texcoord = getFloatAttribute(ifs, 0);
    if (texcoord)
        mesh.texcoord = texcoord;

    var tangent = getFloatAttribute(ifs, 1);
    if (tangent)
        mesh.tangent = tangent;

    var color = getFloatAttribute(ifs, 2);
    if (color)
        mesh.color = color;

	decoder.DecodePlayload(ifs, stream);

    return mesh;
};

function getFloatAttribute(ifs, idx) {
    if (ifs.GetNFloatAttribute(idx) > 0) {
        var values = new Float32Array(ifs.GetFloatAttributeDim(idx) * ifs.GetNFloatAttribute(idx));
        ifs.SetFloatAttribute(idx, values);
        return values;
    }
}

},{"./o3dgc":35}],35:[function(require,module,exports){
(function (global){
/*global ArrayBuffer, Uint32Array, Int32Array, Float32Array, Int8Array, Uint8Array, window, performance, Console*/

/*
Copyright (c) 2013 Khaled Mammou - Advanced Micro Devices, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

if (typeof window === "undefined")
    window = global;

exports = module.exports = (function () {
    "use strict";
    var module, local;
    module = {};
    local = {};
    local.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0 = 7;
    local.O3DGC_BINARY_STREAM_MAX_SYMBOL0 = 127; // ((1 << O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0) >>> 0) - 1;
    local.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL1 = 6;
    local.O3DGC_BINARY_STREAM_MAX_SYMBOL1 = 63; // ((1 << O3DGC_BINARY_STREAM_BITS_PER_SYMBOL1) >>> 0) - 1;
    local.O3DGC_BINARY_STREAM_NUM_SYMBOLS_UINT32 = 5; // Math.floor((32 + O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0 - 1) / O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0);
    local.O3DGC_BIG_ENDIAN = 0;
    local.O3DGC_LITTLE_ENDIAN = 1;
    local.O3DGC_MAX_DOUBLE = 1.79769e+308;
    local.O3DGC_MIN_LONG = -2147483647;
    local.O3DGC_MAX_LONG = 2147483647;
    local.O3DGC_MAX_UCHAR8 = 255;
    local.O3DGC_MAX_TFAN_SIZE = 256;
    local.O3DGC_MAX_ULONG = 4294967295;
    local.O3DGC_SC3DMC_START_CODE = 0x00001F1;
    local.O3DGC_DV_START_CODE = 0x00001F2;
    local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES = 256;
    local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES = 256;
    local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES = 32;
    local.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS = 2;
    local.O3DGC_SC3DMC_BINARIZATION_FL = 0; // Fixed Length (not supported)
    local.O3DGC_SC3DMC_BINARIZATION_BP = 1; // BPC (not supported)
    local.O3DGC_SC3DMC_BINARIZATION_FC = 2; // 4 bits Coding (not supported)
    local.O3DGC_SC3DMC_BINARIZATION_AC = 3; // Arithmetic Coding (not supported)
    local.O3DGC_SC3DMC_BINARIZATION_AC_EGC = 4; // Arithmetic Coding & EGCk
    local.O3DGC_SC3DMC_BINARIZATION_ASCII = 5; // Arithmetic Coding & EGCk
    local.O3DGC_STREAM_TYPE_UNKOWN = 0;
    local.O3DGC_STREAM_TYPE_ASCII = 1;
    local.O3DGC_STREAM_TYPE_BINARY = 2;
    local.O3DGC_SC3DMC_NO_PREDICTION = 0; // supported
    local.O3DGC_SC3DMC_DIFFERENTIAL_PREDICTION = 1; // supported
    local.O3DGC_SC3DMC_XOR_PREDICTION = 2; // not supported
    local.O3DGC_SC3DMC_ADAPTIVE_DIFFERENTIAL_PREDICTION = 3; // not supported
    local.O3DGC_SC3DMC_CIRCULAR_DIFFERENTIAL_PREDICTION = 4; // not supported
    local.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION = 5; // supported
    local.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION = 6; // supported
    local.O3DGC_SC3DMC_ENCODE_MODE_QBCR = 0; // not supported
    local.O3DGC_SC3DMC_ENCODE_MODE_SVA = 1; // not supported
    local.O3DGC_SC3DMC_ENCODE_MODE_TFAN = 2; // supported
    local.O3DGC_DYNAMIC_VECTOR_ENCODE_MODE_LIFT = 0;
    local.O3DGC_MIN_NEIGHBORS_SIZE = 128;
    local.O3DGC_MIN_NUM_NEIGHBORS_SIZE = 16;
    local.O3DGC_TFANS_MIN_SIZE_ALLOCATED_VERTICES_BUFFER = 128;
    local.O3DGC_TFANS_MIN_SIZE_TFAN_SIZE_BUFFER = 8;
    local.O3DGC_DEFAULT_VECTOR_SIZE = 32;

    module.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_UNKOWN = 0;
    module.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_POSITION = 1;
    module.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_NORMAL = 2;
    module.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_COLOR = 3;
    module.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_TEXCOORD = 4;
    module.O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_WEIGHT = 5;
    module.O3DGC_IFS_INT_ATTRIBUTE_TYPE_UNKOWN = 0;
    module.O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX = 1;
    module.O3DGC_IFS_INT_ATTRIBUTE_TYPE_JOINT_ID = 2;
    module.O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX_BUFFER_ID = 3;

    module.O3DGC_OK = 0;
    module.O3DGC_ERROR_BUFFER_FULL = 1;
    module.O3DGC_ERROR_CORRUPTED_STREAM = 5;
    module.O3DGC_ERROR_NON_SUPPORTED_FEATURE = 6;
    module.O3DGC_ERROR_AC = 7;

    function SystemEndianness() {
        var a, b, c;
        b = new ArrayBuffer(4);
        a = new Uint32Array(b);
        c = new Uint8Array(b);
        a[0] = 1;
        if (c[0] === 1) {
            return local.O3DGC_LITTLE_ENDIAN;
        }
        return local.O3DGC_BIG_ENDIAN;
    }
    // SC3DMCStats class
    module.SC3DMCStats = function () {
        this.m_timeCoord = 0;
        this.m_timeNormal = 0;
        this.m_timeCoordIndex = 0;
        this.m_timeFloatAttribute = new Float32Array(local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES);
        this.m_timeIntAttribute = new Float32Array(local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES);
        this.m_timeReorder = 0;
        this.m_streamSizeCoord = 0;
        this.m_streamSizeNormal = 0;
        this.m_streamSizeCoordIndex = 0;
        this.m_streamSizeFloatAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES);
        this.m_streamSizeIntAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES);
    };
    // SC3DMCTriplet class
    module.SC3DMCTriplet = function (a, b, c) {
        this.m_a = a;
        this.m_b = b;
        this.m_c = c;
    };
    module.SC3DMCTriplet.prototype.Less = function (rhs) {
        var res;
        if (this.m_c !== rhs.m_c) {
            res = (this.m_c < rhs.m_c);
        } else if (this.m_b !== rhs.m_b) {
            res = (this.m_b < rhs.m_b);
        } else {
            res = (this.m_a < rhs.m_a);
        }
        return res;
    };
    module.SC3DMCTriplet.prototype.Equal = function (rhs) {
        return (this.m_c === rhs.m_c && this.m_b === rhs.m_b && this.m_a === rhs.m_a);
    };
    // SC3DMCPredictor class
    module.SC3DMCPredictor = function () {
        this.m_id = new module.SC3DMCTriplet(-1, -1, -1);
        this.m_pred = new Float32Array(local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES);
    };
    // fix me: optimize this function (e.g., binary search)
    function InsertPredictor(e, nPred, list, dimFloatArray) {
        var pos, foundOrInserted, j, j1, j0, h, i;
        pos = -1;
        foundOrInserted = false;
        j1 = nPred.m_value;
        j0 = 0;
        for (j = j0; j < j1; ++j) {
            if (e.Equal(list[j].m_id)) {
                foundOrInserted = true;
                break;
            } else if (e.Less(list[j].m_id)) {
                if (nPred.m_value < local.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS) {
                    ++nPred.m_value;
                }
                for (h = nPred.m_value - 1; h > j; --h) {
                    list[h].m_id.m_a = list[h - 1].m_id.m_a;
                    list[h].m_id.m_b = list[h - 1].m_id.m_b;
                    list[h].m_id.m_c = list[h - 1].m_id.m_c;
                    for (i = 0; i < dimFloatArray; ++i) {
                        list[h].m_pred[i] = list[h - 1].m_pred[i];
                    }
                }
                list[j].m_id.m_a = e.m_a;
                list[j].m_id.m_b = e.m_b;
                list[j].m_id.m_c = e.m_c;
                pos = j;
                foundOrInserted = true;
                break;
            }
        }
        if (!foundOrInserted && nPred.m_value < local.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS) {
            pos = nPred.m_value++;
            list[pos].m_id.m_a = e.m_a;
            list[pos].m_id.m_b = e.m_b;
            list[pos].m_id.m_c = e.m_c;
        }
        return pos;
    }
    // Timer class
    if (typeof window.performance === 'undefined') {
        window.performance = {};
    }
    if (!window.performance.now) {
        local.nowOffset = Date.now();
        if (performance.timing && performance.timing.navigationStart) {
            local.nowOffset = performance.timing.navigationStart;
        }
        window.performance.now = function now() {
            return Date.now() - local.nowOffset;
        };
    }
    module.Timer = function () {
        this.m_start = 0;
        this.m_end = 0;
    };
    module.Timer.prototype.Tic = function () {
        this.m_start = window.performance.now();
    };
    module.Timer.prototype.Toc = function () {
        this.m_end = window.performance.now();
    };
    module.Timer.prototype.GetElapsedTime = function () {
        return this.m_end - this.m_start;
    };
    // Vec3 class
    module.Vec3 = function (x, y, z) {
        this.m_x = x;
        this.m_y = y;
        this.m_z = z;
    };
    module.Vec3.prototype.Set = function (x, y, z) {
        this.m_x = x;
        this.m_y = y;
        this.m_z = z;
    };
    module.Vec3.prototype.Sub = function (lhs, rhs) {
        this.m_x = lhs.m_x - rhs.m_x;
        this.m_y = lhs.m_y - rhs.m_y;
        this.m_z = lhs.m_z - rhs.m_z;
    };
    module.Vec3.prototype.Add = function (lhs, rhs) {
        this.m_x = lhs.m_x + rhs.m_x;
        this.m_y = lhs.m_y + rhs.m_y;
        this.m_z = lhs.m_z + rhs.m_z;
    };
    module.Vec3.prototype.SelfAdd = function (v) {
        this.m_x += v.m_x;
        this.m_y += v.m_y;
        this.m_z += v.m_z;
    };
    module.Vec3.prototype.Cross = function (lhs, rhs) {
        this.m_x = lhs.m_y * rhs.m_z - lhs.m_z * rhs.m_y;
        this.m_y = lhs.m_z * rhs.m_x - lhs.m_x * rhs.m_z;
        this.m_z = lhs.m_x * rhs.m_y - lhs.m_y * rhs.m_x;
    };
    module.Vec3.prototype.GetNorm = function () {
        return Math.sqrt(this.m_x * this.m_x + this.m_y * this.m_y + this.m_z * this.m_z);
    };
    function SphereToCube(vin, vout) {
        var ax, ay, az;
        ax = Math.abs(vin.m_x);
        ay = Math.abs(vin.m_y);
        az = Math.abs(vin.m_z);
        if (az >= ax && az >= ay) {
            if (vin.m_z >= 0) {
                vout.m_z = 0;
                vout.m_x = vin.m_x;
                vout.m_y = vin.m_y;
            } else {
                vout.m_z = 1;
                vout.m_x = -vin.m_x;
                vout.m_y = -vin.m_y;
            }
        } else if (ay >= ax && ay >= az) {
            if (vin.m_y >= 0) {
                vout.m_z = 2;
                vout.m_x = vin.m_z;
                vout.m_y = vin.m_x;
            } else {
                vout.m_z = 3;
                vout.m_x = -vin.m_z;
                vout.m_y = -vin.m_x;
            }
        } else {
            if (vin.m_x >= 0) {
                vout.m_z = 4;
                vout.m_x = vin.m_y;
                vout.m_y = vin.m_z;
            } else {
                vout.m_z = 5;
                vout.m_x = -vin.m_y;
                vout.m_y = -vin.m_z;
            }
        }
    }
    local.CubeToSphere = {
        0: function (vin, vout) {
            vout.m_x = vin.m_x;
            vout.m_y = vin.m_y;
            vout.m_z = Math.sqrt(Math.max(0.0, 1.0 - vout.m_x * vout.m_x - vout.m_y * vout.m_y));
        },
        1: function (vin, vout) {
            vout.m_x = -vin.m_x;
            vout.m_y = -vin.m_y;
            vout.m_z = -Math.sqrt(Math.max(0.0, 1.0 - vout.m_x * vout.m_x - vout.m_y * vout.m_y));
        },
        2: function (vin, vout) {
            vout.m_z = vin.m_x;
            vout.m_x = vin.m_y;
            vout.m_y = Math.sqrt(Math.max(0.0, 1.0 - vout.m_x * vout.m_x - vout.m_z * vout.m_z));
        },
        3: function (vin, vout) {
            vout.m_z = -vin.m_x;
            vout.m_x = -vin.m_y;
            vout.m_y = -Math.sqrt(Math.max(0.0, 1.0 - vout.m_x * vout.m_x - vout.m_z * vout.m_z));
        },
        4: function (vin, vout) {
            vout.m_y = vin.m_x;
            vout.m_z = vin.m_y;
            vout.m_x = Math.sqrt(Math.max(0.0, 1.0 - vout.m_y * vout.m_y - vout.m_z * vout.m_z));
        },
        5: function (vin, vout) {
            vout.m_y = -vin.m_x;
            vout.m_z = -vin.m_y;
            vout.m_x = -Math.sqrt(Math.max(0.0, 1.0 - vout.m_y * vout.m_y - vout.m_z * vout.m_z));
        }
    };
    function IntToUInt(value) {
        return (value < 0) ? (-1 - (2 * value)) : (2 * value);
    }
    function UIntToInt(uiValue) {
        return (uiValue & 1) ? -((uiValue + 1) >>> 1) : ((uiValue >>> 1));
    }
    module.Iterator = function () {
        this.m_count = 0;
    };
    module.NumberRef = function () {
        this.m_value = 0;
    };
    // BinaryStream class
    module.BinaryStream = function (buffer) {
        this.m_endianness = SystemEndianness();
        this.m_buffer = buffer;
        this.m_stream = new Uint8Array(this.m_buffer);
        this.m_localBuffer = new ArrayBuffer(4);
        this.m_localBufferViewUChar8 = new Uint8Array(this.m_localBuffer);
        this.m_localBufferViewFloat32 = new Float32Array(this.m_localBuffer);
        this.m_localBufferViewUInt32 = new Uint32Array(this.m_localBuffer);
    };
    module.BinaryStream.prototype.ReadFloat32Bin = function (bsIterator) {
        if (this.m_endianness === local.O3DGC_BIG_ENDIAN) {
            this.m_localBufferViewUChar8[3] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[2] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[1] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[0] = this.m_stream[bsIterator.m_count++];
        } else {
            this.m_localBufferViewUChar8[0] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[1] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[2] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[3] = this.m_stream[bsIterator.m_count++];
        }
        return this.m_localBufferViewFloat32[0];
    };
    module.BinaryStream.prototype.ReadUInt32Bin = function (bsIterator) {
        if (this.m_endianness === local.O3DGC_BIG_ENDIAN) {
            this.m_localBufferViewUChar8[3] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[2] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[1] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[0] = this.m_stream[bsIterator.m_count++];
        } else {
            this.m_localBufferViewUChar8[0] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[1] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[2] = this.m_stream[bsIterator.m_count++];
            this.m_localBufferViewUChar8[3] = this.m_stream[bsIterator.m_count++];
        }
        return this.m_localBufferViewUInt32[0];
    };
    module.BinaryStream.prototype.ReadUChar8Bin = function (bsIterator) {
        return this.m_stream[bsIterator.m_count++];
    };
    module.BinaryStream.prototype.ReadUInt32ASCII = function (bsIterator) {
        var value, shift, i;
        value = 0;
        shift = 0;
        for (i = 0; i < local.O3DGC_BINARY_STREAM_NUM_SYMBOLS_UINT32; ++i) {
            value += (this.m_stream[bsIterator.m_count++] << shift) >>> 0;
            shift += local.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0;
        }
        return value;
    };
    module.BinaryStream.prototype.ReadFloat32ASCII = function (bsIterator) {
        var value = this.ReadUInt32ASCII(bsIterator);
        if (this.m_endianness === local.O3DGC_BIG_ENDIAN) {
            this.m_localBufferViewUChar8[3] = value & local.O3DGC_MAX_UCHAR8;
            value >>>= 8;
            this.m_localBufferViewUChar8[2] = value & local.O3DGC_MAX_UCHAR8;
            value >>>= 8;
            this.m_localBufferViewUChar8[1] = value & local.O3DGC_MAX_UCHAR8;
            value >>>= 8;
            this.m_localBufferViewUChar8[0] = value & local.O3DGC_MAX_UCHAR8;
        } else {
            this.m_localBufferViewUChar8[0] = value & local.O3DGC_MAX_UCHAR8;
            value >>>= 8;
            this.m_localBufferViewUChar8[1] = value & local.O3DGC_MAX_UCHAR8;
            value >>>= 8;
            this.m_localBufferViewUChar8[2] = value & local.O3DGC_MAX_UCHAR8;
            value >>>= 8;
            this.m_localBufferViewUChar8[3] = value & local.O3DGC_MAX_UCHAR8;
        }
        return this.m_localBufferViewFloat32[0];
    };
    module.BinaryStream.prototype.ReadIntASCII = function (bsIterator) {
        return UIntToInt(this.ReadUIntASCII(bsIterator));
    };
    module.BinaryStream.prototype.ReadUIntASCII = function (bsIterator) {
        var i, x, value;
        value = this.m_stream[bsIterator.m_count++];
        if (value === local.O3DGC_BINARY_STREAM_MAX_SYMBOL0) {
            i = 0;
            do {
                x = this.m_stream[bsIterator.m_count++];
                value += ((x >>> 1) << i) >>> 0;
                i += local.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL1;
            } while (x & 1);
        }
        return value;
    };
    module.BinaryStream.prototype.ReadUCharASCII = function (bsIterator) {
        return this.m_stream[bsIterator.m_count++];
    };
    module.BinaryStream.prototype.ReadFloat32 = function (bsIterator, streamType) {
        if (streamType === local.O3DGC_STREAM_TYPE_ASCII) {
            return this.ReadFloat32ASCII(bsIterator);
        }
        return this.ReadFloat32Bin(bsIterator);
    };
    module.BinaryStream.prototype.ReadUInt32 = function (bsIterator, streamType) {
        if (streamType === local.O3DGC_STREAM_TYPE_ASCII) {
            return this.ReadUInt32ASCII(bsIterator);
        }
        return this.ReadUInt32Bin(bsIterator);
    };
    module.BinaryStream.prototype.ReadUChar = function (bsIterator, streamType) {
        if (streamType === local.O3DGC_STREAM_TYPE_ASCII) {
            return this.ReadUCharASCII(bsIterator);
        }
        return this.ReadUChar8Bin(bsIterator);
    };
    module.BinaryStream.prototype.GetBuffer = function (bsIterator, size) {
        return new Uint8Array(this.m_buffer, bsIterator.m_count, size);
    };

    // Copyright (c) 2004 Amir Said (said@ieee.org) & William A. Pearlman (pearlw@ecse.rpi.edu)
    // All rights reserved.

    local.O3DGC_AC_MIN_LENGTH = 0x01000000;   // threshold for renormalization
    local.O3DGC_AC_MAX_LENGTH = 0xFFFFFFFF;      // maximum AC interval length
    local.O3DGC_AC_BM_LENGTH_SHIFT = 13;     // Maximum values for binary models length bits discarded before mult.
    local.O3DGC_AC_BM_MAX_COUNT = (1 << local.O3DGC_AC_BM_LENGTH_SHIFT) >>> 0;  // for adaptive models
    local.O3DGC_AC_DM_LENGTH_SHIFT = 15; // Maximum values for general models length bits discarded before mult.
    local.O3DGC_AC_DM_MAX_COUNT = (1 << local.O3DGC_AC_DM_LENGTH_SHIFT) >>> 0;  // for adaptive models
    // StaticBitModel class 
    module.StaticBitModel = function () {
        this.m_bit0Prob = (1 << (local.O3DGC_AC_BM_LENGTH_SHIFT - 1)) >>> 0; // p0 = 0.5
    };
    module.StaticBitModel.prototype.SetProbability = function (p) {
        this.m_bit0Prob = Math.floor(p * ((1 << local.O3DGC_AC_BM_LENGTH_SHIFT) >>> 0));
    };
    // AdaptiveBitModel class 
    module.AdaptiveBitModel = function () {
        // initialization to equiprobable model
        this.m_updateCycle = 4;
        this.m_bitsUntilUpdate = 4;
        this.m_bit0Prob = (1 << (local.O3DGC_AC_BM_LENGTH_SHIFT - 1)) >>> 0;
        this.m_bit0Count = 1;
        this.m_bitCount = 2;
    };
    module.AdaptiveBitModel.prototype.Reset = function () {
        this.m_updateCycle = 4;
        this.m_bitsUntilUpdate = 4;
        this.m_bit0Prob = (1 << (local.O3DGC_AC_BM_LENGTH_SHIFT - 1)) >>> 0;
        this.m_bit0Count = 1;
        this.m_bitCount = 2;
    };
    module.AdaptiveBitModel.prototype.Update = function () {
        // halve counts when a threshold is reached
        if ((this.m_bitCount += this.m_updateCycle) > local.O3DGC_AC_BM_MAX_COUNT) {
            this.m_bitCount = (this.m_bitCount + 1) >>> 1;
            this.m_bit0Count = (this.m_bit0Count + 1) >>> 1;
            if (this.m_bit0Count === this.m_bitCount) {
                ++this.m_bitCount;
            }
        }
        // compute scaled bit 0 probability
        var scale = Math.floor(0x80000000 / this.m_bitCount);
        this.m_bit0Prob = (this.m_bit0Count * scale) >>> (31 - local.O3DGC_AC_BM_LENGTH_SHIFT);
        // set frequency of model updates
        this.m_updateCycle = (5 * this.m_updateCycle) >>> 2;
        if (this.m_updateCycle > 64) {
            this.m_updateCycle = 64;
        }
        this.m_bitsUntilUpdate = this.m_updateCycle;
    };
    // AdaptiveDataModel class 
    module.AdaptiveDataModel = function () {
        this.m_buffer = {};
        this.m_distribution = {};
        this.m_symbolCount = {};
        this.m_decoderTable = {};
        this.m_totalCount = 0;
        this.m_updateCycle = 0;
        this.m_symbolsUntilUpdate = 0;
        this.m_dataSymbols = 0;
        this.m_lastSymbol = 0;
        this.m_tableSize = 0;
        this.m_tableShift = 0;
    };
    module.AdaptiveDataModel.prototype.Update = function () {
        var n, sum, s, scale, k, max_cycle, w;
        // halve counts when a threshold is reached
        if ((this.m_totalCount += this.m_updateCycle) > local.O3DGC_AC_DM_MAX_COUNT) {
            this.m_totalCount = 0;
            for (n = 0; n < this.m_dataSymbols; ++n) {
                this.m_totalCount += (this.m_symbolCount[n] = (this.m_symbolCount[n] + 1) >>> 1);
            }
        }
        // compute cumulative distribution, decoder table
        sum = 0;
        s = 0;
        scale = Math.floor(0x80000000 / this.m_totalCount);
        if (this.m_tableSize === 0) {
            for (k = 0; k < this.m_dataSymbols; ++k) {
                this.m_distribution[k] = (scale * sum) >>> (31 - local.O3DGC_AC_DM_LENGTH_SHIFT);
                sum += this.m_symbolCount[k];
            }
        } else {
            for (k = 0; k < this.m_dataSymbols; ++k) {
                this.m_distribution[k] = (scale * sum) >>> (31 - local.O3DGC_AC_DM_LENGTH_SHIFT);
                sum += this.m_symbolCount[k];
                w = this.m_distribution[k] >>> this.m_tableShift;
                while (s < w) {
                    this.m_decoderTable[++s] = k - 1;
                }
            }
            this.m_decoderTable[0] = 0;
            while (s <= this.m_tableSize) {
                this.m_decoderTable[++s] = this.m_dataSymbols - 1;
            }
        }
        // set frequency of model updates
        this.m_updateCycle = (5 * this.m_updateCycle) >>> 2;
        max_cycle = ((this.m_dataSymbols + 6) << 3) >>> 0;
        if (this.m_updateCycle > max_cycle) {
            this.m_updateCycle = max_cycle;
        }
        this.m_symbolsUntilUpdate = this.m_updateCycle;
    };
    module.AdaptiveDataModel.prototype.Reset = function () {
        var k;
        if (this.m_dataSymbols === 0) {
            return;
        }
        // restore probability estimates to uniform distribution
        this.m_totalCount = 0;
        this.m_updateCycle = this.m_dataSymbols;
        for (k = 0; k < this.m_dataSymbols; ++k) {
            this.m_symbolCount[k] = 1;
        }
        this.Update();
        this.m_symbolsUntilUpdate = this.m_updateCycle = (this.m_dataSymbols + 6) >>> 1;
    };
    module.AdaptiveDataModel.prototype.SetAlphabet = function (number_of_symbols) {
        if ((number_of_symbols < 2) || (number_of_symbols > (1 << 11))) {
            Console.log("invalid number of data symbols");
            return module.O3DGC_ERROR_AC;
        }
        if (this.m_dataSymbols !== number_of_symbols) { // assign memory for data model
            this.m_dataSymbols = number_of_symbols;
            this.m_lastSymbol = this.m_dataSymbols - 1;
            // define size of table for fast decoding
            if (this.m_dataSymbols > 16) {
                var table_bits = 3;
                while (this.m_dataSymbols > ((1 << (table_bits + 2)) >>> 0)) {
                    ++table_bits;
                }
                this.m_tableSize = (1 << table_bits) >>> 0;
                this.m_tableShift = local.O3DGC_AC_DM_LENGTH_SHIFT - table_bits;
                this.m_buffer = new ArrayBuffer(4 * (2 * this.m_dataSymbols + this.m_tableSize + 2));
                this.m_distribution = new Uint32Array(this.m_buffer, 0, this.m_dataSymbols);
                this.m_symbolCount = new Uint32Array(this.m_buffer, 4 * this.m_dataSymbols, this.m_dataSymbols);
                this.m_decoderTable = new Uint32Array(this.m_buffer, 8 * this.m_dataSymbols, this.m_tableSize + 2);
            } else {// small alphabet: no table needed
                this.m_tableSize = this.m_tableShift = 0;
                this.m_buffer = new ArrayBuffer(4 * 2 * this.m_dataSymbols);
                this.m_distribution = new Uint32Array(this.m_buffer, 0, this.m_dataSymbols);
                this.m_symbolCount = new Uint32Array(this.m_buffer, 4 * this.m_dataSymbols, this.m_dataSymbols);
                this.m_decoderTable = {};
            }
        }
        this.Reset(); // initialize model
        return module.O3DGC_OK;
    };
    // ArithmeticDecoder class
    module.ArithmeticDecoder = function () {
        this.m_codeBuffer = {};
        this.m_acShift = 0;
        this.m_base = 0;
        this.m_value = 0;
        this.m_length = 0; // arithmetic coding state
        this.m_bufferSize = 0;
        this.m_mode = 0; // mode: 0 = undef, 1 = encoder, 2 = decoder
    };
    module.ArithmeticDecoder.prototype.SetBuffer = function (max_code_bytes, user_buffer) {
        if (max_code_bytes === 0) {
            Console.log("invalid codec buffer size");
            return module.O3DGC_ERROR_AC;
        }
        if (this.m_mode !== 0) {
            Console.log("cannot set buffer while encoding or decoding");
            return module.O3DGC_ERROR_AC;
        }
        this.m_bufferSize = max_code_bytes;
        this.m_codeBuffer = user_buffer;
    };
    module.ArithmeticDecoder.prototype.StartDecoder = function () {
        if (this.m_mode !== 0) {
            Console.log("cannot start decoder");
            return module.O3DGC_ERROR_AC;
        }
        if (this.m_bufferSize === 0) {
            Console.log("no code buffer set");
            return module.O3DGC_ERROR_AC;
        }
        // initialize decoder: interval, pointer, initial code value
        this.m_mode = 2;
        this.m_length = local.O3DGC_AC_MAX_LENGTH;
        this.m_acShift = 3;
        this.m_value = ((this.m_codeBuffer[0] << 24) | (this.m_codeBuffer[1] << 16) | (this.m_codeBuffer[2] << 8) | (this.m_codeBuffer[3])) >>> 0;
    };
    module.ArithmeticDecoder.prototype.StopDecoder = function () {
        if (this.m_mode !== 2) {
            Console.log("invalid to stop decoder");
            return module.O3DGC_ERROR_AC;
        }
        this.m_mode = 0;
    };
    module.ArithmeticDecoder.prototype.GetBit = function () {
        this.m_length >>>= 1; // halve interval
        var bit = (this.m_value >= this.m_length); // decode bit
        if (bit) {
            this.m_value -= this.m_length; // move base
        }
        if (this.m_length < local.O3DGC_AC_MIN_LENGTH) {
            this.RenormDecInterval(); // renormalization
        }
        return bit;
    };
    module.ArithmeticDecoder.prototype.GetBits = function (bits) {
        var s = Math.floor(this.m_value / (this.m_length >>>= bits)); // decode symbol, change length
        this.m_value -= this.m_length * s; // update interval
        if (this.m_length < local.O3DGC_AC_MIN_LENGTH) {
            this.RenormDecInterval(); // renormalization
        }
        return s;
    };
    module.ArithmeticDecoder.prototype.DecodeStaticBitModel = function (M) {
        var x, bit;
        x = M.m_bit0Prob * (this.m_length >>> local.O3DGC_AC_BM_LENGTH_SHIFT); // product l x p0
        bit = (this.m_value >= x); // decision
        // update & shift interval
        if (!bit) {
            this.m_length = x;
        } else {
            this.m_value -= x; // shifted interval base = 0
            this.m_length -= x;
        }
        if (this.m_length < local.O3DGC_AC_MIN_LENGTH) {
            this.RenormDecInterval(); // renormalization
        }
        return bit; // return data bit value
    };
    module.ArithmeticDecoder.prototype.DecodeAdaptiveBitModel = function (M) {
        var x, bit;
        x = M.m_bit0Prob * (this.m_length >>> local.O3DGC_AC_BM_LENGTH_SHIFT);   // product l x p0
        bit = (this.m_value >= x); // decision
        // update interval
        if (!bit) {
            this.m_length = x;
            ++M.m_bit0Count;
        } else {
            this.m_value -= x;
            this.m_length -= x;
        }
        if (this.m_length < local.O3DGC_AC_MIN_LENGTH) {
            this.RenormDecInterval(); // renormalization
        }
        if (--M.m_bitsUntilUpdate === 0) {
            M.Update(); // periodic model update
        }
        return bit; // return data bit value
    };
    module.ArithmeticDecoder.prototype.DecodeAdaptiveDataModel = function (M) {
        var n, s, x, y, t, dv, z, m;
        y = this.m_length;
        if (M.m_tableSize > 0) { // use table look-up for faster decoding
            dv = Math.floor(this.m_value / (this.m_length >>>= local.O3DGC_AC_DM_LENGTH_SHIFT));
            t = dv >>> M.m_tableShift;
            s = M.m_decoderTable[t];         // initial decision based on table look-up
            n = M.m_decoderTable[t + 1] + 1;
            while (n > s + 1) { // finish with bisection search
                m = (s + n) >>> 1;
                if (M.m_distribution[m] > dv) {
                    n = m;
                } else {
                    s = m;
                }
            }
            // compute products
            x = M.m_distribution[s] * this.m_length;
            if (s !== M.m_lastSymbol) {
                y = M.m_distribution[s + 1] * this.m_length;
            }
        } else { // decode using only multiplications
            x = s = 0;
            this.m_length >>>= local.O3DGC_AC_DM_LENGTH_SHIFT;
            m = (n = M.m_dataSymbols) >>> 1;
            // decode via bisection search
            do {
                z = this.m_length * M.m_distribution[m];
                if (z > this.m_value) {
                    n = m;
                    y = z; // value is smaller
                } else {
                    s = m;
                    x = z; // value is larger or equal
                }
            } while ((m = (s + n) >>> 1) !== s);
        }
        this.m_value -= x; // update interval
        this.m_length = y - x;
        if (this.m_length < local.O3DGC_AC_MIN_LENGTH) {
            this.RenormDecInterval(); // renormalization
        }
        ++M.m_symbolCount[s];
        if (--M.m_symbolsUntilUpdate === 0) {
            M.Update(false); // periodic model update
        }
        return s;
    };
    module.ArithmeticDecoder.prototype.ExpGolombDecode = function (k, bModel0, bModel1) {
        var symbol, binary_symbol, l;
        symbol = 0;
        binary_symbol = 0;
        do {
            l = this.DecodeAdaptiveBitModel(bModel1);
            if (l) {
                symbol += (1 << k) >>> 0;
                k++;
            }
        } while (l);
        while (k--) { //next binary part
            if (this.DecodeStaticBitModel(bModel0)) {
                binary_symbol = (binary_symbol | (1 << k)) >>> 0;
            }
        }
        return (symbol + binary_symbol);
    };
    module.ArithmeticDecoder.prototype.RenormDecInterval = function () {
        do { // read least-significant byte
            this.m_value = ((this.m_value << 8) | this.m_codeBuffer[++this.m_acShift]) >>> 0;
            this.m_length = (this.m_length << 8) >>> 0;
        } while (this.m_length < local.O3DGC_AC_MIN_LENGTH); // length multiplied by 256
    };
    module.ArithmeticDecoder.prototype.DecodeIntACEGC = function (mModelValues, bModel0, bModel1, exp_k, M) {
        var uiValue = this.DecodeAdaptiveDataModel(mModelValues);
        if (uiValue === M) {
            uiValue += this.ExpGolombDecode(exp_k, bModel0, bModel1);
        }
        return UIntToInt(uiValue);
    };
    module.ArithmeticDecoder.prototype.DecodeUIntACEGC = function (mModelValues, bModel0, bModel1, exp_k, M) {
        var uiValue = this.DecodeAdaptiveDataModel(mModelValues);
        if (uiValue === M) {
            uiValue += this.ExpGolombDecode(exp_k, bModel0, bModel1);
        }
        return uiValue;
    };

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -    
    // FIFO class
    module.FIFO = function () {
        this.m_data = {};
        this.m_allocated = 0;
        this.m_size = 0;
        this.m_start = 0;
        this.m_end = 0;
    };
    module.FIFO.prototype.Clear = function () {
        this.m_start = this.m_end = this.m_size = 0;
    };
    module.FIFO.prototype.GetAllocatedSize = function () {
        return this.m_allocated;
    };
    module.FIFO.prototype.GetSize = function () {
        return this.m_size;
    };
    module.FIFO.prototype.Allocate = function (size) {
        if (size > this.m_allocated) {
            this.m_allocated = size;
            this.m_data = new Int32Array(this.m_allocated);
        }
        this.Clear();
        return module.O3DGC_OK;
    };
    module.FIFO.prototype.PopFirst = function () {
        --this.m_size;
        var current = this.m_start++;
        if (this.m_start === this.m_allocated) {
            this.m_end = 0;
        }
        return this.m_data[current];
    };
    module.FIFO.prototype.PushBack = function (value) {
        --this.m_size;
        this.m_data[this.m_end] = value;
        ++this.m_size;
        ++this.m_end;
        if (this.m_end === this.m_allocated) {
            this.m_end = 0;
        }
    };
    // IndexedFaceSet class
    module.IndexedFaceSet = function () {
        this.m_nCoordIndex = 0;
        this.m_nCoord = 0;
        this.m_nNormal = 0;
        this.m_numFloatAttributes = 0;
        this.m_numIntAttributes = 0;
        this.m_creaseAngle = 30.0;
        this.m_ccw = true;
        this.m_solid = true;
        this.m_convex = true;
        this.m_isTriangularMesh = true;
        this.m_coordMin = new Float32Array(3);
        this.m_coordMax = new Float32Array(3);
        this.m_normalMin = new Float32Array(3);
        this.m_normalMax = new Float32Array(3);
        this.m_nFloatAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES);
        this.m_nIntAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES);
        this.m_dimFloatAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES);
        this.m_dimIntAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES);
        this.m_typeFloatAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES);
        this.m_typeIntAttribute = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES);
        this.m_minFloatAttributeBuffer = new ArrayBuffer(4 * local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES * local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES);
        this.m_minFloatAttribute = new Float32Array(this.m_minFloatAttributeBuffer);
        this.m_maxFloatAttributeBuffer = new ArrayBuffer(4 * local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES * local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES);
        this.m_maxFloatAttribute = new Float32Array(this.m_maxFloatAttributeBuffer);
        this.m_coordIndex = {};
        this.m_coord = {};
        this.m_normal = {};
        this.m_floatAttribute = [];
        this.m_intAttribute = [];
    };
    module.IndexedFaceSet.prototype.GetNCoordIndex = function () {
        return this.m_nCoordIndex;
    };
    module.IndexedFaceSet.prototype.GetNCoordIndex = function () {
        return this.m_nCoordIndex;
    };
    module.IndexedFaceSet.prototype.GetNCoord = function () {
        return this.m_nCoord;
    };
    module.IndexedFaceSet.prototype.GetNNormal = function () {
        return this.m_nNormal;
    };
    module.IndexedFaceSet.prototype.GetNFloatAttribute = function (a) {
        return this.m_nFloatAttribute[a];
    };
    module.IndexedFaceSet.prototype.GetNIntAttribute = function (a) {
        return this.m_nIntAttribute[a];
    };
    module.IndexedFaceSet.prototype.GetNumFloatAttributes = function () {
        return this.m_numFloatAttributes;
    };
    module.IndexedFaceSet.prototype.GetNumIntAttributes = function () {
        return this.m_numIntAttributes;
    };
    module.IndexedFaceSet.prototype.GetCoordMinArray = function () {
        return this.m_coordMin;
    };
    module.IndexedFaceSet.prototype.GetCoordMaxArray = function () {
        return this.m_coordMax;
    };
    module.IndexedFaceSet.prototype.GetNormalMinArray = function () {
        return this.m_normalMin;
    };
    module.IndexedFaceSet.prototype.GetNormalMaxArray = function () {
        return this.m_normalMax;
    };
    module.IndexedFaceSet.prototype.GetFloatAttributeMinArray = function (a) {
        return (new Float32Array(this.m_minFloatAttributeBuffer, a * local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES * 4, this.GetFloatAttributeDim(a)));
    };
    module.IndexedFaceSet.prototype.GetFloatAttributeMaxArray = function (a) {
        return (new Float32Array(this.m_maxFloatAttributeBuffer, a * local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES * 4, this.GetFloatAttributeDim(a)));
    };
    module.IndexedFaceSet.prototype.GetFloatAttributeDim = function (a) {
        return this.m_dimFloatAttribute[a];
    };
    module.IndexedFaceSet.prototype.GetIntAttributeDim = function (a) {
        return this.m_dimIntAttribute[a];
    };
    module.IndexedFaceSet.prototype.GetFloatAttributeType = function (a) {
        return this.m_typeFloatAttribute[a];
    };
    module.IndexedFaceSet.prototype.GetIntAttributeType = function (a) {
        return this.m_typeIntAttribute[a];
    };
    module.IndexedFaceSet.prototype.GetFloatAttributeMax = function (a, dim) {
        return this.m_maxFloatAttribute[a * local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES + dim];
    };
    module.IndexedFaceSet.prototype.GetCreaseAngle = function () {
        return this.m_creaseAngle;
    };
    module.IndexedFaceSet.prototype.GetCreaseAngle = function () {
        return this.m_creaseAngle;
    };
    module.IndexedFaceSet.prototype.GetCCW = function () {
        return this.m_ccw;
    };
    module.IndexedFaceSet.prototype.GetSolid = function () {
        return this.m_solid;
    };
    module.IndexedFaceSet.prototype.GetConvex = function () {
        return this.m_convex;
    };
    module.IndexedFaceSet.prototype.GetIsTriangularMesh = function () {
        return this.m_isTriangularMesh;
    };
    module.IndexedFaceSet.prototype.GetCoordIndex = function () {
        return this.m_coordIndex;
    };
    module.IndexedFaceSet.prototype.GetCoordIndex = function () {
        return this.m_coordIndex;
    };
    module.IndexedFaceSet.prototype.GetCoord = function () {
        return this.m_coord;
    };
    module.IndexedFaceSet.prototype.GetNormal = function () {
        return this.m_normal;
    };
    module.IndexedFaceSet.prototype.GetFloatAttribute = function (a) {
        return this.m_floatAttribute[a];
    };
    module.IndexedFaceSet.prototype.GetIntAttribute = function (a) {
        return this.m_intAttribute[a];
    };
    module.IndexedFaceSet.prototype.SetNCoordIndex = function (nCoordIndex) {
        this.m_nCoordIndex = nCoordIndex;
    };
    module.IndexedFaceSet.prototype.SetNNormalIndex = function (nNormalIndex) {
    };
    module.IndexedFaceSet.prototype.SetNormalPerVertex = function (perVertex) {
    };
    module.IndexedFaceSet.prototype.SetNFloatAttributeIndex = function (nFloatAttributeIndex) {
    };
    module.IndexedFaceSet.prototype.SetNIntAttributeIndex = function (nIntAttributeIndex) {
    };
    module.IndexedFaceSet.prototype.SetFloatAttributePerVertex = function (perVertex) {
    };
    module.IndexedFaceSet.prototype.SetIntAttributePerVertex = function (perVertex) {
    };
    module.IndexedFaceSet.prototype.SetNCoord = function (nCoord) {
        this.m_nCoord = nCoord;
    };
    module.IndexedFaceSet.prototype.SetNNormal = function (nNormal) {
        this.m_nNormal = nNormal;
    };
    module.IndexedFaceSet.prototype.SetNumFloatAttributes = function (numFloatAttributes) {
        this.m_numFloatAttributes = numFloatAttributes;
    };
    module.IndexedFaceSet.prototype.SetNumIntAttributes = function (numIntAttributes) {
        this.m_numIntAttributes = numIntAttributes;
    };
    module.IndexedFaceSet.prototype.SetCreaseAngle = function (creaseAngle) {
        this.m_creaseAngle = creaseAngle;
    };
    module.IndexedFaceSet.prototype.SetCCW = function (ccw) {
        this.m_ccw = ccw;
    };
    module.IndexedFaceSet.prototype.SetSolid = function (solid) {
        this.m_solid = solid;
    };
    module.IndexedFaceSet.prototype.SetConvex = function (convex) {
        this.m_convex = convex;
    };
    module.IndexedFaceSet.prototype.SetIsTriangularMesh = function (isTriangularMesh) {
        this.m_isTriangularMesh = isTriangularMesh;
    };
    module.IndexedFaceSet.prototype.SetCoordMin = function (j, min) {
        this.m_coordMin[j] = min;
    };
    module.IndexedFaceSet.prototype.SetCoordMax = function (j, max) {
        this.m_coordMax[j] = max;
    };
    module.IndexedFaceSet.prototype.SetNormalMin = function (j, min) {
        this.m_normalMin[j] = min;
    };
    module.IndexedFaceSet.prototype.SetNormalMax = function (j, max) {
        this.m_normalMax[j] = max;
    };
    module.IndexedFaceSet.prototype.SetNFloatAttribute = function (a, nFloatAttribute) {
        this.m_nFloatAttribute[a] = nFloatAttribute;
    };
    module.IndexedFaceSet.prototype.SetNIntAttribute = function (a, nIntAttribute) {
        this.m_nIntAttribute[a] = nIntAttribute;
    };
    module.IndexedFaceSet.prototype.SetFloatAttributeDim = function (a, d) {
        this.m_dimFloatAttribute[a] = d;
    };
    module.IndexedFaceSet.prototype.SetIntAttributeDim = function (a, d) {
        this.m_dimIntAttribute[a] = d;
    };
    module.IndexedFaceSet.prototype.SetFloatAttributeType = function (a, d) {
        this.m_typeFloatAttribute[a] = d;
    };
    module.IndexedFaceSet.prototype.SetIntAttributeType = function (a, d) {
        this.m_typeIntAttribute[a] = d;
    };
    module.IndexedFaceSet.prototype.SetFloatAttributeMin = function (a, dim, min) {
        this.m_minFloatAttribute[a * local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES + dim] = min;
    };
    module.IndexedFaceSet.prototype.SetFloatAttributeMax = function (a, dim, max) {
        this.m_maxFloatAttribute[a * local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES + dim] = max;
    };
    module.IndexedFaceSet.prototype.SetCoordIndex = function (coordIndex) {
        this.m_coordIndex = coordIndex;
    };
    module.IndexedFaceSet.prototype.SetCoord = function (coord) {
        this.m_coord = coord;
    };
    module.IndexedFaceSet.prototype.SetNormal = function (normal) {
        this.m_normal = normal;
    };
    module.IndexedFaceSet.prototype.SetFloatAttribute = function (a, floatAttribute) {
        this.m_floatAttribute[a] = floatAttribute;
    };
    module.IndexedFaceSet.prototype.SetIntAttribute = function (a, intAttribute) {
        this.m_intAttribute[a] = intAttribute;
    };

    // SC3DMCEncodeParams class
    module.SC3DMCEncodeParams = function () {
        var a;
        this.m_numFloatAttributes = 0;
        this.m_numIntAttributes = 0;
        this.m_floatAttributeQuantBits = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES);
        this.m_floatAttributePredMode = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES);
        this.m_intAttributePredMode = new Uint32Array(local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES);
        this.m_encodeMode = local.O3DGC_SC3DMC_ENCODE_MODE_TFAN;
        this.m_streamTypeMode = local.O3DGC_STREAM_TYPE_ASCII;
        this.m_coordQuantBits = 14;
        this.m_normalQuantBits = 8;
        this.m_coordPredMode = local.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION;
        this.m_normalPredMode = local.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION;
        for (a = 0; a < local.O3DGC_SC3DMC_MAX_NUM_FLOAT_ATTRIBUTES; ++a) {
            this.m_floatAttributePredMode[a] = local.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION;
        }
        for (a = 0; a < local.O3DGC_SC3DMC_MAX_NUM_INT_ATTRIBUTES; ++a) {
            this.m_intAttributePredMode[a] = local.O3DGC_SC3DMC_DIFFERENTIAL_PREDICTION;
        }
    };
    module.SC3DMCEncodeParams.prototype.GetStreamType = function () {
        return this.m_streamTypeMode;
    };
    module.SC3DMCEncodeParams.prototype.GetEncodeMode = function () {
        return this.m_encodeMode;
    };
    module.SC3DMCEncodeParams.prototype.GetNumFloatAttributes = function () {
        return this.m_numFloatAttributes;
    };
    module.SC3DMCEncodeParams.prototype.GetNumIntAttributes = function () {
        return this.m_numIntAttributes;
    };
    module.SC3DMCEncodeParams.prototype.GetCoordQuantBits = function () {
        return this.m_coordQuantBits;
    };
    module.SC3DMCEncodeParams.prototype.GetNormalQuantBits = function () {
        return this.m_normalQuantBits;
    };
    module.SC3DMCEncodeParams.prototype.GetFloatAttributeQuantBits = function (a) {
        return this.m_floatAttributeQuantBits[a];
    };
    module.SC3DMCEncodeParams.prototype.GetCoordPredMode = function () {
        return this.m_coordPredMode;
    };
    module.SC3DMCEncodeParams.prototype.GetNormalPredMode = function () {
        return this.m_normalPredMode;
    };
    module.SC3DMCEncodeParams.prototype.GetFloatAttributePredMode = function (a) {
        return this.m_floatAttributePredMode[a];
    };
    module.SC3DMCEncodeParams.prototype.GetIntAttributePredMode = function (a) {
        return this.m_intAttributePredMode[a];
    };
    module.SC3DMCEncodeParams.prototype.GetCoordPredMode = function () {
        return this.m_coordPredMode;
    };
    module.SC3DMCEncodeParams.prototype.GetNormalPredMode = function () {
        return this.m_normalPredMode;
    };
    module.SC3DMCEncodeParams.prototype.GetFloatAttributePredMode = function (a) {
        return this.m_floatAttributePredMode[a];
    };
    module.SC3DMCEncodeParams.prototype.GetIntAttributePredMode = function (a) {
        return this.m_intAttributePredMode[a];
    };
    module.SC3DMCEncodeParams.prototype.SetStreamType = function (streamTypeMode) {
        this.m_streamTypeMode = streamTypeMode;
    };
    module.SC3DMCEncodeParams.prototype.SetEncodeMode = function (encodeMode) {
        this.m_encodeMode = encodeMode;
    };
    module.SC3DMCEncodeParams.prototype.SetNumFloatAttributes = function (numFloatAttributes) {
        this.m_numFloatAttributes = numFloatAttributes;
    };
    module.SC3DMCEncodeParams.prototype.SetNumIntAttributes = function (numIntAttributes) {
        this.m_numIntAttributes = numIntAttributes;
    };
    module.SC3DMCEncodeParams.prototype.SetCoordQuantBits = function (coordQuantBits) {
        this.m_coordQuantBits = coordQuantBits;
    };
    module.SC3DMCEncodeParams.prototype.SetNormalQuantBits = function (normalQuantBits) {
        this.m_normalQuantBits = normalQuantBits;
    };
    module.SC3DMCEncodeParams.prototype.SetFloatAttributeQuantBits = function (a, q) {
        this.m_floatAttributeQuantBits[a] = q;
    };
    module.SC3DMCEncodeParams.prototype.SetCoordPredMode = function (coordPredMode) {
        this.m_coordPredMode = coordPredMode;
    };
    module.SC3DMCEncodeParams.prototype.SetNormalPredMode = function (normalPredMode) {
        this.m_normalPredMode = normalPredMode;
    };
    module.SC3DMCEncodeParams.prototype.SetFloatAttributePredMode = function (a, p) {
        this.m_floatAttributePredMode[a] = p;
    };
    module.SC3DMCEncodeParams.prototype.SetIntAttributePredMode = function (a, p) {
        this.m_intAttributePredMode[a] = p;
    };
    // AdjacencyInfo class
    module.AdjacencyInfo = function () {
        this.m_neighborsSize = 0;    // actual allocated size for m_neighbors
        this.m_numNeighborsSize = 0; // actual allocated size for m_numNeighbors
        this.m_numElements = 0;      // number of elements 
        this.m_neighbors = {};
        this.m_numNeighbors = {};
    };
    module.AdjacencyInfo.prototype.Allocate = function (numNeighborsSize, neighborsSize) {
        this.m_numElements = numNeighborsSize;
        if (neighborsSize > this.m_neighborsSize) {
            this.m_neighborsSize = neighborsSize;
            this.m_neighbors = new Int32Array(this.m_neighborsSize);
        }
        if (numNeighborsSize > this.m_numNeighborsSize) {
            this.m_numNeighborsSize = numNeighborsSize;
            this.m_numNeighbors = new Int32Array(this.m_numNeighborsSize);
        }
        return module.O3DGC_OK;
    };
    module.AdjacencyInfo.prototype.AllocateNumNeighborsArray = function (numElements) {
        if (numElements > this.m_numNeighborsSize) {
            this.m_numNeighborsSize = numElements;
            this.m_numNeighbors = new Int32Array(this.m_numNeighborsSize);
        }
        this.m_numElements = numElements;
        return module.O3DGC_OK;
    };
    module.AdjacencyInfo.prototype.AllocateNeighborsArray = function () {
        var i;
        for (i = 1; i < this.m_numElements; ++i) {
            this.m_numNeighbors[i] += this.m_numNeighbors[i - 1];
        }
        if (this.m_numNeighbors[this.m_numElements - 1] > this.m_neighborsSize) {
            this.m_neighborsSize = this.m_numNeighbors[this.m_numElements - 1];
            this.m_neighbors = new Int32Array(this.m_neighborsSize);
        }
        return module.O3DGC_OK;
    };
    module.AdjacencyInfo.prototype.ClearNumNeighborsArray = function () {
        var i;
        for (i = 0; i < this.m_numElements; ++i) {
            this.m_numNeighbors[i] = 0;
        }
        return module.O3DGC_OK;
    };
    module.AdjacencyInfo.prototype.ClearNeighborsArray = function () {
        var i;
        for (i = 0; i < this.m_neighborsSize; ++i) {
            this.m_neighbors[i] = -1;
        }
        return module.O3DGC_OK;
    };
    module.AdjacencyInfo.prototype.Begin = function (element) {
        return (element > 0) ? this.m_numNeighbors[element - 1] : 0;
    };
    module.AdjacencyInfo.prototype.End = function (element) {
        return this.m_numNeighbors[element];
    };
    module.AdjacencyInfo.prototype.AddNeighbor = function (element, neighbor) {
        var p, p0, p1;
        p0 = this.Begin(element);
        p1 = this.End(element);
        for (p = p0; p < p1; ++p) {
            if (this.m_neighbors[p] === -1) {
                this.m_neighbors[p] = neighbor;
                return module.O3DGC_OK;
            }
        }
        return module.O3DGC_ERROR_BUFFER_FULL;
    };
    module.AdjacencyInfo.prototype.GetNeighbor = function (element) {
        return this.m_neighbors[element];
    };
    module.AdjacencyInfo.prototype.GetNumNeighbors = function (element) {
        return this.End(element) - this.Begin(element);
    };
    module.AdjacencyInfo.prototype.GetNumNeighborsBuffer = function () {
        return this.m_numNeighbors;
    };
    module.AdjacencyInfo.prototype.GetNeighborsBuffer = function () {
        return this.m_neighbors;
    };
    // Vector class
    module.Vector = function () {
        this.m_data = {};
        this.m_allocated = 0;
        this.m_size = 0;
    };
    module.Vector.prototype.Clear = function () {
        this.m_size = 0;
    };
    module.Vector.prototype.Get = function (i) {
        return this.m_data[i];
    };
    module.Vector.prototype.GetAllocatedSize = function () {
        return this.m_allocated;
    };
    module.Vector.prototype.GetSize = function () {
        return this.m_size;
    };
    module.Vector.prototype.GetBuffer = function () {
        return this.m_data;
    };
    module.Vector.prototype.SetSize = function (size) {
        this.m_size = size;
    };
    module.Vector.prototype.Allocate = function (size) {
        var i, tmp_data;
        if (size > this.m_allocated) {
            this.m_allocated = size;
            tmp_data = new Int32Array(this.m_allocated);
            if (this.m_size > 0) {
                for (i = 0; i < this.m_size; ++i) {
                    tmp_data[i] = this.m_data[i];
                }
            }
            this.m_data = tmp_data;
        }
    };
    module.Vector.prototype.PushBack = function (value) {
        var i, tmp_data;
        if (this.m_size === this.m_allocated) {
            this.m_allocated *= 2;
            if (this.m_allocated < local.O3DGC_DEFAULT_VECTOR_SIZE) {
                this.m_allocated = local.O3DGC_DEFAULT_VECTOR_SIZE;
            }
            tmp_data = new Int32Array(this.m_allocated);
            if (this.m_size > 0) {
                for (i = 0; i < this.m_size; ++i) {
                    tmp_data[i] = this.m_data[i];
                }
            }
            this.m_data = tmp_data;
        }
        this.m_data[this.m_size++] = value;
    };
    // CompressedTriangleFans class
    module.CompressedTriangleFans = function () {
        this.m_numTFANs = new module.Vector();
        this.m_degrees = new module.Vector();
        this.m_configs = new module.Vector();
        this.m_operations = new module.Vector();
        this.m_indices = new module.Vector();
        this.m_trianglesOrder = new module.Vector();
        this.m_streamType = local.O3DGC_STREAM_TYPE_UNKOWN;
    };
    module.CompressedTriangleFans.prototype.GetStreamType = function () {
        return this.m_streamType;
    };
    module.CompressedTriangleFans.prototype.SetStreamType = function (streamType) {
        this.m_streamType = streamType;
    };
    module.CompressedTriangleFans.prototype.Clear = function () {
        this.m_numTFANs.Clear();
        this.m_degrees.Clear();
        this.m_configs.Clear();
        this.m_operations.Clear();
        this.m_indices.Clear();
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.Allocate = function (numVertices, numTriangles) {
        this.m_numTFANs.Allocate(numVertices);
        this.m_degrees.Allocate(2 * numVertices);
        this.m_configs.Allocate(2 * numVertices);
        this.m_operations.Allocate(2 * numVertices);
        this.m_indices.Allocate(2 * numVertices);
        this.m_trianglesOrder.Allocate(numTriangles);
        this.Clear();
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.PushNumTFans = function (numTFans) {
        this.m_numTFANs.PushBack(numTFans);
    };
    module.CompressedTriangleFans.prototype.ReadNumTFans = function (it) {
        return this.m_numTFANs.Get(it.m_count++);
    };
    module.CompressedTriangleFans.prototype.PushDegree = function (degree) {
        this.m_degrees.PushBack(degree);
    };
    module.CompressedTriangleFans.prototype.ReadDegree = function (it) {
        return this.m_degrees.Get(it.m_count++);
    };
    module.CompressedTriangleFans.prototype.PushConfig = function (config) {
        this.m_configs.PushBack(config);
    };
    module.CompressedTriangleFans.prototype.ReadConfig = function (it) {
        return this.m_configs.Get(it.m_count++);
    };
    module.CompressedTriangleFans.prototype.PushOperation = function (op) {
        this.m_operations.PushBack(op);
    };
    module.CompressedTriangleFans.prototype.ReadOperation = function (it) {
        return this.m_operations.Get(it.m_count++);
    };
    module.CompressedTriangleFans.prototype.PushIndex = function (index) {
        this.m_indices.PushBack(index);
    };
    module.CompressedTriangleFans.prototype.ReadIndex = function (it) {
        return this.m_indices.Get(it.m_count++);
    };
    module.CompressedTriangleFans.prototype.PushTriangleIndex = function (index) {
        this.m_trianglesOrder.PushBack(IntToUInt(index));
    };
    module.CompressedTriangleFans.prototype.ReadTriangleIndex = function (it) {
        return UIntToInt(this.m_trianglesOrder.Get(it.m_count++));
    };
    module.CompressedTriangleFans.prototype.LoadUIntData = function (data, bstream, it) {
        var size, i;
        bstream.ReadUInt32ASCII(it);
        size = bstream.ReadUInt32ASCII(it);
        data.Allocate(size);
        data.Clear();
        for (i = 0; i < size; ++i) {
            data.PushBack(bstream.ReadUIntASCII(it));
        }
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.LoadIntData = function (data, bstream, it) {
        var size, i;
        bstream.ReadUInt32ASCII(it);
        size = bstream.ReadUInt32ASCII(it);
        data.Allocate(size);
        data.Clear();
        for (i = 0; i < size; ++i) {
            data.PushBack(bstream.ReadIntASCII(it));
        }
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.LoadBinData = function (data, bstream, it) {
        var size, symbol, i, h;
        bstream.ReadUInt32ASCII(it);
        size = bstream.ReadUInt32ASCII(it);
        data.Allocate(size * local.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0);
        data.Clear();
        i = 0;
        while (i < size) {
            symbol = bstream.ReadUCharASCII(it);
            for (h = 0; h < local.O3DGC_BINARY_STREAM_BITS_PER_SYMBOL0; ++h) {
                data.PushBack(symbol & 1);
                symbol >>>= 1;
                ++i;
            }
        }
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.LoadUIntAC = function (data, M, bstream, it) {

        var sizeSize, size, minValue, buffer, acd, mModelValues, i;
        sizeSize = bstream.ReadUInt32Bin(it) - 12;
        size = bstream.ReadUInt32Bin(it);
        if (size === 0) {
            return module.O3DGC_OK;
        }
        minValue = bstream.ReadUInt32Bin(it);
        buffer = bstream.GetBuffer(it, sizeSize);
        it.m_count += sizeSize;
        data.Allocate(size);
        acd = new module.ArithmeticDecoder();
        acd.SetBuffer(sizeSize, buffer);
        acd.StartDecoder();
        mModelValues = new module.AdaptiveDataModel();
        mModelValues.SetAlphabet(M + 1);
        for (i = 0; i < size; ++i) {
            data.PushBack(acd.DecodeAdaptiveDataModel(mModelValues) + minValue);
        }
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.LoadIntACEGC = function (data, M, bstream, it) {
        var sizeSize, size, minValue, buffer, acd, mModelValues, bModel0, bModel1, value, i;
        sizeSize = bstream.ReadUInt32Bin(it) - 12;
        size = bstream.ReadUInt32Bin(it);
        if (size === 0) {
            return module.O3DGC_OK;
        }
        minValue = bstream.ReadUInt32Bin(it) - local.O3DGC_MAX_LONG;
        buffer = bstream.GetBuffer(it, sizeSize);
        it.m_count += sizeSize;
        data.Allocate(size);
        acd = new module.ArithmeticDecoder();
        acd.SetBuffer(sizeSize, buffer);
        acd.StartDecoder();
        mModelValues = new module.AdaptiveDataModel();
        mModelValues.SetAlphabet(M + 2);
        bModel0 = new module.StaticBitModel();
        bModel1 = new module.AdaptiveBitModel();
        for (i = 0; i < size; ++i) {
            value = acd.DecodeAdaptiveDataModel(mModelValues);
            if (value === M) {
                value += acd.ExpGolombDecode(0, bModel0, bModel1);
            }
            data.PushBack(value + minValue);
        }
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.LoadBinAC = function (data, bstream, it) {
        var sizeSize, size, buffer, acd, bModel, i;
        sizeSize = bstream.ReadUInt32Bin(it) - 8;
        size = bstream.ReadUInt32Bin(it);
        if (size === 0) {
            return module.O3DGC_OK;
        }
        buffer = bstream.GetBuffer(it, sizeSize);
        it.m_count += sizeSize;
        data.Allocate(size);
        acd = new module.ArithmeticDecoder();
        acd.SetBuffer(sizeSize, buffer);
        acd.StartDecoder();
        bModel = new module.AdaptiveBitModel();
        for (i = 0; i < size; ++i) {
            data.PushBack(acd.DecodeAdaptiveBitModel(bModel));
        }
        return module.O3DGC_OK;
    };
    module.CompressedTriangleFans.prototype.Load = function (bstream, iterator, decodeTrianglesOrder, streamType) {
        if (streamType === local.O3DGC_STREAM_TYPE_ASCII) {
            this.LoadUIntData(this.m_numTFANs, bstream, iterator);
            this.LoadUIntData(this.m_degrees, bstream, iterator);
            this.LoadUIntData(this.m_configs, bstream, iterator);
            this.LoadBinData(this.m_operations, bstream, iterator);
            this.LoadIntData(this.m_indices, bstream, iterator);
            if (decodeTrianglesOrder) {
                this.LoadUIntData(this.m_trianglesOrder, bstream, iterator);
            }
        } else {
            this.LoadIntACEGC(this.m_numTFANs, 4, bstream, iterator);
            this.LoadIntACEGC(this.m_degrees, 16, bstream, iterator);
            this.LoadUIntAC(this.m_configs, 10, bstream, iterator);
            this.LoadBinAC(this.m_operations, bstream, iterator);
            this.LoadIntACEGC(this.m_indices, 8, bstream, iterator);
            if (decodeTrianglesOrder) {
                this.LoadIntACEGC(this.m_trianglesOrder, 16, bstream, iterator);
            }
        }
        return module.O3DGC_OK;
    };
    // TriangleFans class
    module.TriangleFans = function () {
        this.m_verticesAllocatedSize = 0;
        this.m_sizeTFANAllocatedSize = 0;
        this.m_numTFANs = 0;
        this.m_numVertices = 0;
        this.m_sizeTFAN = {};
        this.m_vertices = {};
    };
    module.TriangleFans.prototype.Allocate = function (sizeTFAN, verticesSize) {
        this.m_numTFANs = 0;
        this.m_numVertices = 0;
        if (this.m_verticesAllocatedSize < verticesSize) {
            this.m_verticesAllocatedSize = verticesSize;
            this.m_vertices = new Int32Array(this.m_verticesAllocatedSize);
        }
        if (this.m_sizeTFANAllocatedSize < sizeTFAN) {
            this.m_sizeTFANAllocatedSize = sizeTFAN;
            this.m_sizeTFAN = new Int32Array(this.m_sizeTFANAllocatedSize);
        }
        return module.O3DGC_OK;
    };
    module.TriangleFans.prototype.Clear = function () {
        this.m_numTFANs = 0;
        this.m_numVertices = 0;
        return module.O3DGC_OK;
    };
    module.TriangleFans.prototype.AddVertex = function (vertex) {
        var i, tmp_vertices;
        ++this.m_numVertices;
        if (this.m_numVertices > this.m_verticesAllocatedSize) {
            this.m_verticesAllocatedSize *= 2;
            tmp_vertices = new Int32Array(this.m_verticesAllocatedSize);
            for (i = 0; i < this.m_numVertices; ++i) {
                tmp_vertices[i] = this.m_vertices[i];
            }
            this.m_vertices = tmp_vertices;
        }
        this.m_vertices[this.m_numVertices - 1] = vertex;
        ++this.m_sizeTFAN[this.m_numTFANs - 1];
        return module.O3DGC_OK;
    };
    module.TriangleFans.prototype.AddTFAN = function () {
        var i, tmp_sizeTFAN;
        ++this.m_numTFANs;
        if (this.m_numTFANs > this.m_sizeTFANAllocatedSize) {
            this.m_sizeTFANAllocatedSize *= 2;
            tmp_sizeTFAN = new Int32Array(this.m_sizeTFANAllocatedSize);
            for (i = 0; i < this.m_numTFANs; ++i) {
                tmp_sizeTFAN[i] = this.m_sizeTFAN[i];
            }
            this.m_sizeTFAN = tmp_sizeTFAN;
        }
        this.m_sizeTFAN[this.m_numTFANs - 1] = (this.m_numTFANs > 1) ? this.m_sizeTFAN[this.m_numTFANs - 2] : 0;
        return module.O3DGC_OK;
    };
    module.TriangleFans.prototype.Begin = function (tfan) {
        return (tfan > 0) ? this.m_sizeTFAN[tfan - 1] : 0;
    };
    module.TriangleFans.prototype.End = function (tfan) {
        return this.m_sizeTFAN[tfan];
    };
    module.TriangleFans.prototype.GetVertex = function (vertex) {
        return this.m_vertices[vertex];
    };
    module.TriangleFans.prototype.GetTFANSize = function (tfan) {
        return this.End(tfan) - this.Begin(tfan);
    };
    module.TriangleFans.prototype.GetNumTFANs = function () {
        return this.m_numTFANs;
    };
    module.TriangleFans.prototype.GetNumVertices = function () {
        return this.m_numVertices;
    };
    // TriangleListDecoder class
    module.TriangleListDecoder = function () {
        this.m_itNumTFans = new module.Iterator();
        this.m_itDegree = new module.Iterator();
        this.m_itConfig = new module.Iterator();
        this.m_itOperation = new module.Iterator();
        this.m_itIndex = new module.Iterator();
        this.m_maxNumVertices = 0;
        this.m_maxNumTriangles = 0;
        this.m_numTriangles = 0;
        this.m_numVertices = 0;
        this.m_tempTrianglesSize = 0;
        this.m_vertexCount = 0;
        this.m_triangleCount = 0;
        this.m_numConqueredTriangles = 0;
        this.m_numVisitedVertices = 0;
        this.m_triangles = {};
        this.m_tempTriangles = {};
        this.m_visitedVertices = {};
        this.m_visitedVerticesValence = {};
        this.m_vertexToTriangle = new module.AdjacencyInfo();
        this.m_ctfans = new module.CompressedTriangleFans();
        this.m_tfans = new module.TriangleFans();
        this.m_streamType = local.O3DGC_STREAM_TYPE_ASCII;
        this.m_decodeTrianglesOrder = false;
        this.m_decodeVerticesOrder = false;
        this.m_processConfig = {
            0: function (decoder, degree) { // ops: 1000001 vertices: -1 -2
                var u;
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[0]);
                for (u = 1; u < degree - 1; ++u) {
                    decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                    decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                }
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[1]);
            },
            1: function (decoder, degree, focusVertex) { // ops: 1xxxxxx1 vertices: -1 x x x x x -2
                var u, op, index;
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[0]);
                for (u = 1; u < degree - 1; ++u) {
                    op = decoder.m_ctfans.ReadOperation(decoder.m_itOperation);
                    if (op === 1) {
                        index = decoder.m_ctfans.ReadIndex(decoder.m_itIndex);
                        if (index < 0) {
                            decoder.m_tfans.AddVertex(decoder.m_visitedVertices[-index - 1]);
                        } else {
                            decoder.m_tfans.AddVertex(index + focusVertex);
                        }
                    } else {
                        decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                        decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                    }
                }
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[1]);
            },
            2: function (decoder, degree) { // ops: 00000001 vertices: -1
                var u;
                for (u = 0; u < degree - 1; ++u) {
                    decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                    decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                }
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[0]);
            },
            3: function (decoder, degree) { // ops: 00000001 vertices: -2
                var u;
                for (u = 0; u < degree - 1; ++u) {
                    decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                    decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                }
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[1]);
            },
            4: function (decoder, degree) {// ops: 10000000 vertices: -1
                var u;
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[0]);
                for (u = 1; u < degree; ++u) {
                    decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                    decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                }
            },
            5: function (decoder, degree) { // ops: 10000000 vertices: -2
                var u;
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[1]);
                for (u = 1; u < degree; ++u) {
                    decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                    decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                }
            },
            6: function (decoder, degree) { // ops: 00000000 vertices:
                var u;
                for (u = 0; u < degree; ++u) {
                    decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                    decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                }
            },
            7: function (decoder, degree) { // ops: 1000001 vertices: -2 -1
                var u;
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[1]);
                for (u = 1; u < degree - 1; ++u) {
                    decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                    decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                }
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[0]);
            },
            8: function (decoder, degree, focusVertex) { // ops: 1xxxxxx1 vertices: -2 x x x x x -1
                var u, op, index;
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[1]);
                for (u = 1; u < degree - 1; ++u) {
                    op = decoder.m_ctfans.ReadOperation(decoder.m_itOperation);
                    if (op === 1) {
                        index = decoder.m_ctfans.ReadIndex(decoder.m_itIndex);
                        if (index < 0) {
                            decoder.m_tfans.AddVertex(decoder.m_visitedVertices[-index - 1]);
                        } else {
                            decoder.m_tfans.AddVertex(index + focusVertex);
                        }
                    } else {
                        decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                        decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                    }
                }
                decoder.m_tfans.AddVertex(decoder.m_visitedVertices[0]);
            },
            9: function (decoder, degree, focusVertex) { // general case
                var u, op, index;
                for (u = 0; u < degree; ++u) {
                    op = decoder.m_ctfans.ReadOperation(decoder.m_itOperation);
                    if (op === 1) {
                        index = decoder.m_ctfans.ReadIndex(decoder.m_itIndex);
                        if (index < 0) {
                            decoder.m_tfans.AddVertex(decoder.m_visitedVertices[-index - 1]);
                        } else {
                            decoder.m_tfans.AddVertex(index + focusVertex);
                        }
                    } else {
                        decoder.m_visitedVertices[decoder.m_numVisitedVertices++] = decoder.m_vertexCount;
                        decoder.m_tfans.AddVertex(decoder.m_vertexCount++);
                    }
                }
            }
        };
    };
    module.TriangleListDecoder.prototype.GetStreamType = function () {
        return this.m_streamType;
    };
    module.TriangleListDecoder.prototype.GetReorderTriangles = function () {
        return this.m_decodeTrianglesOrder;
    };
    module.TriangleListDecoder.prototype.GetReorderVertices = function () {
        return this.m_decodeVerticesOrder;
    };
    module.TriangleListDecoder.prototype.SetStreamType = function (streamType) {
        this.m_streamType = streamType;
    };
    module.TriangleListDecoder.prototype.GetVertexToTriangle = function () {
        return this.m_vertexToTriangle;
    };
    module.TriangleListDecoder.prototype.Reorder = function () {
        var triangles, numTriangles, order, it, prevTriangleIndex, tempTriangles, t, i;
        if (this.m_decodeTrianglesOrder) {
            triangles = this.m_triangles;
            numTriangles = this.m_numTriangles;
            order = this.m_ctfans.m_trianglesOrder.m_data;
            tempTriangles = this.m_tempTriangles;
            tempTriangles.set(triangles);
            it = 0;
            prevTriangleIndex = 0;
            for (i = 0; i < numTriangles; ++i) {
                t = UIntToInt(order[it++]) + prevTriangleIndex;
                triangles[3 * t] = tempTriangles[3 * i];
                triangles[3 * t + 1] = tempTriangles[3 * i + 1];
                triangles[3 * t + 2] = tempTriangles[3 * i + 2];
                prevTriangleIndex = t + 1;
            }
        }
        return module.O3DGC_OK;
    };
    module.TriangleListDecoder.prototype.CompueLocalConnectivityInfo = function (focusVertex) {
        var visitedVertices, visitedVerticesValence, triangles, vertexToTriangle, beginV2T, endV2T, numConqueredTriangles, foundOrInserted, numVisitedVertices, tmp, i, j, k, h, x, y, t, p, v;
        visitedVertices = this.m_visitedVertices;
        visitedVerticesValence = this.m_visitedVerticesValence;
        triangles = this.m_triangles;
        vertexToTriangle = this.m_vertexToTriangle;
        beginV2T = vertexToTriangle.Begin(focusVertex);
        endV2T = vertexToTriangle.End(focusVertex);
        numConqueredTriangles = 0;
        numVisitedVertices = 0;
        t = 0;
        for (i = beginV2T; (t >= 0) && (i < endV2T); ++i) {
            t = vertexToTriangle.GetNeighbor(i);
            if (t >= 0) {
                ++numConqueredTriangles;
                p = 3 * t;
                // extract visited vertices
                for (k = 0; k < 3; ++k) {
                    v = triangles[p + k];
                    if (v > focusVertex) { // vertices are insertices by increasing traversal order
                        foundOrInserted = false;
                        for (j = 0; j < numVisitedVertices; ++j) {
                            if (v === visitedVertices[j]) {
                                visitedVerticesValence[j]++;
                                foundOrInserted = true;
                                break;
                            } else if (v < visitedVertices[j]) {
                                ++numVisitedVertices;
                                for (h = numVisitedVertices - 1; h > j; --h) {
                                    visitedVertices[h] = visitedVertices[h - 1];
                                    visitedVerticesValence[h] = visitedVerticesValence[h - 1];
                                }
                                visitedVertices[j] = v;
                                visitedVerticesValence[j] = 1;
                                foundOrInserted = true;
                                break;
                            }
                        }
                        if (!foundOrInserted) {
                            visitedVertices[numVisitedVertices] = v;
                            visitedVerticesValence[numVisitedVertices] = 1;
                            numVisitedVertices++;
                        }
                    }
                }
            }
        }
        // re-order visited vertices by taking into account their valence (i.e., # of conquered triangles incident to each vertex)
        // in order to avoid config. 9
        if (numVisitedVertices > 2) {
            for (x = 1; x < numVisitedVertices; ++x) {
                if (visitedVerticesValence[x] === 1) {
                    y = x;
                    while ((y > 0) && (visitedVerticesValence[y] < visitedVerticesValence[y - 1])) {
                        tmp = visitedVerticesValence[y];
                        visitedVerticesValence[y] = visitedVerticesValence[y - 1];
                        visitedVerticesValence[y - 1] = tmp;
                        tmp = visitedVertices[y];
                        visitedVertices[y] = visitedVertices[y - 1];
                        visitedVertices[y - 1] = tmp;
                        --y;
                    }
                }
            }
        }
        this.m_numConqueredTriangles = numConqueredTriangles;
        this.m_numVisitedVertices = numVisitedVertices;
        return module.O3DGC_OK;
    };
    module.TriangleListDecoder.prototype.DecompressTFAN = function (focusVertex) {
        var vertexToTriangle, triangles, itDegree, itConfig, tfans, ntfans, processConfig, ctfans, triangleCount, numConqueredTriangles, degree, config, k0, k1, b, c, t, f, k;
        vertexToTriangle = this.m_vertexToTriangle;
        triangles = this.m_triangles;
        itDegree = this.m_itDegree;
        itConfig = this.m_itConfig;
        tfans = this.m_tfans;
        processConfig = this.m_processConfig;
        ctfans = this.m_ctfans;
        triangleCount = this.m_triangleCount;
        numConqueredTriangles = this.m_numConqueredTriangles;
        ntfans = ctfans.ReadNumTFans(this.m_itNumTFans);
        if (ntfans > 0) {
            for (f = 0; f < ntfans; ++f) {
                tfans.AddTFAN();
                degree = ctfans.ReadDegree(itDegree) + 2 - numConqueredTriangles;
                config = ctfans.ReadConfig(itConfig);
                k0 = tfans.GetNumVertices();
                tfans.AddVertex(focusVertex);
                processConfig[config](this, degree, focusVertex);
                k1 = tfans.GetNumVertices();
                b = tfans.GetVertex(k0 + 1);
                for (k = k0 + 2; k < k1; ++k) {
                    c = tfans.GetVertex(k);
                    t = triangleCount * 3;
                    triangles[t++] = focusVertex;
                    triangles[t++] = b;
                    triangles[t] = c;
                    vertexToTriangle.AddNeighbor(focusVertex, triangleCount);
                    vertexToTriangle.AddNeighbor(b, triangleCount);
                    vertexToTriangle.AddNeighbor(c, triangleCount);
                    b = c;
                    triangleCount++;
                }
            }
        }
        this.m_triangleCount = triangleCount;
        return module.O3DGC_OK;
    };
    module.TriangleListDecoder.prototype.Decompress = function () {
        var focusVertex;
        for (focusVertex = 0; focusVertex < this.m_numVertices; ++focusVertex) {
            if (focusVertex === this.m_vertexCount) {
                this.m_vertexCount++; // insert focusVertex
            }
            this.CompueLocalConnectivityInfo(focusVertex);
            this.DecompressTFAN(focusVertex);
        }
        return module.O3DGC_OK;
    };
    module.TriangleListDecoder.prototype.Init = function (triangles, numTriangles, numVertices, maxSizeV2T) {
        var i, numNeighbors;
        this.m_numTriangles = numTriangles;
        this.m_numVertices = numVertices;
        this.m_triangles = triangles;
        this.m_vertexCount = 0;
        this.m_triangleCount = 0;
        this.m_itNumTFans.m_count = 0;
        this.m_itDegree.m_count = 0;
        this.m_itConfig.m_count = 0;
        this.m_itOperation.m_count = 0;
        this.m_itIndex.m_count = 0;
        if (this.m_numVertices > this.m_maxNumVertices) {
            this.m_maxNumVertices = this.m_numVertices;
            this.m_visitedVerticesValence = new Int32Array(this.m_numVertices);
            this.m_visitedVertices = new Int32Array(this.m_numVertices);
        }
        if (this.m_decodeTrianglesOrder && this.m_tempTrianglesSize < this.m_numTriangles) {
            this.m_tempTrianglesSize = this.m_numTriangles;
            this.m_tempTriangles = new Int32Array(3 * this.m_tempTrianglesSize);
        }
        this.m_ctfans.SetStreamType(this.m_streamType);
        this.m_ctfans.Allocate(this.m_numVertices, this.m_numTriangles);
        this.m_tfans.Allocate(2 * this.m_numVertices, 8 * this.m_numVertices);
        // compute vertex-to-triangle adjacency information
        this.m_vertexToTriangle.AllocateNumNeighborsArray(numVertices);
        numNeighbors = this.m_vertexToTriangle.GetNumNeighborsBuffer();
        for (i = 0; i < numVertices; ++i) {
            numNeighbors[i] = maxSizeV2T;
        }
        this.m_vertexToTriangle.AllocateNeighborsArray();
        this.m_vertexToTriangle.ClearNeighborsArray();
        return module.O3DGC_OK;
    };
    module.TriangleListDecoder.prototype.Decode = function (triangles, numTriangles, numVertices, bstream, it) {
        var compressionMask, maxSizeV2T;
        compressionMask = bstream.ReadUChar(it, this.m_streamType);
        this.m_decodeTrianglesOrder = ((compressionMask & 2) !== 0);
        this.m_decodeVerticesOrder = ((compressionMask & 1) !== 0);
        if (this.m_decodeVerticesOrder) { // vertices reordering not supported
            return module.O3DGC_ERROR_NON_SUPPORTED_FEATURE;
        }
        maxSizeV2T = bstream.ReadUInt32(it, this.m_streamType);
        this.Init(triangles, numTriangles, numVertices, maxSizeV2T);
        this.m_ctfans.Load(bstream, it, this.m_decodeTrianglesOrder, this.m_streamType);
        this.Decompress();
        return module.O3DGC_OK;
    };
    // SC3DMCDecoder class
    module.SC3DMCDecoder = function () {
        var i;
        this.m_iterator = new module.Iterator();
        this.m_streamSize = 0;
        this.m_params = new module.SC3DMCEncodeParams();
        this.m_triangleListDecoder = new module.TriangleListDecoder();
        this.m_quantFloatArray = {};
        this.m_orientation = {};
        this.m_normals = {};
        this.m_quantFloatArraySize = 0;
        this.m_normalsSize = 0;
        this.m_orientationSize = 0;
        this.m_stats = new module.SC3DMCStats();
        this.m_streamType = local.O3DGC_STREAM_TYPE_UNKOWN;
        this.m_neighbors = [];
        this.m_idelta = new Float32Array(local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES);
        this.m_minNormal = new Float32Array(2);
        this.m_maxNormal = new Float32Array(2);
        this.m_minNormal[0] = this.m_minNormal[1] = -2;
        this.m_maxNormal[0] = this.m_maxNormal[1] = 2;
        for (i = 0; i < local.O3DGC_SC3DMC_MAX_DIM_ATTRIBUTES; ++i) {
            this.m_neighbors[i] = new module.SC3DMCPredictor();
        }
    };
    module.SC3DMCDecoder.prototype.GetStats = function () {
        return this.m_stats;
    };
    module.SC3DMCDecoder.prototype.DecodeHeader = function (ifs, bstream) {
        var c0, start_code, mask, j, a, d;
        c0 = this.m_iterator.m_count;
        start_code = bstream.ReadUInt32(this.m_iterator, local.O3DGC_STREAM_TYPE_BINARY);
        if (start_code !== local.O3DGC_SC3DMC_START_CODE) {
            this.m_iterator.m_count = c0;
            start_code = bstream.ReadUInt32(this.m_iterator, local.O3DGC_STREAM_TYPE_ASCII);
            if (start_code !== local.O3DGC_SC3DMC_START_CODE) {
                return module.O3DGC_ERROR_CORRUPTED_STREAM;
            }
            this.m_streamType = local.O3DGC_STREAM_TYPE_ASCII;
        } else {
            this.m_streamType = local.O3DGC_STREAM_TYPE_BINARY;
        }
        this.m_streamSize = bstream.ReadUInt32(this.m_iterator, this.m_streamType);
        this.m_params.SetEncodeMode(bstream.ReadUChar(this.m_iterator, this.m_streamType));

        ifs.SetCreaseAngle(bstream.ReadFloat32(this.m_iterator, this.m_streamType));
        mask = bstream.ReadUChar(this.m_iterator, this.m_streamType);
        ifs.SetCCW((mask & 1) === 1);
        ifs.SetSolid((mask & 2) === 1);
        ifs.SetConvex((mask & 4) === 1);
        ifs.SetIsTriangularMesh((mask & 8) === 1);

        ifs.SetNCoord(bstream.ReadUInt32(this.m_iterator, this.m_streamType));
        ifs.SetNNormal(bstream.ReadUInt32(this.m_iterator, this.m_streamType));
        ifs.SetNumFloatAttributes(bstream.ReadUInt32(this.m_iterator, this.m_streamType));
        ifs.SetNumIntAttributes(bstream.ReadUInt32(this.m_iterator, this.m_streamType));

        if (ifs.GetNCoord() > 0) {
            ifs.SetNCoordIndex(bstream.ReadUInt32(this.m_iterator, this.m_streamType));
            for (j = 0; j < 3; ++j) {
                ifs.SetCoordMin(j, bstream.ReadFloat32(this.m_iterator, this.m_streamType));
                ifs.SetCoordMax(j, bstream.ReadFloat32(this.m_iterator, this.m_streamType));
            }
            this.m_params.SetCoordQuantBits(bstream.ReadUChar(this.m_iterator, this.m_streamType));
        }
        if (ifs.GetNNormal() > 0) {
            ifs.SetNNormalIndex(bstream.ReadUInt32(this.m_iterator, this.m_streamType));
            for (j = 0; j < 3; ++j) {
                ifs.SetNormalMin(j, bstream.ReadFloat32(this.m_iterator, this.m_streamType));
                ifs.SetNormalMax(j, bstream.ReadFloat32(this.m_iterator, this.m_streamType));
            }
            ifs.SetNormalPerVertex(bstream.ReadUChar(this.m_iterator, this.m_streamType) === 1);
            this.m_params.SetNormalQuantBits(bstream.ReadUChar(this.m_iterator, this.m_streamType));
        }
        for (a = 0; a < ifs.GetNumFloatAttributes(); ++a) {
            ifs.SetNFloatAttribute(a, bstream.ReadUInt32(this.m_iterator, this.m_streamType));
            if (ifs.GetNFloatAttribute(a) > 0) {
                ifs.SetNFloatAttributeIndex(a, bstream.ReadUInt32(this.m_iterator, this.m_streamType));
                d = bstream.ReadUChar(this.m_iterator, this.m_streamType);
                ifs.SetFloatAttributeDim(a, d);
                for (j = 0; j < d; ++j) {
                    ifs.SetFloatAttributeMin(a, j, bstream.ReadFloat32(this.m_iterator, this.m_streamType));
                    ifs.SetFloatAttributeMax(a, j, bstream.ReadFloat32(this.m_iterator, this.m_streamType));
                }
                ifs.SetFloatAttributePerVertex(a, bstream.ReadUChar(this.m_iterator, this.m_streamType) === 1);
                ifs.SetFloatAttributeType(a, bstream.ReadUChar(this.m_iterator, this.m_streamType));
                this.m_params.SetFloatAttributeQuantBits(a, bstream.ReadUChar(this.m_iterator, this.m_streamType));
            }
        }
        for (a = 0; a < ifs.GetNumIntAttributes(); ++a) {
            ifs.SetNIntAttribute(a, bstream.ReadUInt32(this.m_iterator, this.m_streamType));
            if (ifs.GetNIntAttribute(a) > 0) {
                ifs.SetNIntAttributeIndex(a, bstream.ReadUInt32(this.m_iterator, this.m_streamType));
                ifs.SetIntAttributeDim(a, bstream.ReadUChar(this.m_iterator, this.m_streamType));
                ifs.SetIntAttributePerVertex(a, bstream.ReadUChar(this.m_iterator, this.m_streamType) === 1);
                ifs.SetIntAttributeType(a, bstream.ReadUChar(this.m_iterator, this.m_streamType));
            }
        }
        return module.O3DGC_OK;
    };
    function DeltaPredictors(triangles, ta, v, nPred, neighbors, dimFloatArray, quantFloatArray, stride) {
        var ws, k, p, w, i, id;
        id = new module.SC3DMCTriplet(-1, -1, -1);
        for (k = 0; k < 3; ++k) {
            w = triangles[ta * 3 + k];
            if (w < v) {
                id.m_a = -1;
                id.m_b = -1;
                id.m_c = w;
                p = InsertPredictor(id, nPred, neighbors, dimFloatArray);
                if (p !== -1) {
                    ws = w * stride;
                    for (i = 0; i < dimFloatArray; ++i) {
                        neighbors[p].m_pred[i] = quantFloatArray[ws + i];
                    }
                }
            }
        }
    }
    function ParallelogramPredictors(triangles, ta, v, nPred, neighbors, dimFloatArray, quantFloatArray, stride, v2T, v2TNeighbors) {
        var ta3, tb3, as, bs, cs, a, b, c, x, i, k, u1_begin, u1_end, u1, tb, foundB, p, id;
        ta3 = ta * 3;
        id = new module.SC3DMCTriplet(-1, -1, -1);
        if (triangles[ta3] === v) {
            a = triangles[ta3 + 1];
            b = triangles[ta3 + 2];
        } else if (triangles[ta3 + 1] === v) {
            a = triangles[ta3];
            b = triangles[ta3 + 2];
        } else {
            a = triangles[ta3];
            b = triangles[ta3 + 1];
        }
        if (a < v && b < v) {
            u1_begin = v2T.Begin(a);
            u1_end = v2T.End(a);
            for (u1 = u1_begin; u1 < u1_end; ++u1) {
                tb = v2TNeighbors[u1];
                if (tb < 0) {
                    break;
                }
                tb3 = tb * 3;
                c = -1;
                foundB = false;
                for (k = 0; k < 3; ++k) {
                    x = triangles[tb3 + k];
                    if (x === b) {
                        foundB = true;
                    } else if (x < v && x !== a) {
                        c = x;
                    }
                }
                if (c !== -1 && foundB) {
                    if (a < b) {
                        id.m_a = a;
                        id.m_b = b;
                    } else {
                        id.m_a = b;
                        id.m_b = a;
                    }
                    id.m_c = (-c - 1);
                    p = InsertPredictor(id, nPred, neighbors, dimFloatArray);
                    if (p !== -1) {
                        as = a * stride;
                        bs = b * stride;
                        cs = c * stride;
                        for (i = 0; i < dimFloatArray; ++i) {
                            neighbors[p].m_pred[i] = quantFloatArray[as + i] + quantFloatArray[bs + i] - quantFloatArray[cs + i];
                        }
                    }
                }
            }
        }
    }
    module.SC3DMCDecoder.prototype.DecodeIntArrayBinary = function (intArray,
                                                                    numIntArray,
                                                                    dimIntArray,
                                                                    stride,
                                                                    ifs,
                                                                    predMode,
                                                                    bstream) {
        var testPredEnabled, bestPred, i, u, ta, u_begin, u_end, buffer, iterator, streamType, predResidual, acd, bModel0, bModel1, mModelPreds, v2T, v2TNeighbors, triangles, size, start, streamSize, mask, binarization, iteratorPred, exp_k, M, id, mModelValues, neighbors, normals, nPred, v;
        iterator = this.m_iterator;
        streamType = this.m_streamType;
        acd = new module.ArithmeticDecoder();
        bModel0 = new module.StaticBitModel();
        bModel1 = new module.AdaptiveBitModel();
        mModelPreds = new module.AdaptiveDataModel();
        mModelPreds.SetAlphabet(local.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS + 1);
        v2T = this.m_triangleListDecoder.GetVertexToTriangle();
        v2TNeighbors = v2T.m_neighbors;
        triangles = ifs.GetCoordIndex();
        size = numIntArray * dimIntArray;
        start = iterator.m_count;
        streamSize = bstream.ReadUInt32(iterator, streamType);        // bitsream size
        mask = bstream.ReadUChar(iterator, streamType);
        binarization = (mask >>> 4) & 7;
        predMode.m_value = mask & 7;
        streamSize -= (iterator.m_count - start);
        iteratorPred = new module.Iterator();
        iteratorPred.m_count = iterator.m_count + streamSize;
        exp_k = 0;
        M = 0;
        id = new module.SC3DMCTriplet(-1, -1, -1);
        if (binarization !== local.O3DGC_SC3DMC_BINARIZATION_AC_EGC) {
            return module.O3DGC_ERROR_CORRUPTED_STREAM;
        }
        buffer = bstream.GetBuffer(iterator, streamSize);
        iterator.m_count += streamSize;
        acd.SetBuffer(streamSize, buffer);
        acd.StartDecoder();
        exp_k = acd.ExpGolombDecode(0, bModel0, bModel1);
        M = acd.ExpGolombDecode(0, bModel0, bModel1);
        mModelValues = new module.AdaptiveDataModel();
        mModelValues.SetAlphabet(M + 2);
        neighbors = this.m_neighbors;
        normals = this.m_normals;
        nPred = new module.NumberRef();
        testPredEnabled = predMode.m_value !== local.O3DGC_SC3DMC_NO_PREDICTION;
        for (v = 0; v < numIntArray; ++v) {
            nPred.m_value = 0;
            if (v2T.GetNumNeighbors(v) > 0 && testPredEnabled) {
                u_begin = v2T.Begin(v);
                u_end = v2T.End(v);
                for (u = u_begin; u < u_end; ++u) {
                    ta = v2TNeighbors[u];
                    if (ta < 0) {
                        break;
                    }
                    DeltaPredictors(triangles, ta, v, nPred, neighbors, dimIntArray, intArray, stride);
                }
            }
            if (nPred.m_value > 1) {
                bestPred = acd.DecodeAdaptiveDataModel(mModelPreds);
                for (i = 0; i < dimIntArray; ++i) {
                    predResidual = acd.DecodeIntACEGC(mModelValues, bModel0, bModel1, exp_k, M);
                    intArray[v * stride + i] = predResidual + neighbors[bestPred].m_pred[i];
                }
            } else if (v > 0 && predMode.m_value !== local.O3DGC_SC3DMC_NO_PREDICTION) {
                for (i = 0; i < dimIntArray; ++i) {
                    predResidual = acd.DecodeIntACEGC(mModelValues, bModel0, bModel1, exp_k, M);
                    intArray[v * stride + i] = predResidual + intArray[(v - 1) * stride + i];
                }
            } else {
                for (i = 0; i < dimIntArray; ++i) {
                    predResidual = acd.DecodeUIntACEGC(mModelValues, bModel0, bModel1, exp_k, M);
                    intArray[v * stride + i] = predResidual;
                }
            }
        }
        iterator.m_count = iteratorPred.m_count;
        return module.O3DGC_OK;
    };
    module.SC3DMCDecoder.prototype.DecodeIntArrayASCII = function (intArray,
                                                                   numIntArray,
                                                                   dimIntArray,
                                                                   stride,
                                                                   ifs,
                                                                   predMode,
                                                                   bstream) {
        var testPredEnabled, iterator, streamType, predResidual, v2T, v2TNeighbors, triangles, size, start, streamSize, mask, binarization, iteratorPred, id, neighbors, normals, nPred, v, u_begin, u_end, u, ta, i, bestPred;
        iterator = this.m_iterator;
        streamType = this.m_streamType;
        v2T = this.m_triangleListDecoder.GetVertexToTriangle();
        v2TNeighbors = v2T.m_neighbors;
        triangles = ifs.GetCoordIndex();
        size = numIntArray * dimIntArray;
        start = iterator.m_count;
        streamSize = bstream.ReadUInt32(iterator, streamType);        // bitsream size
        mask = bstream.ReadUChar(iterator, streamType);
        binarization = (mask >>> 4) & 7;
        predMode.m_value = mask & 7;
        streamSize -= (iterator.m_count - start);
        iteratorPred = new module.Iterator();
        iteratorPred.m_count = iterator.m_count + streamSize;
        id = new module.SC3DMCTriplet(-1, -1, -1);
        if (binarization !== local.O3DGC_SC3DMC_BINARIZATION_ASCII) {
            return module.O3DGC_ERROR_CORRUPTED_STREAM;
        }
        bstream.ReadUInt32(iteratorPred, streamType);        // predictors bitsream size
        neighbors = this.m_neighbors;
        normals = this.m_normals;
        nPred = new module.NumberRef();
        testPredEnabled = predMode.m_value !== local.O3DGC_SC3DMC_NO_PREDICTION;
        for (v = 0; v < numIntArray; ++v) {
            nPred.m_value = 0;
            if (v2T.GetNumNeighbors(v) > 0 && testPredEnabled) {
                u_begin = v2T.Begin(v);
                u_end = v2T.End(v);
                for (u = u_begin; u < u_end; ++u) {
                    ta = v2TNeighbors[u];
                    if (ta < 0) {
                        break;
                    }
                    DeltaPredictors(triangles, ta, v, nPred, neighbors, dimIntArray, intArray, stride);
                }
            }
            if (nPred.m_value > 1) {
                bestPred = bstream.ReadUCharASCII(iteratorPred);
                for (i = 0; i < dimIntArray; ++i) {
                    predResidual = bstream.ReadIntASCII(iterator);
                    intArray[v * stride + i] = predResidual + neighbors[bestPred].m_pred[i];
                }
            } else if (v > 0 && predMode.m_value !== local.O3DGC_SC3DMC_NO_PREDICTION) {
                for (i = 0; i < dimIntArray; ++i) {
                    predResidual = bstream.ReadIntASCII(iterator);
                    intArray[v * stride + i] = predResidual + intArray[(v - 1) * stride + i];
                }
            } else {
                for (i = 0; i < dimIntArray; ++i) {
                    predResidual = bstream.ReadUIntASCII(iterator);
                    intArray[v * stride + i] = predResidual;
                }
            }
        }
        iterator.m_count = iteratorPred.m_count;
        return module.O3DGC_OK;
    };
    module.SC3DMCDecoder.prototype.DecodeIntArray = function (intArray,
                                                              numIntArray,
                                                              dimIntArray,
                                                              stride,
                                                              ifs,
                                                              predMode,
                                                              bstream) {
        if (this.m_streamType === local.O3DGC_STREAM_TYPE_ASCII) {
            return this.DecodeIntArrayASCII(intArray, numIntArray, dimIntArray, stride, ifs, predMode, bstream);
        }
        return this.DecodeIntArrayBinary(intArray, numIntArray, dimIntArray, stride, ifs, predMode, bstream);
    };
    function ComputeNormals(triangles, ntris, coords, nvert, normals) {
        var t3, v, n, t, a, b, c, d1, d2, n0;
        n0 = new module.Vec3();
        d1 = new module.Vec3();
        d2 = new module.Vec3();
        n = nvert * 3;
        for (v = 0; v < n; ++v) {
            normals[v] = 0;
        }
        for (t = 0; t < ntris; ++t) {
            t3 = t * 3;
            a = triangles[t3] * 3;
            b = triangles[t3 + 1] * 3;
            c = triangles[t3 + 2] * 3;
            d1.m_x = coords[b] - coords[a];
            d1.m_y = coords[b + 1] - coords[a + 1];
            d1.m_z = coords[b + 2] - coords[a + 2];
            d2.m_x = coords[c] - coords[a];
            d2.m_y = coords[c + 1] - coords[a + 1];
            d2.m_z = coords[c + 2] - coords[a + 2];
            n0.m_x = d1.m_y * d2.m_z - d1.m_z * d2.m_y;
            n0.m_y = d1.m_z * d2.m_x - d1.m_x * d2.m_z;
            n0.m_z = d1.m_x * d2.m_y - d1.m_y * d2.m_x;
            normals[a] += n0.m_x;
            normals[a + 1] += n0.m_y;
            normals[a + 2] += n0.m_z;
            normals[b] += n0.m_x;
            normals[b + 1] += n0.m_y;
            normals[b + 2] += n0.m_z;
            normals[c] += n0.m_x;
            normals[c + 1] += n0.m_y;
            normals[c + 2] += n0.m_z;
        }
    }
    module.SC3DMCDecoder.prototype.ProcessNormals = function (ifs) {
        var v3, v2, nvert, normalSize, normals, quantFloatArray, orientation, triangles, n0, n1, v, rna0, rnb0, ni1, norm0;
        nvert = ifs.GetNNormal();

        normalSize = ifs.GetNNormal() * 3;
        if (this.m_normalsSize < normalSize) {
            this.m_normalsSize = normalSize;
            this.m_normals = new Float32Array(this.m_normalsSize);
        }
        normals = this.m_normals;
        quantFloatArray = this.m_quantFloatArray;
        orientation = this.m_orientation;
        triangles = ifs.GetCoordIndex();
        ComputeNormals(triangles, ifs.GetNCoordIndex(), quantFloatArray, nvert, normals);
        n0 = new module.Vec3();
        n1 = new module.Vec3();
        for (v = 0; v < nvert; ++v) {
            v3 = 3 * v;
            n0.m_x = normals[v3];
            n0.m_y = normals[v3 + 1];
            n0.m_z = normals[v3 + 2];
            norm0 = Math.sqrt(n0.m_x * n0.m_x + n0.m_y * n0.m_y + n0.m_z * n0.m_z);
            if (norm0 === 0.0) {
                norm0 = 1.0;
            }
            SphereToCube(n0, n1);
            rna0 = n1.m_x / norm0;
            rnb0 = n1.m_y / norm0;
            ni1 = n1.m_z + orientation[v];
            orientation[v] = ni1;
            if ((ni1 >>> 1) !== (n1.m_z >>> 1)) {
                rna0 = 0.0;
                rnb0 = 0.0;
            }
            v2 = v * 2;
            normals[v2] = rna0;
            normals[v2 + 1] = rnb0;
        }
        return module.O3DGC_OK;
    };
    module.SC3DMCDecoder.prototype.IQuantize = function (floatArray,
                                                         numFloatArray,
                                                         dimFloatArray,
                                                         stride,
                                                         minFloatArray,
                                                         maxFloatArray,
                                                         nQBits,
                                                         predMode) {
        var v, nin, nout, orientation, normals, CubeToSphere;
        if (predMode.m_value === local.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION) {
            CubeToSphere = local.CubeToSphere;
            orientation = this.m_orientation;
            normals = this.m_normals;
            nin = new module.Vec3(0, 0, 0);
            nout = new module.Vec3(0, 0, 0);
            this.IQuantizeFloatArray(floatArray, numFloatArray, dimFloatArray, stride, this.m_minNormal, this.m_maxNormal, nQBits + 1);
            for (v = 0; v < numFloatArray; ++v) {
                nin.m_x = floatArray[stride * v] + normals[2 * v];
                nin.m_y = floatArray[stride * v + 1] + normals[2 * v + 1];
                nin.m_z = orientation[v];
                CubeToSphere[nin.m_z](nin, nout);
                floatArray[stride * v] = nout.m_x;
                floatArray[stride * v + 1] = nout.m_y;
                floatArray[stride * v + 2] = nout.m_z;
            }
        } else {
            this.IQuantizeFloatArray(floatArray, numFloatArray, dimFloatArray, stride, minFloatArray, maxFloatArray, nQBits);
        }
    };
    module.SC3DMCDecoder.prototype.DecodeFloatArrayBinary = function (floatArray,
                                                                      numFloatArray,
                                                                      dimFloatArray,
                                                                      stride,
                                                                      minFloatArray,
                                                                      maxFloatArray,
                                                                      nQBits,
                                                                      ifs,
                                                                      predMode,
                                                                      bstream) {
        var maxNPred, testPredEnabled, testParaPredEnabled, bestPred, dModel, buffer, quantFloatArray, neighbors, normals, nPred, ta, i, v, u, u_begin, u_end, iterator, orientation, streamType, predResidual, acd, bModel0, bModel1, mModelPreds, v2T, v2TNeighbors, triangles, size, start, streamSize, mask, binarization, iteratorPred, exp_k, M, mModelValues;
        iterator = this.m_iterator;
        orientation = this.m_orientation;
        streamType = this.m_streamType;
        acd = new module.ArithmeticDecoder();
        bModel0 = new module.StaticBitModel();
        bModel1 = new module.AdaptiveBitModel();
        mModelPreds = new module.AdaptiveDataModel();
        maxNPred = local.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS;
        mModelPreds.SetAlphabet(maxNPred + 1);
        v2T = this.m_triangleListDecoder.GetVertexToTriangle();
        v2TNeighbors = v2T.m_neighbors;
        triangles = ifs.GetCoordIndex();
        size = numFloatArray * dimFloatArray;
        start = iterator.m_count;
        streamSize = bstream.ReadUInt32(iterator, streamType);
        mask = bstream.ReadUChar(iterator, streamType);
        binarization = (mask >>> 4) & 7;
        predMode.m_value = mask & 7;
        streamSize -= (iterator.m_count - start);
        iteratorPred = new module.Iterator();
        iteratorPred.m_count = iterator.m_count + streamSize;
        exp_k = 0;
        M = 0;
        if (binarization !== local.O3DGC_SC3DMC_BINARIZATION_AC_EGC) {
            return module.O3DGC_ERROR_CORRUPTED_STREAM;
        }
        buffer = bstream.GetBuffer(iterator, streamSize);
        iterator.m_count += streamSize;
        acd.SetBuffer(streamSize, buffer);
        acd.StartDecoder();
        exp_k = acd.ExpGolombDecode(0, bModel0, bModel1);
        M = acd.ExpGolombDecode(0, bModel0, bModel1);
        mModelValues = new module.AdaptiveDataModel();
        mModelValues.SetAlphabet(M + 2);
        if (predMode.m_value === local.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION) {
            if (this.m_orientationSize < size) {
                this.m_orientationSize = size;
                this.m_orientation = new Int8Array(this.m_orientationSize);
                orientation = this.m_orientation;
            }
            dModel = new module.AdaptiveDataModel();
            dModel.SetAlphabet(12);
            for (i = 0; i < numFloatArray; ++i) {
                orientation[i] = UIntToInt(acd.DecodeAdaptiveDataModel(dModel));
            }
            this.ProcessNormals(ifs);
            dimFloatArray = 2;
        }
        if (this.m_quantFloatArraySize < size) {
            this.m_quantFloatArraySize = size;
            this.m_quantFloatArray = new Int32Array(this.m_quantFloatArraySize);
        }
        quantFloatArray = this.m_quantFloatArray;
        neighbors = this.m_neighbors;
        normals = this.m_normals;
        nPred = new module.NumberRef();
        testPredEnabled = predMode.m_value !== local.O3DGC_SC3DMC_NO_PREDICTION;
        testParaPredEnabled = predMode.m_value === local.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION;
        for (v = 0; v < numFloatArray; ++v) {
            nPred.m_value = 0;
            if (v2T.GetNumNeighbors(v) > 0 && testPredEnabled) {
                u_begin = v2T.Begin(v);
                u_end = v2T.End(v);
                if (testParaPredEnabled) {
                    for (u = u_begin; u < u_end; ++u) {
                        ta = v2TNeighbors[u];
                        if (ta < 0) {
                            break;
                        }
                        ParallelogramPredictors(triangles, ta, v, nPred, neighbors, dimFloatArray, quantFloatArray, stride, v2T, v2TNeighbors);
                    }
                }
                if (nPred.m_value < maxNPred) {
                    for (u = u_begin; u < u_end; ++u) {
                        ta = v2TNeighbors[u];
                        if (ta < 0) {
                            break;
                        }
                        DeltaPredictors(triangles, ta, v, nPred, neighbors, dimFloatArray, quantFloatArray, stride);
                    }
                }
            }
            if (nPred.m_value > 1) {
                bestPred = acd.DecodeAdaptiveDataModel(mModelPreds);
                for (i = 0; i < dimFloatArray; ++i) {
                    predResidual = acd.DecodeIntACEGC(mModelValues, bModel0, bModel1, exp_k, M);
                    quantFloatArray[v * stride + i] = predResidual + neighbors[bestPred].m_pred[i];
                }
            } else if (v > 0 && testPredEnabled) {
                for (i = 0; i < dimFloatArray; ++i) {
                    predResidual = acd.DecodeIntACEGC(mModelValues, bModel0, bModel1, exp_k, M);
                    quantFloatArray[v * stride + i] = predResidual + quantFloatArray[(v - 1) * stride + i];
                }
            } else {
                for (i = 0; i < dimFloatArray; ++i) {
                    predResidual = acd.DecodeUIntACEGC(mModelValues, bModel0, bModel1, exp_k, M);
                    quantFloatArray[v * stride + i] = predResidual;
                }
            }
        }
        iterator.m_count = iteratorPred.m_count;
        this.IQuantize(floatArray, numFloatArray, dimFloatArray, stride, minFloatArray, maxFloatArray, nQBits, predMode);
        return module.O3DGC_OK;
    };
    module.SC3DMCDecoder.prototype.DecodeFloatArrayASCII = function (floatArray,
                                                                     numFloatArray,
                                                                     dimFloatArray,
                                                                     stride,
                                                                     minFloatArray,
                                                                     maxFloatArray,
                                                                     nQBits,
                                                                     ifs,
                                                                     predMode,
                                                                     bstream) {
        var maxNPred, testPredEnabled, testParaPredEnabled, iterator, orientation, streamType, predResidual, v2T, v2TNeighbors, triangles, size, start, streamSize, mask, binarization, iteratorPred, quantFloatArray, neighbors, normals, nPred, v, u, u_begin, u_end, ta, i, bestPred;
        maxNPred = local.O3DGC_SC3DMC_MAX_PREDICTION_NEIGHBORS;
        iterator = this.m_iterator;
        orientation = this.m_orientation;
        streamType = this.m_streamType;
        v2T = this.m_triangleListDecoder.GetVertexToTriangle();
        v2TNeighbors = v2T.m_neighbors;
        triangles = ifs.GetCoordIndex();
        size = numFloatArray * dimFloatArray;
        start = iterator.m_count;
        streamSize = bstream.ReadUInt32(iterator, streamType);
        mask = bstream.ReadUChar(iterator, streamType);
        binarization = (mask >>> 4) & 7;
        predMode.m_value = mask & 7;
        streamSize -= (iterator.m_count - start);
        iteratorPred = new module.Iterator();
        iteratorPred.m_count = iterator.m_count + streamSize;
        if (binarization !== local.O3DGC_SC3DMC_BINARIZATION_ASCII) {
            return module.O3DGC_ERROR_CORRUPTED_STREAM;
        }
        bstream.ReadUInt32(iteratorPred, streamType);
        if (predMode.m_value === local.O3DGC_SC3DMC_SURF_NORMALS_PREDICTION) {
            if (this.m_orientationSize < numFloatArray) {
                this.m_orientationSize = numFloatArray;
                this.m_orientation = new Int8Array(this.m_orientationSize);
                orientation = this.m_orientation;
            }
            for (i = 0; i < numFloatArray; ++i) {
                orientation[i] = bstream.ReadIntASCII(iterator);
            }
            this.ProcessNormals(ifs);
            dimFloatArray = 2;
        }
        if (this.m_quantFloatArraySize < size) {
            this.m_quantFloatArraySize = size;
            this.m_quantFloatArray = new Int32Array(this.m_quantFloatArraySize);
        }
        quantFloatArray = this.m_quantFloatArray;
        neighbors = this.m_neighbors;
        normals = this.m_normals;
        nPred = new module.NumberRef();
        testPredEnabled = predMode.m_value !== local.O3DGC_SC3DMC_NO_PREDICTION;
        testParaPredEnabled = predMode.m_value === local.O3DGC_SC3DMC_PARALLELOGRAM_PREDICTION;
        for (v = 0; v < numFloatArray; ++v) {
            nPred.m_value = 0;
            if (v2T.GetNumNeighbors(v) > 0 && testPredEnabled) {
                u_begin = v2T.Begin(v);
                u_end = v2T.End(v);
                if (testParaPredEnabled) {
                    for (u = u_begin; u < u_end; ++u) {
                        ta = v2TNeighbors[u];
                        if (ta < 0) {
                            break;
                        }
                        ParallelogramPredictors(triangles, ta, v, nPred, neighbors, dimFloatArray, quantFloatArray, stride, v2T, v2TNeighbors);
                    }
                }
                if (nPred.m_value < maxNPred) {
                    for (u = u_begin; u < u_end; ++u) {
                        ta = v2TNeighbors[u];
                        if (ta < 0) {
                            break;
                        }
                        DeltaPredictors(triangles, ta, v, nPred, neighbors, dimFloatArray, quantFloatArray, stride);
                    }
                }
            }
            if (nPred.m_value > 1) {
                bestPred = bstream.ReadUCharASCII(iteratorPred);
                for (i = 0; i < dimFloatArray; ++i) {
                    predResidual = bstream.ReadIntASCII(iterator);
                    quantFloatArray[v * stride + i] = predResidual + neighbors[bestPred].m_pred[i];
                }
            } else if (v > 0 && predMode.m_value !== local.O3DGC_SC3DMC_NO_PREDICTION) {
                for (i = 0; i < dimFloatArray; ++i) {
                    predResidual = bstream.ReadIntASCII(iterator);
                    quantFloatArray[v * stride + i] = predResidual + quantFloatArray[(v - 1) * stride + i];
                }
            } else {
                for (i = 0; i < dimFloatArray; ++i) {
                    predResidual = bstream.ReadUIntASCII(iterator);
                    quantFloatArray[v * stride + i] = predResidual;
                }
            }
        }
        iterator.m_count = iteratorPred.m_count;
        this.IQuantize(floatArray, numFloatArray, dimFloatArray, stride, minFloatArray, maxFloatArray, nQBits, predMode);
        return module.O3DGC_OK;
    };
    module.SC3DMCDecoder.prototype.DecodeFloatArray = function (floatArray,
                                                                numFloatArray,
                                                                dimFloatArray,
                                                                stride,
                                                                minFloatArray,
                                                                maxFloatArray,
                                                                nQBits,
                                                                ifs,
                                                                predMode,
                                                                bstream) {
        if (this.m_streamType === local.O3DGC_STREAM_TYPE_ASCII) {
            return this.DecodeFloatArrayASCII(floatArray, numFloatArray, dimFloatArray, stride, minFloatArray, maxFloatArray, nQBits, ifs, predMode, bstream);
        }
        return this.DecodeFloatArrayBinary(floatArray, numFloatArray, dimFloatArray, stride, minFloatArray, maxFloatArray, nQBits, ifs, predMode, bstream);
    };
    module.SC3DMCDecoder.prototype.IQuantizeFloatArray = function (floatArray, numFloatArray, dimFloatArray, stride, minFloatArray, maxFloatArray, nQBits) {
        var idelta, quantFloatArray, d, r, v;
        idelta = this.m_idelta;
        quantFloatArray = this.m_quantFloatArray;
        for (d = 0; d < dimFloatArray; ++d) {
            r = maxFloatArray[d] - minFloatArray[d];
            if (r > 0.0) {
                idelta[d] = r / (((1 << nQBits) >>> 0) - 1);
            } else {
                idelta[d] = 1.0;
            }
        }
        for (v = 0; v < numFloatArray; ++v) {
            for (d = 0; d < dimFloatArray; ++d) {
                floatArray[v * stride + d] = quantFloatArray[v * stride + d] * idelta[d] + minFloatArray[d];
            }
        }
        return module.O3DGC_OK;
    };
    module.SC3DMCDecoder.prototype.DecodePlayload = function (ifs, bstream) {
        var params, iterator, stats, predMode, timer, ret, a;
        params = this.m_params;
        iterator = this.m_iterator;
        stats = this.m_stats;
        predMode = new module.NumberRef();
        timer = new module.Timer();
        ret = module.O3DGC_OK;
        this.m_triangleListDecoder.SetStreamType(this.m_streamType);
        stats.m_streamSizeCoordIndex = iterator.m_count;
        timer.Tic();
        this.m_triangleListDecoder.Decode(ifs.GetCoordIndex(), ifs.GetNCoordIndex(), ifs.GetNCoord(), bstream, iterator);
        timer.Toc();
        stats.m_timeCoordIndex = timer.GetElapsedTime();
        stats.m_streamSizeCoordIndex = iterator.m_count - stats.m_streamSizeCoordIndex;
        // decode coord
        stats.m_streamSizeCoord = iterator.m_count;
        timer.Tic();
        if (ifs.GetNCoord() > 0) {
            ret = this.DecodeFloatArray(ifs.GetCoord(), ifs.GetNCoord(), 3, 3, ifs.GetCoordMinArray(), ifs.GetCoordMaxArray(), params.GetCoordQuantBits(), ifs, predMode, bstream);
            params.SetCoordPredMode(predMode.m_value);
        }
        if (ret !== module.O3DGC_OK) {
            return ret;
        }
        timer.Toc();
        stats.m_timeCoord = timer.GetElapsedTime();
        stats.m_streamSizeCoord = iterator.m_count - stats.m_streamSizeCoord;

        // decode Normal
        stats.m_streamSizeNormal = iterator.m_count;
        timer.Tic();
        if (ifs.GetNNormal() > 0) {
            ret = this.DecodeFloatArray(ifs.GetNormal(), ifs.GetNNormal(), 3, 3, ifs.GetNormalMinArray(), ifs.GetNormalMaxArray(), params.GetNormalQuantBits(), ifs, predMode, bstream);
            params.SetNormalPredMode(predMode.m_value);
        }
        if (ret !== module.O3DGC_OK) {
            return ret;
        }
        timer.Toc();
        stats.m_timeNormal = timer.GetElapsedTime();
        stats.m_streamSizeNormal = iterator.m_count - stats.m_streamSizeNormal;

        // decode FloatAttributes
        for (a = 0; a < ifs.GetNumFloatAttributes(); ++a) {
            stats.m_streamSizeFloatAttribute[a] = iterator.m_count;
            timer.Tic();
            ret = this.DecodeFloatArray(ifs.GetFloatAttribute(a), ifs.GetNFloatAttribute(a), ifs.GetFloatAttributeDim(a), ifs.GetFloatAttributeDim(a), ifs.GetFloatAttributeMinArray(a), ifs.GetFloatAttributeMaxArray(a), params.GetFloatAttributeQuantBits(a), ifs, predMode, bstream);
            params.SetFloatAttributePredMode(a, predMode.m_value);
            timer.Toc();
            stats.m_timeFloatAttribute[a] = timer.GetElapsedTime();
            stats.m_streamSizeFloatAttribute[a] = iterator.m_count - stats.m_streamSizeFloatAttribute[a];
        }
        if (ret !== module.O3DGC_OK) {
            return ret;
        }
        // decode IntAttributes
        for (a = 0; a < ifs.GetNumIntAttributes(); ++a) {
            stats.m_streamSizeIntAttribute[a] = iterator.m_count;
            timer.Tic();
            ret = this.DecodeIntArray(ifs.GetIntAttribute(a), ifs.GetNIntAttribute(a), ifs.GetIntAttributeDim(a), ifs.GetIntAttributeDim(a), ifs, predMode, bstream);
            params.SetIntAttributePredMode(a, predMode.m_value);
            timer.Toc();
            stats.m_timeIntAttribute[a] = timer.GetElapsedTime();
            stats.m_streamSizeIntAttribute[a] = iterator.m_count - stats.m_streamSizeIntAttribute[a];
        }
        if (ret !== module.O3DGC_OK) {
            return ret;
        }
        timer.Tic();
        this.m_triangleListDecoder.Reorder();
        timer.Toc();
        stats.m_timeReorder = timer.GetElapsedTime();
        return ret;
    };
    // DVEncodeParams class
    module.DVEncodeParams = function () {
        this.m_encodeMode = local.O3DGC_DYNAMIC_VECTOR_ENCODE_MODE_LIFT;
        this.m_streamTypeMode = local.O3DGC_STREAM_TYPE_ASCII;
        this.m_quantBits = 10;
    };
    module.DVEncodeParams.prototype.GetStreamType = function () {
        return this.m_streamTypeMode;
    };
    module.DVEncodeParams.prototype.GetEncodeMode = function () {
        return this.m_encodeMode;
    };
    module.DVEncodeParams.prototype.GetQuantBits = function () {
        return this.m_quantBits;
    };
    module.DVEncodeParams.prototype.SetStreamType = function (streamTypeMode) {
        this.m_streamTypeMode = streamTypeMode;
    };
    module.DVEncodeParams.prototype.SetEncodeMode = function (encodeMode) {
        this.m_encodeMode = encodeMode;
    };
    module.DVEncodeParams.prototype.SetQuantBits = function (quantBits) {
        this.m_quantBits = quantBits;
    };
    // DynamicVector class
    module.DynamicVector = function () {
        this.m_num = 0;
        this.m_dim = 0;
        this.m_stride = 0;
        this.m_max = {};
        this.m_min = {};
        this.m_vectors = {};
    };
    module.DynamicVector.prototype.GetNVector = function () {
        return this.m_num;
    };
    module.DynamicVector.prototype.GetDimVector = function () {
        return this.m_dim;
    };
    module.DynamicVector.prototype.GetStride = function () {
        return this.m_stride;
    };
    module.DynamicVector.prototype.GetMinArray = function () {
        return this.m_min;
    };
    module.DynamicVector.prototype.GetMaxArray = function () {
        return this.m_max;
    };
    module.DynamicVector.prototype.GetVectors = function () {
        return this.m_vectors;
    };
    module.DynamicVector.prototype.GetMin = function (j) {
        return this.m_min[j];
    };
    module.DynamicVector.prototype.GetMax = function (j) {
        return this.m_max[j];
    };
    module.DynamicVector.prototype.SetNVector = function (num) {
        this.m_num = num;
    };
    module.DynamicVector.prototype.SetDimVector = function (dim) {
        this.m_dim = dim;
    };
    module.DynamicVector.prototype.SetStride = function (stride) {
        this.m_stride = stride;
    };
    module.DynamicVector.prototype.SetMinArray = function (min) {
        this.m_min = min;
    };
    module.DynamicVector.prototype.SetMaxArray = function (max) {
        this.m_max = max;
    };
    module.DynamicVector.prototype.SetMin = function (j, min) {
        this.m_min[j] = min;
    };
    module.DynamicVector.prototype.SetMax = function (j, max) {
        this.m_max[j] = max;
    };
    module.DynamicVector.prototype.SetVectors = function (vectors) {
        this.m_vectors = vectors;
    };
    // DynamicVectorDecoder class
    module.DynamicVectorDecoder = function () {
        this.m_streamSize = 0;
        this.m_maxNumVectors = 0;
        this.m_numVectors = 0;
        this.m_dimVectors = 0;
        this.m_quantVectors = {};
        this.m_iterator = new module.Iterator();
        this.m_streamType = local.O3DGC_STREAM_TYPE_UNKOWN;
        this.m_params = new module.DVEncodeParams();
    };
    module.DynamicVectorDecoder.prototype.GetStreamType = function () {
        return this.m_streamType;
    };
    module.DynamicVectorDecoder.prototype.GetIterator = function () {
        return this.m_iterator;
    };
    module.DynamicVectorDecoder.prototype.SetStreamType = function (streamType) {
        this.m_streamType = streamType;
    };
    module.DynamicVectorDecoder.prototype.SetIterator = function (iterator) {
        this.m_iterator = iterator;
    };
    module.DynamicVectorDecoder.prototype.IUpdate = function (data, shift, size) {
        var p, size1;
        size1 = size - 1;
        p = 2;
        data[shift] -= data[shift + 1] >> 1;
        while (p < size1) {
            data[shift + p] -= (data[shift + p - 1] + data[shift + p + 1] + 2) >> 2;
            p += 2;
        }
        if (p === size1) {
            data[shift + p] -= data[shift + p - 1] >> 1;
        }
        return module.O3DGC_OK;
    };
    module.DynamicVectorDecoder.prototype.IPredict = function (data, shift, size) {
        var p, size1;
        size1 = size - 1;
        p = 1;
        while (p < size1) {
            data[shift + p] += (data[shift + p - 1] + data[shift + p + 1] + 1) >> 1;
            p += 2;
        }
        if (p === size1) {
            data[shift + p] += data[shift + p - 1];
        }
        return module.O3DGC_OK;
    };
    module.DynamicVectorDecoder.prototype.Merge = function (data, shift, size) {
        var i, h, a, b, tmp;
        h = (size >> 1) + (size & 1);
        a = h - 1;
        b = h;
        while (a > 0) {
            for (i = a; i < b; i += 2) {
                tmp = data[shift + i];
                data[shift + i] = data[shift + i + 1];
                data[shift + i + 1] = tmp;
            }
            --a;
            ++b;
        }
        return module.O3DGC_OK;
    };
    module.DynamicVectorDecoder.prototype.ITransform = function (data, shift, size) {
        var n, even, k, i;
        n = size;
        even = 0;
        k = 0;
        even += ((n & 1) << k++) >>> 0;
        while (n > 1) {
            n = (n >> 1) + ((n & 1) >>> 0);
            even += ((n & 1) << k++) >>> 0;
        }
        for (i = k - 2; i >= 0; --i) {
            n = ((n << 1) >>> 0) - (((even >>> i) & 1)) >>> 0;
            this.Merge(data, shift, n);
            this.IUpdate(data, shift, n);
            this.IPredict(data, shift, n);
        }
        return module.O3DGC_OK;
    };
    module.DynamicVectorDecoder.prototype.IQuantize = function (floatArray,
                                                       numFloatArray,
                                                       dimFloatArray,
                                                       stride,
                                                       minFloatArray,
                                                       maxFloatArray,
                                                       nQBits) {
        var quantVectors, r, idelta, size, d, v;
        quantVectors = this.m_quantVectors;
        size = numFloatArray * dimFloatArray;
        for (d = 0; d < dimFloatArray; ++d) {
            r = maxFloatArray[d] - minFloatArray[d];
            if (r > 0.0) {
                idelta = r / (((1 << nQBits) >>> 0) - 1);
            } else {
                idelta = 1.0;
            }
            for (v = 0; v < numFloatArray; ++v) {
                floatArray[v * stride + d] = quantVectors[v + d * numFloatArray] * idelta + minFloatArray[d];
            }
        }
        return module.O3DGC_OK;
    };
    module.DynamicVectorDecoder.prototype.DecodeHeader = function (dynamicVector, bstream) {
        var iterator, c0, start_code, streamType;
        iterator = this.m_iterator;
        c0 = iterator.m_count;
        start_code = bstream.ReadUInt32(iterator, local.O3DGC_STREAM_TYPE_BINARY);
        if (start_code !== local.O3DGC_DV_START_CODE) {
            iterator.m_count = c0;
            start_code = bstream.ReadUInt32(iterator, local.O3DGC_STREAM_TYPE_ASCII);
            if (start_code !== local.O3DGC_DV_START_CODE) {
                return module.O3DGC_ERROR_CORRUPTED_STREAM;
            }
            this.m_streamType = local.O3DGC_STREAM_TYPE_ASCII;
        } else {
            this.m_streamType = local.O3DGC_STREAM_TYPE_BINARY;
        }
        streamType = this.m_streamType;
        this.m_streamSize = bstream.ReadUInt32(iterator, streamType);
        this.m_params.SetEncodeMode(bstream.ReadUChar(iterator, streamType));
        dynamicVector.SetNVector(bstream.ReadUInt32(iterator, streamType));
        if (dynamicVector.GetNVector() > 0) {
            dynamicVector.SetDimVector(bstream.ReadUInt32(iterator, streamType));
            this.m_params.SetQuantBits(bstream.ReadUChar(iterator, streamType));
        }
        return module.O3DGC_OK;
    };
    module.DynamicVectorDecoder.prototype.DecodePlayload = function (dynamicVector, bstream) {
        var size, iterator, streamType, ret, start, streamSize, dim, num, j, acd, bModel0, bModel1, exp_k, M, buffer, mModelValues, quantVectors, v, d;
        iterator = this.m_iterator;
        streamType = this.m_streamType;
        ret = module.O3DGC_OK;
        start = iterator.m_count;
        streamSize = bstream.ReadUInt32(iterator, streamType);
        dim = dynamicVector.GetDimVector();
        num = dynamicVector.GetNVector();
        size = dim * num;
        for (j = 0; j < dynamicVector.GetDimVector(); ++j) {
            dynamicVector.SetMin(j, bstream.ReadFloat32(iterator, streamType));
            dynamicVector.SetMax(j, bstream.ReadFloat32(iterator, streamType));
        }
        acd = new module.ArithmeticDecoder();
        bModel0 = new module.StaticBitModel();
        bModel1 = new module.AdaptiveBitModel();
        streamSize -= (iterator.m_count - start);
        exp_k = 0;
        M = 0;
        if (streamType === local.O3DGC_STREAM_TYPE_BINARY) {
            buffer = bstream.GetBuffer(iterator, streamSize);
            iterator.m_count += streamSize;
            acd.SetBuffer(streamSize, buffer);
            acd.StartDecoder();
            exp_k = acd.ExpGolombDecode(0, bModel0, bModel1);
            M = acd.ExpGolombDecode(0, bModel0, bModel1);
        }
        mModelValues = new module.AdaptiveDataModel();
        mModelValues.SetAlphabet(M + 2);
        if (this.m_maxNumVectors < size) {
            this.m_maxNumVectors = size;
            this.m_quantVectors = new Int32Array(this.m_maxNumVectors);
        }
        quantVectors = this.m_quantVectors;
        if (streamType === local.O3DGC_STREAM_TYPE_ASCII) {
            for (v = 0; v < num; ++v) {
                for (d = 0; d < dim; ++d) {
                    quantVectors[d * num + v] = bstream.ReadIntASCII(iterator);
                }
            }
        } else {
            for (v = 0; v < num; ++v) {
                for (d = 0; d < dim; ++d) {
                    quantVectors[d * num + v] = acd.DecodeIntACEGC(mModelValues, bModel0, bModel1, exp_k, M);
                }
            }
        }
        for (d = 0; d < dim; ++d) {
            this.ITransform(quantVectors, d * num, num);
        }
        this.IQuantize(dynamicVector.GetVectors(), num, dim,
                       dynamicVector.GetStride(), dynamicVector.GetMinArray(),
                       dynamicVector.GetMaxArray(), this.m_params.GetQuantBits());
        return ret;
    };

    return module;
})();


}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],36:[function(require,module,exports){
(function (process){
if (!process.browser)
	exports.toBuffer = require("./build/Release/" + "openctm");

exports.fromBuffer = require("./lib/from_buffer");


}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./lib/from_buffer":38,"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69}],37:[function(require,module,exports){

var LZMA = require("./lzma");

var CTM = module.exports;

CTM.CompressionMethod = {
  RAW: 0x00574152,
  MG1: 0x0031474d,
  MG2: 0x0032474d
};

CTM.Flags = {
  NORMALS: 0x00000001
};

CTM.File = function(stream){
  this.load(stream);
};

CTM.File.prototype.load = function(stream){
  this.header = new CTM.FileHeader(stream);

  this.body = new CTM.FileBody(this.header);

  this.getReader().read(stream, this.body);
};

CTM.File.prototype.getReader = function(){
  var reader;

  switch(this.header.compressionMethod){
    case CTM.CompressionMethod.RAW:
      reader = new CTM.ReaderRAW();
      break;
    case CTM.CompressionMethod.MG1:
      reader = new CTM.ReaderMG1();
      break;
    case CTM.CompressionMethod.MG2:
      reader = new CTM.ReaderMG2();
      break;
  }

  return reader;
};

CTM.FileHeader = function(stream) {
  var magic = stream.readInt32(); //magic "OCTM"
  if (magic !== 0x4d54434f)
    throw new Error("Not a OpenCTM stream, magic number should be 0x4d54434f ('OCTM')");
  this.fileFormat = stream.readInt32();
  this.compressionMethod = stream.readInt32();
  this.vertexCount = stream.readInt32();
  this.triangleCount = stream.readInt32();
  this.uvMapCount = stream.readInt32();
  this.attrMapCount = stream.readInt32();
  this.flags = stream.readInt32();
  this.comment = stream.readString();
};

CTM.FileHeader.prototype.hasNormals = function(){
  return this.flags & CTM.Flags.NORMALS;
};

CTM.FileBody = function(header){
  var i = header.triangleCount * 3,
      v = header.vertexCount * 3,
      n = header.hasNormals()? header.vertexCount * 3: 0,
      u = header.vertexCount * 2,
      a = header.vertexCount * 4,
      j = 0;

  var data = new ArrayBuffer(
    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);

  this.indices = new Uint32Array(data, 0, i);

  this.vertices = new Float32Array(data, i * 4, v);

  if ( header.hasNormals() ){
    this.normals = new Float32Array(data, (i + v) * 4, n);
  }

  if (header.uvMapCount){
    this.uvMaps = [];
    for (j = 0; j < header.uvMapCount; ++ j){
      this.uvMaps[j] = {uv: new Float32Array(data,
        (i + v + n + (j * u) ) * 4, u) };
    }
  }

  if (header.attrMapCount){
    this.attrMaps = [];
    for (j = 0; j < header.attrMapCount; ++ j){
      this.attrMaps[j] = {attr: new Float32Array(data,
        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a) };
    }
  }
};

CTM.FileMG2Header = function(stream){
  stream.readInt32(); //magic "MG2H"
  this.vertexPrecision = stream.readFloat32();
  this.normalPrecision = stream.readFloat32();
  this.lowerBoundx = stream.readFloat32();
  this.lowerBoundy = stream.readFloat32();
  this.lowerBoundz = stream.readFloat32();
  this.higherBoundx = stream.readFloat32();
  this.higherBoundy = stream.readFloat32();
  this.higherBoundz = stream.readFloat32();
  this.divx = stream.readInt32();
  this.divy = stream.readInt32();
  this.divz = stream.readInt32();

  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;
  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;
  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;
};

CTM.ReaderRAW = function(){
};

CTM.ReaderRAW.prototype.read = function(stream, body){
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);

  if (body.normals){
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderRAW.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readArrayInt32(indices);
};

CTM.ReaderRAW.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readArrayFloat32(vertices);
};

CTM.ReaderRAW.prototype.readNormals = function(stream, normals){
  stream.readInt32(); //magic "NORM"
  stream.readArrayFloat32(normals);
};

CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();
    stream.readArrayFloat32(uvMaps[i].uv);
  }
};

CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();
    stream.readArrayFloat32(attrMaps[i].attr);
  }
};

CTM.ReaderMG1 = function(){
};

CTM.ReaderMG1.prototype.read = function(stream, body){
  this.readIndices(stream, body.indices);
  this.readVertices(stream, body.vertices);

  if (body.normals){
    this.readNormals(stream, body.normals);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG1.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG1.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(vertices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readNormals = function(stream, normals){
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
};

CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();

    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();

    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);
  }
};

CTM.ReaderMG2 = function(){
};

CTM.ReaderMG2.prototype.read = function(stream, body){
  this.MG2Header = new CTM.FileMG2Header(stream);

  this.readVertices(stream, body.vertices);
  this.readIndices(stream, body.indices);

  if (body.normals){
    this.readNormals(stream, body);
  }
  if (body.uvMaps){
    this.readUVMaps(stream, body.uvMaps);
  }
  if (body.attrMaps){
    this.readAttrMaps(stream, body.attrMaps);
  }
};

CTM.ReaderMG2.prototype.readVertices = function(stream, vertices){
  stream.readInt32(); //magic "VERT"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(vertices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  var gridIndices = this.readGridIndices(stream, vertices);

  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);
};

CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){
  stream.readInt32(); //magic "GIDX"
  stream.readInt32(); //packed size

  var gridIndices = new Uint32Array(vertices.length / 3);

  var interleaved = new CTM.InterleavedStream(gridIndices, 1);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreGridIndices(gridIndices, gridIndices.length);

  return gridIndices;
};

CTM.ReaderMG2.prototype.readIndices = function(stream, indices){
  stream.readInt32(); //magic "INDX"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(indices, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  CTM.restoreIndices(indices, indices.length);
};

CTM.ReaderMG2.prototype.readNormals = function(stream, body){
  stream.readInt32(); //magic "NORM"
  stream.readInt32(); //packed size

  var interleaved = new CTM.InterleavedStream(body.normals, 3);
  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);

  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);
};

CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){
  var i = 0;
  for (; i < uvMaps.length; ++ i){
    stream.readInt32(); //magic "TEXC"

    uvMaps[i].name = stream.readString();
    uvMaps[i].filename = stream.readString();

    var precision = stream.readFloat32();

    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

    CTM.restoreMap(uvMaps[i].uv, 2, precision);
  }
};

CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){
  var i = 0;
  for (; i < attrMaps.length; ++ i){
    stream.readInt32(); //magic "ATTR"

    attrMaps[i].name = stream.readString();

    var precision = stream.readFloat32();

    stream.readInt32(); //packed size

    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);
    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);

    CTM.restoreMap(attrMaps[i].attr, 4, precision);
  }
};

CTM.restoreIndices = function(indices, len){
  var i = 3;
  if (len > 0){
    indices[2] += indices[0];
  }
  for (; i < len; i += 3){
    indices[i] += indices[i - 3];

    if (indices[i] === indices[i - 3]){
      indices[i + 1] += indices[i - 2];
    }else{
      indices[i + 1] += indices[i];
    }

    indices[i + 2] += indices[i];
  }
};

CTM.restoreGridIndices = function(gridIndices, len){
  var i = 1;
  for (; i < len; ++ i){
    gridIndices[i] += gridIndices[i - 1];
  }
};

CTM.restoreVertices = function(vertices, grid, gridIndices, precision){
  var gridIdx, delta, x, y, z,
      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),
      ydiv = grid.divx, zdiv = ydiv * grid.divy,
      prevGridIdx = 0x7fffffff, prevDelta = 0,
      i = 0, j = 0, len = gridIndices.length;

  for (; i < len; j += 3){
    x = gridIdx = gridIndices[i ++];

    z = ~~(x / zdiv);
    x -= ~~(z * zdiv);
    y = ~~(x / ydiv);
    x -= ~~(y * ydiv);

    delta = intVertices[j];
    if (gridIdx === prevGridIdx){
      delta += prevDelta;
    }

    vertices[j]     = grid.lowerBoundx +
      x * grid.sizex + precision * delta;
    vertices[j + 1] = grid.lowerBoundy +
      y * grid.sizey + precision * intVertices[j + 1];
    vertices[j + 2] = grid.lowerBoundz +
      z * grid.sizez + precision * intVertices[j + 2];

    prevGridIdx = gridIdx;
    prevDelta = delta;
  }
};

CTM.restoreNormals = function(normals, smooth, precision){
  var ro, phi, theta, sinPhi,
      nx, ny, nz, by, bz, len,
      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),
      i = 0, k = normals.length,
      PI_DIV_2 = 3.141592653589793238462643 * 0.5;

  for (; i < k; i += 3){
    ro = intNormals[i] * precision;
    phi = intNormals[i + 1];

    if (phi === 0){
      normals[i]     = smooth[i]     * ro;
      normals[i + 1] = smooth[i + 1] * ro;
      normals[i + 2] = smooth[i + 2] * ro;
    }else{

      if (phi <= 4){
        theta = (intNormals[i + 2] - 2) * PI_DIV_2;
      }else{
        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;
      }

      phi *= precision * PI_DIV_2;
      sinPhi = ro * Math.sin(phi);

      nx = sinPhi * Math.cos(theta);
      ny = sinPhi * Math.sin(theta);
      nz = ro * Math.cos(phi);

      bz = smooth[i + 1];
      by = smooth[i] - smooth[i + 2];

      len = Math.sqrt(2 * bz * bz + by * by);
      if (len > 1e-20){
        by /= len;
        bz /= len;
      }

      normals[i]     = smooth[i]     * nz +
        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;
      normals[i + 1] = smooth[i + 1] * nz -
        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;
      normals[i + 2] = smooth[i + 2] * nz +
        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;
    }
  }
};

CTM.restoreMap = function(map, count, precision){
  var delta, value,
      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),
      i = 0, j, len = map.length;

  for (; i < count; ++ i){
    delta = 0;

    for (j = i; j < len; j += count){
      value = intMap[j];

      delta += value & 1? -( (value + 1) >> 1): value >> 1;

      map[j] = delta * precision;
    }
  }
};

CTM.calcSmoothNormals = function(indices, vertices){
  var smooth = new Float32Array(vertices.length),
      indx, indy, indz, nx, ny, nz,
      v1x, v1y, v1z, v2x, v2y, v2z, len,
      i, k;

  for (i = 0, k = indices.length; i < k;){
    indx = indices[i ++] * 3;
    indy = indices[i ++] * 3;
    indz = indices[i ++] * 3;

    v1x = vertices[indy]     - vertices[indx];
    v2x = vertices[indz]     - vertices[indx];
    v1y = vertices[indy + 1] - vertices[indx + 1];
    v2y = vertices[indz + 1] - vertices[indx + 1];
    v1z = vertices[indy + 2] - vertices[indx + 2];
    v2z = vertices[indz + 2] - vertices[indx + 2];

    nx = v1y * v2z - v1z * v2y;
    ny = v1z * v2x - v1x * v2z;
    nz = v1x * v2y - v1y * v2x;

    len = Math.sqrt(nx * nx + ny * ny + nz * nz);
    if (len > 1e-10){
      nx /= len;
      ny /= len;
      nz /= len;
    }

    smooth[indx]     += nx;
    smooth[indx + 1] += ny;
    smooth[indx + 2] += nz;
    smooth[indy]     += nx;
    smooth[indy + 1] += ny;
    smooth[indy + 2] += nz;
    smooth[indz]     += nx;
    smooth[indz + 1] += ny;
    smooth[indz + 2] += nz;
  }

  for (i = 0, k = smooth.length; i < k; i += 3){
    len = Math.sqrt(smooth[i] * smooth[i] +
      smooth[i + 1] * smooth[i + 1] +
      smooth[i + 2] * smooth[i + 2]);

    if(len > 1e-10){
      smooth[i]     /= len;
      smooth[i + 1] /= len;
      smooth[i + 2] /= len;
    }
  }

  return smooth;
};

CTM.isLittleEndian = (function(){
  var buffer = new ArrayBuffer(2),
      bytes = new Uint8Array(buffer),
      ints = new Uint16Array(buffer);

  bytes[0] = 1;

  return ints[0] === 1;
}());

CTM.InterleavedStream = function(data, count){
  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  this.offset = CTM.isLittleEndian? 3: 0;
  this.count = count * 4;
  this.len = this.data.length;
};

CTM.InterleavedStream.prototype.writeByte = function(value){
  this.data[this.offset] = value;

  this.offset += this.count;
  if (this.offset >= this.len){

    this.offset -= this.len - 4;
    if (this.offset >= this.count){

      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);
    }
  }
};

CTM.Stream = function(data){
  if (data instanceof ArrayBuffer) {
      this.data = new Uint8Array(data);
  } else {
      this.data = data;
  }
  this.offset = 0;
};

CTM.Stream.prototype.getPosition = function() {
    return this.offset;
};

CTM.Stream.prototype.setPosition = function(offset) {
    this.offset = offset;
};

CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);

CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);

CTM.Stream.prototype.readByte = function() {
    if (this.data instanceof Uint8Array) {
        return this.data[this.offset ++];
    } else {
        return this.data.charCodeAt(this.offset ++) & 0xff;
    }
};

CTM.Stream.prototype.readInt32 = function(){
  var i = this.readByte();
  i |= this.readByte() << 8;
  i |= this.readByte() << 16;
  return i | (this.readByte() << 24);
};

CTM.Stream.prototype.readFloat32 = function(){
  var m = this.readByte();
  m += this.readByte() << 8;

  var b1 = this.readByte();
  var b2 = this.readByte();

  m += (b1 & 0x7f) << 16;
  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);
  var s = b2 & 0x80? -1: 1;

  if (e === 255){
    return m !== 0? NaN: s * Infinity;
  }
  if (e > 0){
    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);
  }
  if (m !== 0){
    return s * m * this.TWO_POW_MINUS126;
  }
  return s * 0;
};

CTM.Stream.prototype.readString = function(){
  var len = this.readInt32();

  this.offset += len;
  if (this.data instanceof Uint8Array) {
      var pos = this.offset - len;
      var buf = "";
      for (var i = pos; i < pos+len; ++i) {
          buf += String.fromCharCode(this.data[i]);
      }
      return buf;
  } else {
      return this.data.substr(this.offset - len, len);
  }
};

CTM.Stream.prototype.readArrayInt32 = function(array){
  var i = 0, len = array.length;

  while(i < len){
    array[i ++] = this.readInt32();
  }

  return array;
};

CTM.Stream.prototype.readArrayFloat32 = function(array){
  var i = 0, len = array.length;

  while(i < len){
    array[i ++] = this.readFloat32();
  }

  return array;
};

},{"./lzma":39}],38:[function(require,module,exports){
"use strict";

var CTM = require("./ctm");

exports = module.exports = function (data) {
	try {
		var stream = new CTM.Stream(data);
		var file = new CTM.File(stream);
	} catch (_) {
		throw new Error("Failed to process OpenCTM file.");
	}

	var index = new Int32Array(file.body.indices.buffer, file.body.indices.byteOffset, file.body.indices.length);
	var position = file.body.vertices;
	var normal  = file.body.normals;
	var texcoord = file.body.uvMaps ? file.body.uvMaps[0].uv : undefined;
	var tangent = extractAttribute(file, "tangent");
	var color = extractAttribute(file, "color");
	return {
		index: index ,
		position: position,
		normal: normal,
		texcoord: texcoord,
		tangent: tangent ? removeFourBytePadding(tangent) : undefined,
		color: color
	};
}

function extractAttribute(file, attributeName) {
	if (!file.body.attrMaps)
		return;

	for (var idx = 0; idx < file.body.attrMaps.length; ++idx)
		if (file.body.attrMaps[idx].name === attributeName)
			return file.body.attrMaps[idx].attr;
}

function removeFourBytePadding(paddedData) {
	var dataWithoutPadding = new paddedData.constructor(paddedData.length / 4 * 3);
	for (var paddedIdx = 0, idx = 0; paddedIdx < paddedData.length; paddedIdx += 4, idx += 3) {
		dataWithoutPadding[idx] = paddedData[paddedIdx];
		dataWithoutPadding[idx + 1] = paddedData[paddedIdx + 1];
		dataWithoutPadding[idx + 2] = paddedData[paddedIdx + 2];
	}

	return dataWithoutPadding;
}

},{"./ctm":37}],39:[function(require,module,exports){

var LZMA = module.exports;

LZMA.OutWindow = function(){
  this._windowSize = 0;
};

LZMA.OutWindow.prototype.create = function(windowSize){
  if ( (!this._buffer) || (this._windowSize !== windowSize) ){
    this._buffer = [];
  }
  this._windowSize = windowSize;
  this._pos = 0;
  this._streamPos = 0;
};

LZMA.OutWindow.prototype.flush = function(){
  var size = this._pos - this._streamPos;
  if (size !== 0){
    while(size --){
      this._stream.writeByte(this._buffer[this._streamPos ++]);
    }
    if (this._pos >= this._windowSize){
      this._pos = 0;
    }
    this._streamPos = this._pos;
  }
};

LZMA.OutWindow.prototype.releaseStream = function(){
  this.flush();
  this._stream = null;
};

LZMA.OutWindow.prototype.setStream = function(stream){
  this.releaseStream();
  this._stream = stream;
};

LZMA.OutWindow.prototype.init = function(solid){
  if (!solid){
    this._streamPos = 0;
    this._pos = 0;
  }
};

LZMA.OutWindow.prototype.copyBlock = function(distance, len){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  while(len --){
    if (pos >= this._windowSize){
      pos = 0;
    }
    this._buffer[this._pos ++] = this._buffer[pos ++];
    if (this._pos >= this._windowSize){
      this.flush();
    }
  }
};

LZMA.OutWindow.prototype.putByte = function(b){
  this._buffer[this._pos ++] = b;
  if (this._pos >= this._windowSize){
    this.flush();
  }
};

LZMA.OutWindow.prototype.getByte = function(distance){
  var pos = this._pos - distance - 1;
  if (pos < 0){
    pos += this._windowSize;
  }
  return this._buffer[pos];
};

LZMA.RangeDecoder = function(){
};

LZMA.RangeDecoder.prototype.setStream = function(stream){
  this._stream = stream;
};

LZMA.RangeDecoder.prototype.releaseStream = function(){
  this._stream = null;
};

LZMA.RangeDecoder.prototype.init = function(){
  var i = 5;

  this._code = 0;
  this._range = -1;

  while(i --){
    this._code = (this._code << 8) | this._stream.readByte();
  }
};

LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){
  var result = 0, i = numTotalBits, t;

  while(i --){
    this._range >>>= 1;
    t = (this._code - this._range) >>> 31;
    this._code -= this._range & (t - 1);
    result = (result << 1) | (1 - t);

    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
  }

  return result;
};

LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){
  var prob = probs[index],
      newBound = (this._range >>> 11) * prob;

  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){
    this._range = newBound;
    probs[index] += (2048 - prob) >>> 5;
    if ( (this._range & 0xff000000) === 0){
      this._code = (this._code << 8) | this._stream.readByte();
      this._range <<= 8;
    }
    return 0;
  }

  this._range -= newBound;
  this._code -= newBound;
  probs[index] -= prob >>> 5;
  if ( (this._range & 0xff000000) === 0){
    this._code = (this._code << 8) | this._stream.readByte();
    this._range <<= 8;
  }
  return 1;
};

LZMA.initBitModels = function(probs, len){
  while(len --){
    probs[len] = 1024;
  }
};

LZMA.BitTreeDecoder = function(numBitLevels){
  this._models = [];
  this._numBitLevels = numBitLevels;
};

LZMA.BitTreeDecoder.prototype.init = function(){
  LZMA.initBitModels(this._models, 1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){
  var m = 1, i = this._numBitLevels;

  while(i --){
    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);
  }
  return m - (1 << this._numBitLevels);
};

LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < this._numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(this._models, m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){
  var m = 1, symbol = 0, i = 0, bit;

  for (; i < numBitLevels; ++ i){
    bit = rangeDecoder.decodeBit(models, startIndex + m);
    m = (m << 1) | bit;
    symbol |= bit << i;
  }
  return symbol;
};

LZMA.LenDecoder = function(){
  this._choice = [];
  this._lowCoder = [];
  this._midCoder = [];
  this._highCoder = new LZMA.BitTreeDecoder(8);
  this._numPosStates = 0;
};

LZMA.LenDecoder.prototype.create = function(numPosStates){
  for (; this._numPosStates < numPosStates; ++ this._numPosStates){
    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);
  }
};

LZMA.LenDecoder.prototype.init = function(){
  var i = this._numPosStates;
  LZMA.initBitModels(this._choice, 2);
  while(i --){
    this._lowCoder[i].init();
    this._midCoder[i].init();
  }
  this._highCoder.init();
};

LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){
  if (rangeDecoder.decodeBit(this._choice, 0) === 0){
    return this._lowCoder[posState].decode(rangeDecoder);
  }
  if (rangeDecoder.decodeBit(this._choice, 1) === 0){
    return 8 + this._midCoder[posState].decode(rangeDecoder);
  }
  return 16 + this._highCoder.decode(rangeDecoder);
};

LZMA.Decoder2 = function(){
  this._decoders = [];
};

LZMA.Decoder2.prototype.init = function(){
  LZMA.initBitModels(this._decoders, 0x300);
};

LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){
  var symbol = 1;

  do{
    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){
  var symbol = 1, matchBit, bit;

  do{
    matchBit = (matchByte >> 7) & 1;
    matchByte <<= 1;
    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);
    symbol = (symbol << 1) | bit;
    if (matchBit !== bit){
      while(symbol < 0x100){
        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);
      }
      break;
    }
  }while(symbol < 0x100);

  return symbol & 0xff;
};

LZMA.LiteralDecoder = function(){
};

LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){
  var i;

  if (this._coders
    && (this._numPrevBits === numPrevBits)
    && (this._numPosBits === numPosBits) ){
    return;
  }
  this._numPosBits = numPosBits;
  this._posMask = (1 << numPosBits) - 1;
  this._numPrevBits = numPrevBits;

  this._coders = [];

  i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i] = new LZMA.Decoder2();
  }
};

LZMA.LiteralDecoder.prototype.init = function(){
  var i = 1 << (this._numPrevBits + this._numPosBits);
  while(i --){
    this._coders[i].init();
  }
};

LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){
  return this._coders[( (pos & this._posMask) << this._numPrevBits)
    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];
};

LZMA.Decoder = function(){
  this._outWindow = new LZMA.OutWindow();
  this._rangeDecoder = new LZMA.RangeDecoder();
  this._isMatchDecoders = [];
  this._isRepDecoders = [];
  this._isRepG0Decoders = [];
  this._isRepG1Decoders = [];
  this._isRepG2Decoders = [];
  this._isRep0LongDecoders = [];
  this._posSlotDecoder = [];
  this._posDecoders = [];
  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);
  this._lenDecoder = new LZMA.LenDecoder();
  this._repLenDecoder = new LZMA.LenDecoder();
  this._literalDecoder = new LZMA.LiteralDecoder();
  this._dictionarySize = -1;
  this._dictionarySizeCheck = -1;

  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);
  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);
};

LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){
  if (dictionarySize < 0){
    return false;
  }
  if (this._dictionarySize !== dictionarySize){
    this._dictionarySize = dictionarySize;
    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);
    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );
  }
  return true;
};

LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){
  var numPosStates = 1 << pb;

  if (lc > 8 || lp > 4 || pb > 4){
    return false;
  }

  this._literalDecoder.create(lp, lc);

  this._lenDecoder.create(numPosStates);
  this._repLenDecoder.create(numPosStates);
  this._posStateMask = numPosStates - 1;

  return true;
};

LZMA.Decoder.prototype.init = function(){
  var i = 4;

  this._outWindow.init(false);

  LZMA.initBitModels(this._isMatchDecoders, 192);
  LZMA.initBitModels(this._isRep0LongDecoders, 192);
  LZMA.initBitModels(this._isRepDecoders, 12);
  LZMA.initBitModels(this._isRepG0Decoders, 12);
  LZMA.initBitModels(this._isRepG1Decoders, 12);
  LZMA.initBitModels(this._isRepG2Decoders, 12);
  LZMA.initBitModels(this._posDecoders, 114);

  this._literalDecoder.init();

  while(i --){
    this._posSlotDecoder[i].init();
  }

  this._lenDecoder.init();
  this._repLenDecoder.init();
  this._posAlignDecoder.init();
  this._rangeDecoder.init();
};

LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){
  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,
      posState, decoder2, len, distance, posSlot, numDirectBits;

  this._rangeDecoder.setStream(inStream);
  this._outWindow.setStream(outStream);

  this.init();

  while(outSize < 0 || nowPos64 < outSize){
    posState = nowPos64 & this._posStateMask;

    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){
      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);

      if (state >= 7){
        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );
      }else{
        prevByte = decoder2.decodeNormal(this._rangeDecoder);
      }
      this._outWindow.putByte(prevByte);

      state = state < 4? 0: state - (state < 10? 3: 6);

    }else{

      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){
        len = 0;
        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){
          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){
            state = state < 7? 9: 11;
            len = 1;
          }
        }else{
          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){
            distance = rep1;
          }else{
            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){
              distance = rep2;
            }else{
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        if (len === 0){
          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);
          state = state < 7? 8: 11;
        }
      }else{
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;

        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);
        state = state < 7? 7: 10;

        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);
        if (posSlot >= 4){

          numDirectBits = (posSlot >> 1) - 1;
          rep0 = (2 | (posSlot & 1) ) << numDirectBits;

          if (posSlot < 14){
            rep0 += LZMA.reverseDecode2(this._posDecoders,
                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);
          }else{
            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;
            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);
            if (rep0 < 0){
              if (rep0 === -1){
                break;
              }
              return false;
            }
          }
        }else{
          rep0 = posSlot;
        }
      }

      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){
        return false;
      }

      this._outWindow.copyBlock(rep0, len);
      nowPos64 += len;
      prevByte = this._outWindow.getByte(0);
    }
  }

  this._outWindow.flush();
  this._outWindow.releaseStream();
  this._rangeDecoder.releaseStream();

  return true;
};

LZMA.Decoder.prototype.setDecoderProperties = function(properties){
  var value, lc, lp, pb, dictionarySize;

  if (properties.size < 5){
    return false;
  }

  value = properties.readByte();
  lc = value % 9;
  value = ~~(value / 9);
  lp = value % 5;
  pb = ~~(value / 5);

  if ( !this.setLcLpPb(lc, lp, pb) ){
    return false;
  }

  dictionarySize = properties.readByte();
  dictionarySize |= properties.readByte() << 8;
  dictionarySize |= properties.readByte() << 16;
  dictionarySize += properties.readByte() * 16777216;

  return this.setDictionarySize(dictionarySize);
};

LZMA.decompress = function(properties, inStream, outStream, outSize){
  var decoder = new LZMA.Decoder();

  if ( !decoder.setDecoderProperties(properties) ){
    throw "Incorrect stream properties";
  }

  if ( !decoder.decode(inStream, outStream, outSize) ){
    throw "Error in data stream";
  }

  return true;
};

},{}],40:[function(require,module,exports){
"use strict";

var tokenize = require("./lexing");
var parse = require("./parsing");

var JPathInvalidEscapeSequenceError = require("./invalid_escape_sequence_error");
var JPathParsingError = require("./parsing_error");
var JPathSyntaxError = require("./syntax_error");

function highlightErroneousPart(expression, startIdx, endIdx) {
    var before = expression.substring(0, startIdx);
    var erroneousPart = expression.substring(startIdx, endIdx);
    var after = expression.substring(endIdx);
    return before + ">" + erroneousPart + "<" + after;
}

function compile(pathExpression) {
    try {
        return parse(tokenize(pathExpression));
    } catch (e) {
        if (e instanceof JPathInvalidEscapeSequenceError) {
            var startIdx = pathExpression.indexOf(e.invalidSequence);
            var endIdx = startIdx + e.invalidSequence.length;
            throw new JPathSyntaxError({
                reason: JPathSyntaxError.reasons.invalidEscapeSequence,
                startIdx: startIdx,
                endIdx: endIdx,
                actual: e.invalidSequence,
                expected: e.expected,
                message: "Invalid escape sequence: " + highlightErroneousPart(pathExpression, startIdx, endIdx) + "! Got: " + e.invalidSequence + ", expected: " + e.expected.join(" or ")
            });
        }
        if (e instanceof JPathParsingError) {
            var message = "";
            switch (e.reason) {
                case JPathParsingError.reasons.missingClosingBracket:
                    message = "Missing closing bracket: " + highlightErroneousPart(pathExpression, e.startIdx, e.endIdx);
                    break;
                case JPathParsingError.reasons.unmatchedClosingBracket:
                    message = "Missing opening bracket: " + highlightErroneousPart(pathExpression, e.startIdx, e.endIdx);
                    break;
                case JPathParsingError.reasons.missingClosingParentheses:
                    message = "Missing closing parentheses: " + highlightErroneousPart(pathExpression, e.startIdx, e.endIdx);
                    break;
                case JPathParsingError.reasons.unmatchedClosingParentheses:
                    message = "Missing opening parentheses: " + highlightErroneousPart(pathExpression, e.startIdx, e.endIdx);
                    break;
                case JPathParsingError.reasons.unexpectedToken:
                    message = "Unexpected Token: " + highlightErroneousPart(pathExpression, e.startIdx, e.endIdx);
                    break;
                case JPathParsingError.reasons.invalidExpression:
                    message = "Invalid expression: " + highlightErroneousPart(pathExpression, e.startIdx, e.endIdx);
                    break;
            }
            throw new JPathSyntaxError({
                reason: e.reason,
                startIdx: e.startIdx,
                endIdx: e.endIdx,
                actual: e.invalidSequence,
                expected: e.expected,
                message: message
            });
        }
        throw e;
    }
}

exports = module.exports = compile;

},{"./invalid_escape_sequence_error":50,"./lexing":52,"./parsing":53,"./parsing_error":54,"./syntax_error":60}],41:[function(require,module,exports){
"use strict";

var EvaluationResult = require("./evaluation_result");

function ConstantValueExpression(value) {
	this._value = [new EvaluationResult(value)];
}

ConstantValueExpression.prototype.evaluate = function (_) {
    return this._value;
};

exports = module.exports = ConstantValueExpression;

},{"./evaluation_result":48}],42:[function(require,module,exports){
"use strict";

var EvaluationResult = require("./evaluation_result");

function Context(root, current) {
	this._root = root;
	this._current = current ? current : [new EvaluationResult(this._root)];
}

Object.defineProperties(Context.prototype, {
	root: {
		get: function () {
			return this._root;
		}
	},
	current: {
		get: function () {
			return this._current;
		}
	}
});

exports = module.exports = Context;


},{"./evaluation_result":48}],43:[function(require,module,exports){
"use strict";

var evaluate = require("./evaluation");

exports = module.exports = function (path, object) {
    var coverageObject = {}; //createCoverageObject(object);

    var rootObjectMatched = false;
    var definedResults = evaluate(path, object).definedResults;
    for (var i = 0; i < definedResults.length; ++i) {
        var result =  definedResults[i];
        if (result.isRoot) {
            rootObjectMatched = true;
            break;
        }
        evaluate(result.path, coverageObject).forEach(function (result) {
            result.value = true;
        });
    }

    if (rootObjectMatched)
        return {};

    return extractUncoveredParts(object, coverageObject);
};

function extractUncoveredParts(object, coverage) {
    var uncovered = {};

    if (object.buffer && object.BYTES_PER_ELEMENT) {
        var coveredIndicesLength = coverage.filter(function (value) {
            return value;
        }).length;
        uncovered = new object.constructor(object.length - coveredIndicesLength);

        for (var idx = 0, uncoveredIdx = 0; idx < object.length; ++idx) {
            if (!coverage[idx])
                uncovered[uncoveredIdx++] = object[idx];
        }
    } else {
        if (Array.isArray(object))
            uncovered= [];

        Object.keys(object).forEach(function (key) {
            if (typeof coverage[key] === "object")
                uncovered[key] = extractUncoveredParts(object[key], coverage[key]);
            else if (!coverage[key])
                uncovered[key] = object[key];
            if ((typeof uncovered[key] === "object" && Object.keys(uncovered[key]).length === 0) || (Array.isArray(uncovered[key]) && uncovered[key].length === 0))
                delete uncovered[key];
        });
    }

    return uncovered;
}


},{"./evaluation":47}],44:[function(require,module,exports){
"use strict";

var EvaluationResult = require("./evaluation_result");

function DescentExpression() {}

DescentExpression.prototype.evaluate = function (context) {
	var x = Array.prototype.concat.apply([], context.current.filter(function (result) {
        return result.isDefined();
    }).map(function (result) {
            var descendants = [];
            Object.keys(result.value).forEach(function (key) {
                descendants.push(new EvaluationResult(result, key));
            });
            return descendants;
	}));
    return x;
};

exports = module.exports = DescentExpression;

},{"./evaluation_result":48}],45:[function(require,module,exports){
(function (process){
// # JPathError

// JPathError represents the base class of the error hierarchy.
// It takes a printable message and a constructor to build a stack trace.
// It inherits from node's generic Error class to allow for catch all handlers.

"use strict";

var util = require("util");

/**
 * Creates a JPathError.
 *
 * @private
 * @constructor
 * @type JPathError
 * @param {string} message Custom error message for logging.
 */
function JPathError(message) {
    Error.call(this);
    if (!process.browser)
        Error.captureStackTrace(this, this.constructor);
    // If no custom error message was defined use a generic one.
    this.message = (message && message.toString()) || "JPath Error";
}

// Inherit the default Error prototype.
util.inherits(JPathError, Error);

// Set a name for the error.
JPathError.prototype.name = "JPath Error";

exports = module.exports = JPathError;

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69,"util":80}],46:[function(require,module,exports){
// # Property name escaping

// In a JPath the characters `/, [, ], :, *` have special meanings, but are valid JSON property names.
// If one wants to access a property that contains such a character they have to be escaped.
// Escape sequences start with a tilde, `~` followed by a number in the range [1, 5].
// The single tilde character is escaped as a double tilde.

"use strict";

var JPathInvalidEscapeSequenceError = require("./invalid_escape_sequence_error");
var separatorTokenMapping = require("./separator_token_mapping");

var escapePrefix = "~";
var characterEscapeSequenceMap = {};
var escapeSequenceCharacterMap = {};
Object.keys(separatorTokenMapping).forEach(function (character) {
	characterEscapeSequenceMap[character] = escapePrefix + separatorTokenMapping[character];
	escapeSequenceCharacterMap[escapePrefix + separatorTokenMapping[character]] = character;
});


/**
 * Escapes the given property name.
 *
 * @param {string} propertyName The property name to escape.
 * @returns {string} The escaped property name.
 */
function escapePropertyName(propertyName) {
    // We iterate over the escape sequence table and replace every reserved character by its escape sequence.
    // It is important that a tilde is escaped first!
    // "~[" should be mapped to "~~~2".
    // If we would decode "~ ~" last, this would be decoded into "~~2" then into "~~~~2",
    // because of the global regex based replace.
    // We have to wrap the reservedCharacter into brackets to escape non valid regular expression characters.
    // We also have use a double backslash because of the `]` character.
	var escapedPropertyName = propertyName.replace(new RegExp(escapePrefix, "g"), escapePrefix + escapePrefix);
	return Object.keys(characterEscapeSequenceMap).reduce(function (propertyName, character) {
		return propertyName.replace(new RegExp("[\\" + character + "]", "g"), characterEscapeSequenceMap[character]);
	}, escapedPropertyName);
}

/**
 * Unescapes a given property name.
 *
 * @public
 * @function unescapePropertyName
 *
 * @param {string} escapedPropertyName The property name to unescape.
 * @returns {string} The unescaped property name.
 * @throws {JPathInvalidEscapeSequenceError} if escapedPropertyName contains an invalid escape sequence,
 * e.g. a tilde followed by a number not in the valid range [1, 5].
 */
function unescapePropertyName(escapedPropertyName) {
    // We iterate over the escapedPropertyName character by character and map every escape sequence back to their original value.
    var unescapedCharacters = [];
    var decodedChar ="";
    var idx = 0;
	var escapeSequences = Object.keys(escapeSequenceCharacterMap);
    while (idx < escapedPropertyName.length) {
        var currentChar = escapedPropertyName[idx];
        if (currentChar === escapePrefix) {
            var nextChar = escapedPropertyName[idx + 1];

            // A single `~` or a `~` followed by a number greater outside the interval [1, Object.keys(characterEscapeSequenceMap).length]
            // can never occur in a well escaped property name.
            var n = parseInt(nextChar, 10);
            if (nextChar !== escapePrefix && (isNaN(n) || !isFinite(n) || n < 0 || n > escapeSequences.length))
                throw new JPathInvalidEscapeSequenceError(escapePrefix + nextChar, escapeSequences);

			if (nextChar === escapePrefix)
				decodedChar = escapePrefix;
			else
				decodedChar = escapeSequenceCharacterMap[escapePrefix + nextChar];

            // Skip by two to not decode ~~1 into ~/.
            idx += 2;
        } else {
            decodedChar = currentChar;
            ++idx;
        }
        unescapedCharacters.push(decodedChar);
    }

    return unescapedCharacters.join("");
}

exports.escapePropertyName = escapePropertyName;
exports.unescapePropertyName = unescapePropertyName;

},{"./invalid_escape_sequence_error":50,"./separator_token_mapping":59}],47:[function(require,module,exports){
"use strict";

var compile = require("./compiling");
var Context = require("./context");

exports = module.exports = function (path, object) {
	var pathExpression = compile(path);
    return augmentArray(pathExpression.evaluate(new Context(object)));
};

function augmentArray(array) {
    Object.defineProperties(array, {
        definedResults: {
            get: function () {
                return this.filter(function (result) {
                    return result.isDefined();
                });
            }
        },
        values: {
            get: function () {
                return this.definedResults.map(function (result) {
                    return result.value;
                });
            }
        },
        paths: {
            get: function () {
                return this.definedResults.map(function (result) {
                    return result.path;
                });
            }
        }
    });
    return array;
}

},{"./compiling":40,"./context":42}],48:[function(require,module,exports){
"use strict";

var join = require("./joining");

function EvaluationResult(parent, propertyName, isArrayAccess) {
    if (!(parent instanceof EvaluationResult)) {
        Object.defineProperty(this, "value", {
            value: parent,
            writable: true
        });
        Object.defineProperty(this, "isRoot", {
            value: true
        });
        this._parent = null;
    } else {
        this._parent = parent;
    }

	this._propertyName = typeof propertyName !== "undefined" ? propertyName : "";
    this._isArrayAccess = isArrayAccess;
}

Object.defineProperties(EvaluationResult.prototype, {
	value: {
		get: function () {
            if (typeof this._parent.value !== "undefined")
                return this._parent.value[this._propertyName];
            else
                return undefined;
		},
		set: function (value) {
            if (!this._parent.value)
                this._parent.value = this._isArrayAccess ? [] : {};
			this._parent.value[this._propertyName] = value;
		}
	},
    path: {
        get: function() {
            if (this._parent)
                return join(this._parent.path, this._propertyName, this._isArrayAccess);
            else
                return this._propertyName;
        }
    }
});

EvaluationResult.prototype.isDefined = function () {
	return typeof this.value !== "undefined";
};

exports = module.exports = EvaluationResult;

},{"./joining":51}],49:[function(require,module,exports){
"use strict";

var escaping = require("./escaping");
exports.escapePropertyName = escaping.escapePropertyName;
exports.unescapePropertyName = escaping.unescapePropertyName;
exports.InvalidEscapeSequenceError = require("./invalid_escape_sequence_error");
exports.separtorTokenMapping = require("./separator_token_mapping");

exports.Token = require("./token");
exports.tokenize = require("./lexing");
exports.join = require("./joining");

exports.parse = require("./parsing");
exports.ParsingError = require("./parsing_error");

exports.ConstantValueExpression = require("./constant_value_expression");
exports.PropertyAccessExpression = require("./property_access_expression");
exports.RangeExpression = require("./range_expression");
exports.DescentExpression = require("./descent_expression");
exports.RecursiveDescentExpression = require("./recursive_descent_expression");
exports.PathExpression = require("./path_expression");

exports.evaluate = require("./evaluation");

exports.extractUncoveredParts = require("./coverage");

},{"./constant_value_expression":41,"./coverage":43,"./descent_expression":44,"./escaping":46,"./evaluation":47,"./invalid_escape_sequence_error":50,"./joining":51,"./lexing":52,"./parsing":53,"./parsing_error":54,"./path_expression":55,"./property_access_expression":56,"./range_expression":57,"./recursive_descent_expression":58,"./separator_token_mapping":59,"./token":61}],50:[function(require,module,exports){
// # InvalidEscapeSequenceError

// This class is only used internally.
// It is the error that is thrown by the `unescape` function, if an invalid escape sequence is found.
// It should be catched an rethrown as a syntax errors to carry more information.

"use strict";

var util = require("util");

var JPathError = require("./error");

/**
 * Constructs an InvalidEscapeSequenceError.
 *
 * @param {string} invalidSequence The sequence that is invalid
 * @param {number} startIdx The start index of the invalid sequence inside the string.
 * @constructor
 */
function InvalidEscapeSequenceError(invalidSequence, expected) {
    JPathError.call(this, "Invalid escape sequence found: " + invalidSequence);
    this.invalidSequence = invalidSequence;
    this.expected = expected;
}

exports = module.exports = InvalidEscapeSequenceError;

util.inherits(InvalidEscapeSequenceError, JPathError);

InvalidEscapeSequenceError.prototype.name = "InvalidEscapeSequenceError";

},{"./error":45,"util":80}],51:[function(require,module,exports){
"use strict";

var path = require("path");

exports = module.exports = function (parent, child, isArrayIndex) {
    if (isArrayIndex)
        child = "[" + child + "]";

    return path.join(parent, child);
};

},{"path":70}],52:[function(require,module,exports){
"use strict";

var unescapePropertyName = require("./escaping").unescapePropertyName;
var InvalidEscapeSequenceError = require("./invalid_escape_sequence_error");
var JPathSyntaxError = require("./syntax_error");
var Token = require("./token");
var separatorTokenMapping = require("./separator_token_mapping");

// Tokenizes the given pathExpression returning an array of tokens representing the token stream.
function tokenize(pathExpression) {
    if (pathExpression.length === 0)
        pathExpression = "/";

    var tokenStream = [];
    var currentCharIdx = 0;
    while (currentCharIdx < pathExpression.length){
        var currentChar = pathExpression[currentCharIdx];
		if (isTokenSeparationCharacter(currentChar)) {
			tokenStream.push(new Token(tokenForSeparationCharacter(currentChar), currentCharIdx, currentCharIdx + 1, currentChar));
			++currentCharIdx;
		} else {
			// literal
			// Read 'till first special character
			var literal = "";
			var literalStartIdx = currentCharIdx;
			do {
				literal += currentChar;
				++currentCharIdx;
				currentChar = pathExpression[currentCharIdx];
			} while (currentCharIdx < pathExpression.length && !isTokenSeparationCharacter(currentChar));

			tokenStream.push(new Token(Token.types.literal, literalStartIdx, currentCharIdx, unescapePropertyName(literal)));
        }
    }

    tokenStream.push(new Token(Token.types.eot, currentCharIdx, currentCharIdx));
    return tokenStream;
}

var tokenSeparationCharacters = Object.keys(separatorTokenMapping);

function isTokenSeparationCharacter(char) {
	return tokenSeparationCharacters.indexOf(char) !== -1;
}

function tokenForSeparationCharacter(char) {
	return separatorTokenMapping[char];
}

exports = module.exports = tokenize;

},{"./escaping":46,"./invalid_escape_sequence_error":50,"./separator_token_mapping":59,"./syntax_error":60,"./token":61}],53:[function(require,module,exports){
// # Parsing

"use strict";

var Token = require("./token");
var JPathParsingError = require("./parsing_error");

var ConstantValueExpression = require("./constant_value_expression");
var PropertyAccessExpression = require("./property_access_expression");
var PathExpression = require("./path_expression");
var RangeExpression = require("./range_expression");
var DescentExpression = require("./descent_expression");
var RecursiveDescentExpression = require("./recursive_descent_expression");

/**
 * Parses the given token stream.
 *
 * @public
 * @function parse
 *
 * @param {Token[]} tokenStream The token stream that should be parsed.
 * @returns {PathExpression} The parsed path expression.
 * @throws {JPathSyntaxError} if the given token stream contains any syntactical errors.
 */
function parse(tokenStream) {
	Object.defineProperty(tokenStream, "front", {
		get: function () {
			return this[0];
		}
	});
    var expression = parsePathExpression(tokenStream);

    if (tokenStream.front.type !== Token.types.eot)
        throw new JPathParsingError(JPathParsingError.reasons.unexpectedToken,
            tokenStream.front.startIdx,
            tokenStream.front.endIdx,
            Token.types.eot);

    return expression;
}

function parsePathExpression(tokenStream) {
	var expressions = [];
	var isAbsolutePath = false;

	// If we have a separator this is a absolute path expression.
	if (tokenStream.front.type === Token.types.separator) {
		isAbsolutePath = true;
		tokenStream.shift();
	}

	do {
		// Consume superfluous separator tokens.
		while (tokenStream.front.type === Token.types.separator)
			tokenStream.shift();

		if (tokenStream.front.type === Token.types.eot)
			break;

		// Parse path components as long as the next token afterwards is a separator.
		expressions.push(parsePathComponent(tokenStream));
	} while (tokenStream.front.type === Token.types.separator);

	return new PathExpression(expressions, isAbsolutePath);
}

function parsePathComponent(tokenStream) {
	if (tokenStream.front.type === Token.types.asterisk)
		return parseDescentExpression(tokenStream);

	if (tokenStream.front.type === Token.types.openBracket)
		return parseArrayAccessExpression(tokenStream);

	return new PropertyAccessExpression(parsePropertyNameExpression(tokenStream));
}

function parseDescentExpression(tokenStream) {
	tokenStream.shift();
	if (tokenStream.front.type !== Token.types.asterisk)
		return new DescentExpression();

	tokenStream.shift();
	return new RecursiveDescentExpression();
}

function parsePropertyNameExpression(tokenStream) {
	var left = parseNameExpression(tokenStream);
	if (tokenStream.front.type === Token.types.colon)
		return parseRangeExpression(left, tokenStream);

	return left;
}

function parseNameExpression(tokenStream) {
	if (tokenStream.front.type === Token.types.literal)
		return parseLiteral(tokenStream);
	else if (tokenStream.front.type === Token.types.openParentheses)
		return parseSubExpression(tokenStream);
	else
		throw new JPathParsingError(JPathParsingError.reasons.unexpectedToken,
			tokenStream.front.startIdx,
			tokenStream.front.endIdx,
			[Token.types.literal, Token.types.openParentheses]);
}

function parseLiteral(tokenStream) {
	return new ConstantValueExpression(tokenStream.shift().value);
}

function parseSubExpression(tokenStream) {
	var openParenthesesToken = tokenStream.shift();

    var expression = parsePathExpression(tokenStream);

	if (tokenStream.front.type !== Token.types.closeParentheses)
		throw new JPathParsingError(JPathParsingError.reasons.missingClosingParentheses,
			openParenthesesToken.startIdx,
			tokenStream.front.startIdx,
			Token.types.closeParentheses);

	tokenStream.shift();
	return expression;
}

function parseRangeExpression(left, tokenStream) {
	tokenStream.shift();
	var right = parseNameExpression(tokenStream);
	return new RangeExpression(left, right);
}

function parseArrayAccessExpression(tokenStream) {
	var openBracketToken = tokenStream.shift();

    var expression = new PropertyAccessExpression(parsePropertyNameExpression(tokenStream), true);

	if (tokenStream.front.type !== Token.types.closeBracket)
		throw new JPathParsingError(JPathParsingError.reasons.missingClosingBracket,
			openBracketToken.startIdx,
			tokenStream.front.startIdx,
			Token.types.closeBracket);

	tokenStream.shift();
	return expression;
}

exports = module.exports = parse;

},{"./constant_value_expression":41,"./descent_expression":44,"./parsing_error":54,"./path_expression":55,"./property_access_expression":56,"./range_expression":57,"./recursive_descent_expression":58,"./token":61}],54:[function(require,module,exports){
// # JPathSyntaxError

// This class represents syntactic errors in a JPath.
// Syntactic errors include unbalanced brackets, invalid escape sequences or invalid expressions in general.
// As all errors it inherits from the general JPath error.
// The reason for the syntax error should be one of the constants defined below.
// The start and end index should be chosen such that a substring call with those indices on the input string results
// in that part of the string that is responsible for the syntax error.

"use strict";

var util = require("util");

var JPathError = require("./error");

function JPathParsingError(reason, startIdx, endIdx, expectedTokens) {
    JPathError.call(this, "Parsing Error");
    this.reason = reason;
    this.startIdx = startIdx;
    this.endIdx = endIdx;
    this.expectedTokens = Array.isArray(expectedTokens) ? expectedTokens : [expectedTokens];
}

util.inherits(JPathParsingError, JPathError);

JPathParsingError.prototype.name = "JPathParsingError";

var reasons = {};

Object.defineProperty(JPathParsingError, "reasons", {
    value: reasons
});

Object.defineProperties(reasons, {
    missingClosingBracket: {
        value: 0
    },
    unmatchedClosingBracket: {
        value: 1
    },
	missingClosingParentheses: {
		value: 2
	},
	unmatchedClosingParentheses: {
		value: 3
	},
    unexpectedToken: {
        value: 4
    },
    invalidExpression: {
        value: 5
    }
});

exports = module.exports = JPathParsingError;

},{"./error":45,"util":80}],55:[function(require,module,exports){
"use strict";

var Context = require("./context");

function PathExpression(expressions, isAbsolutePath) {
	this._expressions = expressions;
	this._isAbsolutePath = isAbsolutePath;
}

PathExpression.prototype.evaluate = function (context) {
	if (this._isAbsolutePath)
		context = new Context(context.root);

	return this._expressions.reduce(function (context, expression) {
		return new Context(context.root, expression.evaluate(context));
	}, context).current;
};

exports = module.exports = PathExpression;

},{"./context":42}],56:[function(require,module,exports){
"use strict";

var EvaluationResult = require("./evaluation_result");

function PropertyAccessExpression(propertyNamesExpression, isArrayAccess) {
	this._isArrayAccess = isArrayAccess;
	this._propertyNamesExpression = propertyNamesExpression;
}

PropertyAccessExpression.prototype.evaluate = function (context) {
    var isArrayAccess = this._isArrayAccess;
	var propertyNameResults = this._propertyNamesExpression.evaluate(context);
	return Array.prototype.concat.apply([], propertyNameResults.map(function (propertyNameResult) {
		return context.current.map(function (result) {
			return new EvaluationResult(result, propertyNameResult.value, isArrayAccess);
		});
	}));
};

exports = module.exports = PropertyAccessExpression;

},{"./evaluation_result":48}],57:[function(require,module,exports){
"use strict";

var EvaluationResult = require("./evaluation_result");

function RangeExpression(leftExpression, rightExpression) {
	this._leftExpression = leftExpression;
	this._rightExpression = rightExpression;
}

RangeExpression.prototype.evaluate = function (context) {
	var leftPropertyNames = this._leftExpression.evaluate(context);
	var rightPropertyNames = this._rightExpression.evaluate(context);

	return makeRange(+leftPropertyNames[0].value, +rightPropertyNames[0].value);
};

function makeRange(left, right) {
	if (left > right) {
		var tmp = left;
		left = right;
		right = tmp;
	}

	var range = [];
	for	(var i = left; i < right; ++i)
		range.push(new EvaluationResult(i));

	return range;
}

exports = module.exports = RangeExpression;

},{"./evaluation_result":48}],58:[function(require,module,exports){
"use strict";

var EvaluationResult = require("./evaluation_result");

function RecursiveDescentExpression() {}

RecursiveDescentExpression.prototype.evaluate = function (context) {
	function findDescendants(result) {
        var object = result.value;
		var descendants = [];
		Object.keys(object).forEach(function (key) {
            if (typeof object[key] === "object") {
				descendants.push.apply(descendants, findDescendants(new EvaluationResult(result, key)));
                descendants.push(new EvaluationResult(result, key));
            }
        });
		return descendants;
	}

	return Array.prototype.concat.apply([], context.current.filter(function (result) {
        return result.isDefined() && typeof result.value === "object";
    }).map(function (result) {
		return findDescendants(result);
	}));
};

exports = module.exports = RecursiveDescentExpression;

},{"./evaluation_result":48}],59:[function(require,module,exports){
"use strict";

var tokenTypes = require("./token").types;

exports = module.exports = {
	"/": tokenTypes.separator,
	"[": tokenTypes.openBracket,
	"]": tokenTypes.closeBracket,
	"(": tokenTypes.openParentheses,
	")": tokenTypes.closeParentheses,
	"*": tokenTypes.asterisk,
	":": tokenTypes.colon
};
},{"./token":61}],60:[function(require,module,exports){
// # JPathSyntaxError

// This class represents syntactic errors in a JPath.
// Syntactic errors include unbalanced brackets, invalid escape sequences or invalid expressions in general.
// As all errors it inherits from the general JPath error.
// The reason for the syntax error should be one of the constants defined below.
// The start and end index should be chosen such that a substring call with those indices on the input string results
// in that part of the string that is responsible for the syntax error.

"use strict";

var util = require("util");

var JPathError = require("./error");
var JPathParsingError = require("./parsing_error");

function JPathSyntaxError(params) {
    JPathError.call(this, "Syntax error");
    this.reason = params.reason;
    this.startIdx = params.startIdx;
    this.endIdx = params.endIdx;
    this.actual = params.actual;
    this.expected = params.expected;
    this.message = params.message;
}

util.inherits(JPathSyntaxError, JPathError);

JPathSyntaxError.prototype.name = "JPathSyntaxError";

var reasons = util._extend({}, JPathParsingError.reasons);

Object.defineProperty(JPathSyntaxError, "reasons", {
    value: reasons
});

Object.defineProperty(reasons, "invalidEscapeSequence", {
    value: JPathParsingError.reasons.invalidExpression + 1
});

exports = module.exports = JPathSyntaxError;

},{"./error":45,"./parsing_error":54,"util":80}],61:[function(require,module,exports){
// # Token

// Represents a token as the result of the lexers scanning process.
// The startIdx and endIdx parameter are chosen to such that a call to String#substring(startIdx, endIdx) on the input stream would return the token's value.

"use strict";

// Constructs a token with the given token type, the tokens start and end index and its actual string value.
function Token(type, startIdx, endIdx, value) {
    this.type = type;
    this.startIdx = startIdx;
    this.endIdx = endIdx;
    this.value = value;
}

exports = module.exports = Token;

var tokenTypes = {};

Object.defineProperty(Token, "types", {
    value: tokenTypes
});

Object.defineProperties(tokenTypes, {
    // The token that separates two path components.
    separator: {
        value: 0
    },
    // Introduces an array index expression.
    openBracket: {
        value: 1
    },
    // Closes an array index expression or a sub expression.
    closeBracket: {
        value: 2
    },
	// Introduces either an array index expression or a sub expression.
	openParentheses: {
		value: 3
	},
	// Closes an array index expression or a sub expression.
	closeParentheses: {
		value: 4
	},
    // The token that represents a descent one level expression.
    asterisk: {
        value: 5
    },
    // The token used inside an array index expression to define a slice operation.
    colon: {
        value: 6
    },
    // The token for a literal.
	literal: {
        value: 11
    },
    // The token representing the end of transmission/tokenstream.
    eot: {
        value: 100
    }
});

},{}],62:[function(require,module,exports){
(function (process){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(new Function("return this")()));

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69}],63:[function(require,module,exports){

},{}],64:[function(require,module,exports){
/**
 * The buffer module from node.js, for the browser.
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install buffer`
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
  if (typeof Uint8Array !== 'function' || typeof ArrayBuffer !== 'function')
    return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Bug in Firefox 4-29, now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":65,"ieee754":66}],65:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],66:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],67:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],68:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],69:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],70:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69}],71:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

},{"./readable.js":75,"./writable.js":77,"inherits":68,"process/browser.js":73}],72:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"./duplex.js":71,"./passthrough.js":74,"./readable.js":75,"./transform.js":76,"./writable.js":77,"events":67,"inherits":68}],73:[function(require,module,exports){
module.exports=require(69)
},{}],74:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./transform.js":76,"inherits":68}],75:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./index.js":72,"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69,"buffer":64,"events":67,"inherits":68,"process/browser.js":73,"string_decoder":78}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./duplex.js":71,"inherits":68}],77:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./index.js":72,"buffer":64,"inherits":68,"process/browser.js":73}],78:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":64}],79:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],80:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":79,"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69,"inherits":68}],81:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"./invalid_escape_sequence_error":91,"./lexing":93,"./parsing":94,"./parsing_error":95,"./syntax_error":101}],82:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"./evaluation_result":89}],83:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./evaluation_result":89}],84:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"./evaluation":88}],85:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"./evaluation_result":89}],86:[function(require,module,exports){
module.exports=require(45)
},{"/Users/jan/development/xml3d_blast_loader/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":69,"util":80}],87:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"./invalid_escape_sequence_error":91,"./separator_token_mapping":100}],88:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./compiling":81,"./context":83}],89:[function(require,module,exports){
module.exports=require(48)
},{"./joining":92}],90:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"./constant_value_expression":82,"./coverage":84,"./descent_expression":85,"./escaping":87,"./evaluation":88,"./invalid_escape_sequence_error":91,"./joining":92,"./lexing":93,"./parsing":94,"./parsing_error":95,"./path_expression":96,"./property_access_expression":97,"./range_expression":98,"./recursive_descent_expression":99,"./separator_token_mapping":100,"./token":102}],91:[function(require,module,exports){
module.exports=require(50)
},{"./error":86,"util":80}],92:[function(require,module,exports){
module.exports=require(51)
},{"path":70}],93:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"./escaping":87,"./invalid_escape_sequence_error":91,"./separator_token_mapping":100,"./syntax_error":101,"./token":102}],94:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"./constant_value_expression":82,"./descent_expression":85,"./parsing_error":95,"./path_expression":96,"./property_access_expression":97,"./range_expression":98,"./recursive_descent_expression":99,"./token":102}],95:[function(require,module,exports){
module.exports=require(54)
},{"./error":86,"util":80}],96:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"./context":83}],97:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"./evaluation_result":89}],98:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./evaluation_result":89}],99:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"./evaluation_result":89}],100:[function(require,module,exports){
module.exports=require(59)
},{"./token":102}],101:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"./error":86,"./parsing_error":95,"util":80}],102:[function(require,module,exports){
module.exports=require(61)
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbGliL2xvYWRlci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9hYm9wcy9saWIvYWJvcHMuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3QvbGliL2Jyb3dzZXIvZGVjb2Rpbmdfd29ya2VyX3Bvb2wuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3QvbGliL2Jyb3dzZXIvcnVuX2V4dGVybmFsX2RlY29kaW5nLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L2xpYi9jaHVuay5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9saWIvY2h1bmtlci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9saWIvZGVjaHVua2VyLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L2xpYi9lcnJvci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9saWIvaW5kZXguanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3QvbGliL25vZGUvcnVuX2V4dGVybmFsX2RlY29kaW5nLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L2xpYi9vYmplY3RfYXNzZW1ibGVyLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L2xpYi9vYmplY3RfZW5jb2Rlci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9saWIvcHJlYW1ibGUuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3QvbGliL3J1bl9leHRlcm5hbF9kZWNvZGluZy5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9saWIvc3RyZWFtX2dlbmVyYXRvci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9saWIvc3RyZWFtX3JlY2VpdmVyLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L2xpYi91dGlsL2NhbGxfaW1tZWRpYXRlLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L2xpYi91dGlsL2lzX2xpdHRsZV9lbmRpYW5fYXJjaGl0ZWN0dXJlLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L2xpYi91dGlsL3dyYXBfc3luY19mdW5jdGlvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9saWIvdmFsdWVfZGVjb2Rlci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYXN5bmMvbGliL2FzeW5jLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9ibGFzdC1jb2RlY3MvbGliL2NvZGVjcy9hc3NpbXBfbWVzaC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYmxhc3QtY29kZWNzL2xpYi9jb2RlY3MvanNvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYmxhc3QtY29kZWNzL2xpYi9jb2RlY3MvbzNkZ2MuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2JsYXN0LWNvZGVjcy9saWIvY29kZWNzL28zZGdjX2FzY2lpLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9ibGFzdC1jb2RlY3MvbGliL2NvZGVjcy9vcGVuY3RtLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9ibGFzdC1jb2RlY3MvbGliL2NvZGVjcy9wYXNzdGhyb3VnaC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYmxhc3QtY29kZWNzL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYmxhc3QtY29kZWNzL2xpYi91dGlsL2ZsaXBfZW5kaWFubmVzc19pZl9uZWNlc3NhcnkuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2JsYXN0LWNvZGVjcy9ub2RlX21vZHVsZXMvbzNkZ2MvaW5kZXguanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2JsYXN0LWNvZGVjcy9ub2RlX21vZHVsZXMvbzNkZ2MvbGliL2Zyb21fYnVmZmVyLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9ibGFzdC1jb2RlY3Mvbm9kZV9tb2R1bGVzL28zZGdjL2xpYi9vM2RnYy5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYmxhc3QtY29kZWNzL25vZGVfbW9kdWxlcy9vcGVuY3RtL2luZGV4LmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9ibGFzdC1jb2RlY3Mvbm9kZV9tb2R1bGVzL29wZW5jdG0vbGliL2N0bS5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYmxhc3QtY29kZWNzL25vZGVfbW9kdWxlcy9vcGVuY3RtL2xpYi9mcm9tX2J1ZmZlci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvYmxhc3QtY29kZWNzL25vZGVfbW9kdWxlcy9vcGVuY3RtL2xpYi9sem1hLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvY29tcGlsaW5nLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvY29uc3RhbnRfdmFsdWVfZXhwcmVzc2lvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvanBhdGgvbGliL2NvbnRleHQuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2pwYXRoL2xpYi9jb3ZlcmFnZS5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvanBhdGgvbGliL2Rlc2NlbnRfZXhwcmVzc2lvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvanBhdGgvbGliL2Vycm9yLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvZXNjYXBpbmcuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2pwYXRoL2xpYi9ldmFsdWF0aW9uLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvZXZhbHVhdGlvbl9yZXN1bHQuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2pwYXRoL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvanBhdGgvbGliL2ludmFsaWRfZXNjYXBlX3NlcXVlbmNlX2Vycm9yLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvam9pbmluZy5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvanBhdGgvbGliL2xleGluZy5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvanBhdGgvbGliL3BhcnNpbmcuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2pwYXRoL2xpYi9wYXJzaW5nX2Vycm9yLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvcGF0aF9leHByZXNzaW9uLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvcHJvcGVydHlfYWNjZXNzX2V4cHJlc3Npb24uanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL2pwYXRoL2xpYi9yYW5nZV9leHByZXNzaW9uLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvcmVjdXJzaXZlX2Rlc2NlbnRfZXhwcmVzc2lvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ibGFzdC9ub2RlX21vZHVsZXMvanBhdGgvbGliL3NlcGFyYXRvcl90b2tlbl9tYXBwaW5nLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvc3ludGF4X2Vycm9yLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2JsYXN0L25vZGVfbW9kdWxlcy9qcGF0aC9saWIvdG9rZW4uanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvYmxhc3Qvbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2R1cGxleC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9wYXNzdGhyb3VnaC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9yZWFkYWJsZS5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS90cmFuc2Zvcm0uanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvd3JpdGFibGUuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL2NvbXBpbGluZy5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9qcGF0aC9saWIvY29uc3RhbnRfdmFsdWVfZXhwcmVzc2lvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9qcGF0aC9saWIvY29udGV4dC5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9qcGF0aC9saWIvY292ZXJhZ2UuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL2Rlc2NlbnRfZXhwcmVzc2lvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9qcGF0aC9saWIvZXNjYXBpbmcuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL2V2YWx1YXRpb24uanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL2luZGV4LmpzIiwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2pwYXRoL2xpYi9sZXhpbmcuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL3BhcnNpbmcuanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL3BhdGhfZXhwcmVzc2lvbi5qcyIsIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9qcGF0aC9saWIvcHJvcGVydHlfYWNjZXNzX2V4cHJlc3Npb24uanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL3JhbmdlX2V4cHJlc3Npb24uanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL3JlY3Vyc2l2ZV9kZXNjZW50X2V4cHJlc3Npb24uanMiLCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvanBhdGgvbGliL3N5bnRheF9lcnJvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaDhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDJGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWtCQTs7QUNBQTs7QUNBQTs7QUNBQTs7QUNBQTs7OztBQ0FBOztBQ0FBOzs7O0FDQUE7Ozs7OztBQ0FBOztBQ0FBOzs7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7Ozs7QUNBQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgYmxhc3QgPSByZXF1aXJlKFwiYmxhc3RcIik7XHJcbnZhciBqcGF0aCA9IHJlcXVpcmUoXCJqcGF0aFwiKTtcclxudmFyIGFib3BzID0gcmVxdWlyZShcImFib3BzXCIpO1xyXG5cclxudmFyIG5vcm1hbCA9ICgxIDw8IDApO1xyXG52YXIgdGFuZ2VudCA9ICgxIDw8IDEpO1xyXG52YXIgdGV4Y29vcmQgPSAoMSA8PCAyKTtcclxudmFyIGNvbG9yID0gKDEgPDwgMyk7XHJcbnZhciB0cmFuc2Zvcm0gPSAoMSA8PCA0KTtcclxuXHJcbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuQXJjaGl0ZWN0dXJlKCkge1xyXG4gICAgLy8gRGF0YVZpZXcjZ2V0VWludDE2IHdpbGwgcmVhZCAxIG9uIGJpZy1lbmRpYW4gc3lzdGVtcy5cclxuICAgIHJldHVybiBuZXcgRGF0YVZpZXcobmV3IFVpbnQxNkFycmF5KFsyNTZdKS5idWZmZXIpLmdldFVpbnQxNigwLCB0cnVlKSA9PT0gMjU2O1xyXG59O1xyXG5cclxuIGZ1bmN0aW9uIGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeSh0eXBlZEFycmF5LCBsaXR0bGVFbmRpYW4pIHtcclxuICAgIGlmIChsaXR0bGVFbmRpYW4gIT09IGlzTGl0dGxlRW5kaWFuQXJjaGl0ZWN0dXJlKCkpXHJcbiAgICAgICAgcmV0dXJuIGFib3BzLmZsaXBFbmRpYW5uZXNzKHR5cGVkQXJyYXkpO1xyXG4gICAgcmV0dXJuIHR5cGVkQXJyYXk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBkZWNvZGVBc3NpbXBNZXNoKGJ1ZmZlciwgbGl0dGxlRW5kaWFuKSB7XHJcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xyXG4gICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICB2YXIgdmVydGV4Q291bnQgPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XHJcbiAgICBvZmZzZXQgKz0gNDtcclxuICAgIHZhciBhdHRyaWJzID0gdmlldy5nZXRVaW50OChvZmZzZXQpO1xyXG4gICAgb2Zmc2V0ICs9IDQ7XHJcblxyXG4gICAgdmFyIG1lc2ggPSB7XHJcbiAgICAgICAgcG9zaXRpb246IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCB2ZXJ0ZXhDb3VudCAqIDMpLCBsaXR0bGVFbmRpYW4pXHJcbiAgICB9O1xyXG4gICAgb2Zmc2V0ICs9IHZlcnRleENvdW50ICogMyAqIG1lc2gucG9zaXRpb24uQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgaWYgKGF0dHJpYnMgJiBub3JtYWwpIHtcclxuICAgICAgICBtZXNoLm5vcm1hbCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCB2ZXJ0ZXhDb3VudCAqIDMpLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIG9mZnNldCArPSB2ZXJ0ZXhDb3VudCAqIDMgKiBtZXNoLm5vcm1hbC5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgIH1cclxuICAgIGlmIChhdHRyaWJzICYgdGFuZ2VudCkge1xyXG4gICAgICAgIG1lc2gudGFuZ2VudCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCB2ZXJ0ZXhDb3VudCAqIDMpLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIG9mZnNldCArPSB2ZXJ0ZXhDb3VudCAqIDMgKiBtZXNoLnRhbmdlbnQuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICB9XHJcbiAgICBpZiAoYXR0cmlicyAmIHRleGNvb3JkKSB7XHJcbiAgICAgICAgbWVzaC50ZXhjb29yZCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCB2ZXJ0ZXhDb3VudCAqIDIpLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIG9mZnNldCArPSB2ZXJ0ZXhDb3VudCAqIDIgKiBtZXNoLnRleGNvb3JkLkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgfVxyXG4gICAgaWYgKGF0dHJpYnMgJiBjb2xvcikge1xyXG4gICAgICAgIG1lc2guY29sb3IgPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIG9mZnNldCwgdmVydGV4Q291bnQgKiA0KSwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICBvZmZzZXQgKz0gdmVydGV4Q291bnQgKiA0ICogbWVzaC5jb2xvci5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgIH1cclxuICAgIGlmIChhdHRyaWJzICYgdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgbWVzaC5tZXNoVHJhbnNmb3JtID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIDE2KSwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICBvZmZzZXQgKz0gMTYgKiBtZXNoLm1lc2hUcmFuc2Zvcm0uQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICB9XHJcblxyXG4gICAgbWVzaC5pbmRleCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShuZXcgVWludDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQpLCBsaXR0bGVFbmRpYW4pO1xyXG5cclxuICAgIHJldHVybiBtZXNoO1xyXG59O1xyXG5cclxudmFyIEJsYXN0Rm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgWE1MM0QuYmFzZS5CaW5hcnlGb3JtYXRIYW5kbGVyLmNhbGwodGhpcyk7XHJcbn07XHJcblxyXG5YTUwzRC5jcmVhdGVDbGFzcyhCbGFzdEZvcm1hdEhhbmRsZXIsIFhNTDNELmJhc2UuQmluYXJ5Rm9ybWF0SGFuZGxlcik7XHJcblxyXG5CbGFzdEZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmlzRm9ybWF0U3VwcG9ydGVkID0gZnVuY3Rpb24ocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUpIHtcclxuICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuQmxhc3RGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGb3JtYXREYXRhID0gZnVuY3Rpb24ocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgeGZsb3dEYXRhID0gW107XHJcbiAgICB2YXIgc3RyZWFtUmVjZWl2ZXIgPSBuZXcgYmxhc3QuU3RyZWFtUmVjZWl2ZXIoe1xyXG4gICAgICAgIGFzeW5jOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICB2YXIgZXJyb3JDYWxsYmFjayA9IGNhbGxiYWNrLmJpbmQodW5kZWZpbmVkLCBmYWxzZSk7XHJcbiAgICBzdHJlYW1SZWNlaXZlci5lbmQocmVzcG9uc2UpO1xyXG4gICAgc3RyZWFtUmVjZWl2ZXJcclxuICAgICAgICAub24oXCJlcnJvclwiLCBlcnJvckNhbGxiYWNrKVxyXG4gICAgICAgIC5waXBlKG5ldyBibGFzdC5EZWNodW5rZXIoeyBhc3luYzogZmFsc2UgfSkpXHJcbiAgICAgICAgLm9uKFwiZXJyb3JcIiwgZXJyb3JDYWxsYmFjaylcclxuICAgICAgICAucGlwZShuZXcgYmxhc3QuVmFsdWVEZWNvZGVyKHtcclxuICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxyXG4gICAgICAgICAgICBkZWNvZGluZ1NwZWNpZmljYXRpb25NYXA6IHtcclxuICAgICAgICAgICAgICAgIFwiaHR0cDovL2xvY2FsaG9zdDo5MDkwL2NvZGVjcy9hc3NpbXBNZXNoXCI6IGRlY29kZUFzc2ltcE1lc2hcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKVxyXG4gICAgICAgIC5vbihcImVycm9yXCIsIGVycm9yQ2FsbGJhY2spXHJcbiAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGVjb2RlZERhdGEpIHtcclxuICAgICAgICAgICAganBhdGguZXZhbHVhdGUoZGVjb2RlZERhdGEucGF0aCwgeGZsb3dEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGRlY29kZWREYXRhLm1ldGFkYXRhLmZvckVhY2goZnVuY3Rpb24gKHBhdGhUeXBlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganBhdGguZXZhbHVhdGUocGF0aFR5cGVNYXAucGF0aCwgZGVjb2RlZERhdGEudmFsdWUpLmRlZmluZWRSZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGZsb3dEYXRhRGVzY3JpcHRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXRoVHlwZU1hcC50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmlzUm9vdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWREYXRhLnZhbHVlID0geGZsb3dEYXRhRGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHhmbG93RGF0YURlc2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmlzUm9vdClcclxuICAgICAgICAgICAgICAgICAgICB4Zmxvd0RhdGEgPSBkZWNvZGVkRGF0YS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBkZWNvZGVkRGF0YS52YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJmaW5pc2hcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh0cnVlLCB4Zmxvd0RhdGEpO1xyXG4gICAgICAgIH0pO1xyXG59O1xyXG5cclxuQmxhc3RGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGcmFnbWVudERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgcGF0aCkge1xyXG4gICAgaWYgKCFwYXRoKVxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgcmV0dXJuIGpwYXRoLmV2YWx1YXRlKHBhdGgsIGRhdGEpLmRlZmluZWRSZXN1bHRzLmxlbmd0aCA+IDAgPyBqcGF0aC5ldmFsdWF0ZShwYXRoLCBkYXRhKS5kZWZpbmVkUmVzdWx0c1swXS52YWx1ZSA6IG51bGw7XHJcbn07XHJcblxyXG52YXIgYmxhc3RGb3JtYXRIYW5kbGVyID0gbmV3IEJsYXN0Rm9ybWF0SGFuZGxlcigpO1xyXG5YTUwzRC5iYXNlLnJlZ2lzdGVyRm9ybWF0KGJsYXN0Rm9ybWF0SGFuZGxlcik7XHJcblxyXG52YXIgQmxhc3REYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YS5hc3NldE1lc2hlcylcclxuICAgICAgICB0aGlzLl9hc3NldCA9IGNyZWF0ZUFzc2V0KGRhdGEpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHRoaXMuX3hmbG93Tm9kZSA9IGNyZWF0ZVhmbG93RGF0YU5vZGUoZGF0YSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVYZmxvd0RhdGFOb2RlIChkYXRhKSB7XHJcbiAgICB2YXIgeGZsb3dEYXRhTm9kZSA9IFhNTDNELmRhdGEueGZsb3dHcmFwaC5jcmVhdGVEYXRhTm9kZSgpO1xyXG5cclxuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgICAgICB2YXIgYXR0cmlidXRlID0gZGF0YVthdHRyaWJ1dGVOYW1lXTtcclxuICAgICAgICBpZiAoYXR0cmlidXRlKVxyXG4gICAgICAgICAgICB4Zmxvd0RhdGFOb2RlLmFwcGVuZENoaWxkKGNyZWF0ZUlucHV0Tm9kZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGUudHlwZSwgYXR0cmlidXRlLnZhbHVlKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4geGZsb3dEYXRhTm9kZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSW5wdXROb2RlKG5hbWUsIHR5cGUsIHR5cGVkQXJyYXkpIHtcclxuICAgIHZhciBpbnB1dE5vZGUgPSBYTUwzRC5kYXRhLnhmbG93R3JhcGguY3JlYXRlSW5wdXROb2RlKCk7XHJcbiAgICBpbnB1dE5vZGUubmFtZSA9IG5hbWU7XHJcbiAgICBpbnB1dE5vZGUuZGF0YSA9IG5ldyBYZmxvdy5CdWZmZXJFbnRyeShYTUwzRC5kYXRhLkJVRkZFUl9UWVBFX1RBQkxFW3R5cGVdLCB0eXBlZEFycmF5KTtcclxuICAgIHJldHVybiBpbnB1dE5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUFzc2V0KGRhdGEpIHtcclxuICAgIHZhciBhc3NldCA9IG5ldyBYTUwzRC5iYXNlLkFzc2V0KCk7XHJcbiAgICBPYmplY3Qua2V5cyhkYXRhLmFzc2V0TWVzaGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhc3NldE1lc2hJZHgpIHtcclxuICAgICAgICB2YXIgYXNzZXRNZXNoRGF0YSA9IGRhdGEuYXNzZXRNZXNoZXNbYXNzZXRNZXNoSWR4XTtcclxuICAgICAgICB2YXIgYXNzZXRNZXNoID0gbmV3IFhNTDNELmJhc2UuU3ViRGF0YShYTUwzRC5kYXRhLnhmbG93R3JhcGguY3JlYXRlRGF0YU5vZGUoKSwgY3JlYXRlWGZsb3dEYXRhTm9kZShhc3NldE1lc2hEYXRhKSk7XHJcbiAgICAgICAgYXNzZXRNZXNoLnNldE1lc2hUeXBlKFwidHJpYW5nbGVzXCIpO1xyXG4gICAgICAgIGFzc2V0LmFwcGVuZENoaWxkKGFzc2V0TWVzaCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBhc3NldDtcclxufVxyXG5cclxuQmxhc3REYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0WGZsb3dOb2RlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5feGZsb3dOb2RlO1xyXG59O1xyXG5cclxuQmxhc3REYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0QXNzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9hc3NldDtcclxufTtcclxuXHJcbnZhciBCbGFzdEZhY3RvcnkgPSBmdW5jdGlvbigpe1xyXG4gICAgWE1MM0QuYmFzZS5BZGFwdGVyRmFjdG9yeS5jYWxsKHRoaXMsIFhNTDNELmRhdGEpO1xyXG59O1xyXG5cclxuWE1MM0QuY3JlYXRlQ2xhc3MoQmxhc3RGYWN0b3J5LCBYTUwzRC5iYXNlLkFkYXB0ZXJGYWN0b3J5KTtcclxuXHJcbkJsYXN0RmFjdG9yeS5wcm90b3R5cGUuYXNwZWN0ID0gWE1MM0QuZGF0YTtcclxuQmxhc3RGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24obWVzaCkge1xyXG4gICAgcmV0dXJuIG5ldyBCbGFzdERhdGFBZGFwdGVyKG1lc2gpO1xyXG59O1xyXG5cclxuWE1MM0QuYmFzZS5yZXNvdXJjZU1hbmFnZXIuYWRkQmluYXJ5RXh0ZW5zaW9uKFwiLmJsYXN0XCIpO1xyXG5YTUwzRC5iYXNlLnJlc291cmNlTWFuYWdlci5hZGRCaW5hcnlDb250ZW50VHlwZShcIm1vZGVsL3ZuZC54bWwzZC5kYXRhK2Jsc3RcIik7XHJcblhNTDNELmJhc2UucmVzb3VyY2VNYW5hZ2VyLmFkZEJpbmFyeUNvbnRlbnRUeXBlKFwibW9kZWwvdm5kLnhtbDNkLm1vZGVsK2Jsc3RcIik7XHJcbmJsYXN0Rm9ybWF0SGFuZGxlci5yZWdpc3RlckZhY3RvcnlDbGFzcyhCbGFzdEZhY3RvcnkpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgVWludDhBcnJheSBmb3IgdGhlIGdpdmVuIEFycmF5QnVmZmVyLlxyXG4gKiBJZiBhIEFycmF5QnVmZmVyVmlldyBvciBhIERhdGFWaWV3IGlzIGdpdmVuLCB0aGUgdW5kZXJseWluZyBidWZmZXIgd2lsbCBiZSB1c2VkIGFuZCB0aGUgc2V0XHJcbiAqIG9mZnNldCBhbmQgbGVuZ3RoIHdpbGwgYmUgcmVzcGVjdGVkLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZnVuY3Rpb24gdG9VaW50OEFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgQXJyYXlCdWZmZXIgb3IgYSB2aWV3IGludG8gYW4gQXJyYXlCdWZmZXIgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIFVpbnQ4QXJyYXkgdmlldy5cclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEEgVWludDhBcnJheSByZWZlcmVuY2luZyB0aGUgZ2l2ZW4gQXJyYXlCdWZmZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKSB7XHJcblx0b2Zmc2V0ID0gK29mZnNldCB8fCAwO1xyXG5cdGxlbmd0aCA9ICtsZW5ndGg7XHJcblx0aWYgKHR5cGVvZiBhcnJheUJ1ZmZlci5CWVRFU19QRVJfRUxFTUVOVCAhPT0gXCJ1bmRlZmluZWRcIiB8fCBhcnJheUJ1ZmZlciBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XHJcblx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIuYnVmZmVyLCBvZmZzZXQgKyBhcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LCBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoIC0gb2Zmc2V0KTtcclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoIHx8IGFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBvZmZzZXQpO1xyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbmNhdGVuYXRlcyBhIHZhcmlhYmxlIGxpc3Qgb2YgQXJyYXlCdWZmZXJzLlxyXG4gKiBJZiBvbmUgb2YgdGhlIGFyZ3VtZW50cyBpcyBhIERhdGFWaWV3IG9yIGFuIGBBcnJheUJ1ZmZlclZpZXdgIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYW5kXHJcbiAqIHRoZSBzZXQgb2Zmc2V0IGFuZCBsZW5ndGggd2lsbCBiZSByZXNwZWN0ZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQGZ1bmN0aW9uIGNvbmNhdFxyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyLi4ufEFycmF5QnVmZmVyVmlldy4uLn0gYnVmZmVycyBBIHZhcmlhYmxlIGxpc3Qgb2YgcGxhaW4gQXJyYXlCdWZmZXJzIG9yIEFycmF5QnVmZmVyVmlld3MuXHJcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQSBuZXcgQXJyYXlCdWZmZXIgYXMgdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBidWZmZXJzLlxyXG4gKi9cclxuZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXHJcblx0XHRyZXR1cm4gdG9VaW50OEFycmF5KGFyZ3VtZW50c1swXSkuYnVmZmVyO1xyXG5cdGVsc2VcclxuXHRcdHZhciBhcnJheUJ1ZmZlckxpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cclxuICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIGJ1ZmZlcnMgYW5kIHRoZWlyIHRvdGFsIHNpemVcclxuICAgIHZhciB0b3RhbFNpemUgPSAwO1xyXG4gICAgdmFyIGJ5dGVCdWZmZXJzID0gYXJyYXlCdWZmZXJMaXN0Lm1hcChmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAvLyBJZiBhIGBEYXRhVmlld2Agb3IgYSB0eXBlZCBhcnJheSB3YXMgcGFzc2VkIGluc3RlYWQgb2YgYSBwbGFpbiBgQXJyYXlCdWZmZXJgXHJcbiAgICAgICAgLy8gdGhlIHVuZGVybHlpbmcgYnVmZmVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxyXG4gICAgICAgIHZhciBieXRlQnVmZmVyID0gdG9VaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgICAgICB0b3RhbFNpemUgKz0gYnl0ZUJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVCdWZmZXI7XHJcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGJ5dGVCdWZmZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVCdWZmZXIubGVuZ3RoID4gMDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICBpZiAoYnl0ZUJ1ZmZlcnMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XHJcblxyXG4gICAgaWYgKGJ5dGVCdWZmZXJzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICByZXR1cm4gYnl0ZUJ1ZmZlcnNbMF0uYnVmZmVyO1xyXG5cclxuXHQvLyBUaGlzIHdpbGwgY29udGFpbiB0aGUgZmluYWwgY29uY2F0ZW5hdGVkIGJ1ZmZlci5cclxuICAgIHZhciBjb25jYXRCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xyXG5cclxuICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgYnl0ZUJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbiAoYnl0ZUJ1ZmZlcikge1xyXG4gICAgICAgIGNvbmNhdEJ1ZmZlci5zZXQoYnl0ZUJ1ZmZlciwgb2Zmc2V0KTtcclxuICAgICAgICBvZmZzZXQgKz0gYnl0ZUJ1ZmZlci5sZW5ndGg7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY29uY2F0QnVmZmVyLmJ1ZmZlcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGbGlwcyB0aGUgZW5kaWFubmVzcyBvZiB0aGUgZ2l2ZW4gVHlwZWRBcnJheSBpbi1wbGFjZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAZnVuY3Rpb24gZmxpcEVuZGlhbm5lc3NcclxuICogQHBhcmFtIHtUeXBlZCBBcnJheX0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgZm9yIHdoaWNoIHRoZSBlbmRpYW5uZXNzIHNob3VsZCBiZSBmbGlwcGVkLlxyXG4gKi9cclxuZXhwb3J0cy5mbGlwRW5kaWFubmVzcyA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XHJcblx0Ly8gVWludDhDbGFtcGVkQXJyYXkgaXMgYSByYXRoZXIgbmV3IHBhcnQgb2YgdGhlIHR5cGVkIGFycmF5IHNwZWNpZmljYXRpb24gYW5kIG5vdCBmdWxseSBzdXBwb3J0ZWQgYnlcclxuXHQvLyBhbGwgYnJvd3NlcnMuXHJcblx0dmFyIFVpbnQ4Q2xhbXBlZEFycmF5VHlwZTtcclxuXHRpZiAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSBcInVuZGVmaW5lZFwiKVxyXG5cdFx0VWludDhDbGFtcGVkQXJyYXlUeXBlID0gZnVuY3Rpb24gZHVtbXkoKSB7fTtcclxuXHRlbHNlXHJcblx0XHRVaW50OENsYW1wZWRBcnJheVR5cGUgPSBVaW50OENsYW1wZWRBcnJheTtcclxuXHJcblx0aWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5VHlwZSlcclxuICAgICAgICByZXR1cm4gdHlwZWRBcnJheTtcclxuXHJcbiAgICB2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkub2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7IGkgKz0gdHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVCkge1xyXG4gICAgICAgIHZhciBsZWZ0SWR4ID0gaTtcclxuICAgICAgICB2YXIgcmlnaHRJZHggPSBpICsgdHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAtIDE7XHJcblx0ICAgIC8vIFdhbGsgZnJvbSBsZWZ0IGFuZCByaWdodCBhbmQgc3dhcCBieXRlcy5cclxuICAgICAgICB3aGlsZSAobGVmdElkeCA8IHJpZ2h0SWR4KSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBieXRlQXJyYXlbbGVmdElkeF07XHJcbiAgICAgICAgICAgIGJ5dGVBcnJheVtsZWZ0SWR4XSA9IGJ5dGVBcnJheVtyaWdodElkeF07XHJcbiAgICAgICAgICAgIGJ5dGVBcnJheVtyaWdodElkeF0gPSB0bXA7XHJcbiAgICAgICAgICAgICsrbGVmdElkeDtcclxuICAgICAgICAgICAgLS1yaWdodElkeDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHR5cGVkQXJyYXk7XHJcbn07XHJcblxyXG4vLyAjIFN0cmluZyBoYW5kbGluZ1xyXG5cclxuLy8gSmF2YVNjcmlwdCBzdHJpbmcgYXJlIFVURi0xNiBlbmNvZGVkLlxyXG4vLyBUbyBoYW5kbGUgY29udmVyc2lvbiBpbnRvIGRpZmZlcmVudCB1bmljb2RlIGVuY29kaW5ncywgbWFpbmx5IFVURi04LCB3ZSBjb252ZXJ0IEphdmFTY3JpcHQgc3RyaW5nXHJcbi8vIGludG8gYW4gYXJyYXkgb2YgdW5pY29kZSBjb2RlIHBvaW50cyB0aGF0IGNhbiBlYXNpbHkgY29udmVydGVkIGludG8gZGlmZmVyZW50IGVuY29kaW5ncy5cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gSmF2YVNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB1bmljb2RlIGNvZGUgcG9pbnRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZnVuY3Rpb24gc3RyaW5nVG9Vbmljb2RlQ29kZVBvaW50c1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cclxuICogQHJldHVybnMge251bWJlcltdfSBUaGUgYXJyYXkgb2YgdW5pY29kZSBjb2RlIHBvaW50cyBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5nVG9Vbmljb2RlQ29kZVBvaW50cyhzdHJpbmcpIHtcclxuXHR2YXIgb3V0cHV0ID0gW107XHJcblx0dmFyXHRjb3VudGVyID0gMDtcclxuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcclxuXHR2YXIgdmFsdWU7XHJcblx0dmFyIGV4dHJhO1xyXG5cclxuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xyXG5cdFx0Ly8gSmF2YVNjcmlwdHMgU3RyaW5nI2NoYXJDb2RlQXQgZnVuY3Rpb24gcmV0dXJucyB2YWx1ZXMgbGVzcyB0aGFuIDY1NTM2LlxyXG5cdFx0Ly8gSGlnaGVyIGNvZGUgcG9pbnRzIGFyZSByZXByZXNlbnRlZCB1c2luZyBzbyBjYWxsZWQgc3Vycm9nYXRlIHBhaXJzLlxyXG5cdFx0Ly8gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8gZXhhbWluZSB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gZ2V0IHRoZSByZWFsIHVuaWNvZGUgY29kZSBwb2ludCB2YWx1ZS5cclxuXHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcclxuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcclxuXHRcdFx0Ly8gSGlnaCBzdXJyb2dhdGUgPT4gdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxyXG5cdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XHJcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xyXG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGVcclxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XHJcblx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXHJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xyXG5cdFx0XHRcdGNvdW50ZXItLTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgdW5pY29kZSBjb2RlcG9pbnRzIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGZ1bmN0aW9uIHVuaWNvZGVDb2RlUG9pbnRzVG9TdHJpbmdcclxuICogQHBhcmFtIHtudW1iZXJbXX0gY29kZVBvaW50cyBBbiBhcnJheSBvZiB1bmljb2RlIGNvZGUgcG9pbnRzLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBjb2RlIHBvaW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHVuaWNvZGVDb2RlUG9pbnRzVG9TdHJpbmcoY29kZVBvaW50cykge1xyXG5cdHJldHVybiBjb2RlUG9pbnRzLm1hcChmdW5jdGlvbihjb2RlUG9pbnQpIHtcclxuXHRcdHZhciBvdXRwdXQgPSAnJztcclxuXHRcdGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcclxuXHRcdFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XHJcblx0XHRcdG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XHJcblx0XHRcdGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xyXG5cdFx0fVxyXG5cdFx0b3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuXHRcdHJldHVybiBvdXRwdXQ7XHJcblx0fSkuam9pbignJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gYSBzZXJpZXMgb2Ygb2YgVVRGLTggY29kZSB1bml0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGZ1bmN0aW9uIHV0ZjhlbmNvZGVcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVuY29kZS5cclxuICogQHJldHVybnMge251bWJlcltdfSBBbiBhcnJheSBvZiBVVEYtOCBjb2RlIHVuaXRzIGZvciB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcclxuXHR2YXIgY29kZVBvaW50cyA9IHN0cmluZ1RvVW5pY29kZUNvZGVQb2ludHMoc3RyaW5nKTtcclxuXHJcblx0Ly8gVVRGLTggaXMgYSB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcgdGhhdCBhY3R1YWxseSBzdXBwb3J0cyB1cCB0byBzaXggYnl0ZXMgcGVyIGNoYXJhY3Rlci5cclxuXHQvLyBIb3dldmVyLCB0aGVzZSBjaGFyYWN0ZXJzIGFyZSBpbiB0aGUgcHJpdmF0ZSB1bmljb2RlIHJhbmdlIGFuZCBjYW4gdGhlcmVmb3JlIG5ldmVyIG9jY3VyIGluIEphdmFTY3JpcHQuXHJcbiAgICB2YXIgdXRmOENvZGVVbml0cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgY29kZVBvaW50cy5sZW5ndGg7ICsraWR4KSB7XHJcbiAgICAgICAgdmFyIGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaWR4XTtcclxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgwMDgwKVxyXG4gICAgICAgICAgICB1dGY4Q29kZVVuaXRzLnB1c2goY29kZVBvaW50ICYgMHhGRik7XHJcbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDwgMHgwODAwKSB7XHJcbiAgICAgICAgICAgIHV0ZjhDb2RlVW5pdHMucHVzaCgweEMwICsgKGNvZGVQb2ludCA+Pj4gNikpO1xyXG4gICAgICAgICAgICB1dGY4Q29kZVVuaXRzLnB1c2goMHg4MCArIChjb2RlUG9pbnQgJiAweDNGKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcclxuICAgICAgICAgICAgdXRmOENvZGVVbml0cy5wdXNoKDB4ZTAgKyAoY29kZVBvaW50ID4+PiAxMikpO1xyXG4gICAgICAgICAgICB1dGY4Q29kZVVuaXRzLnB1c2goMHg4MCArICgoY29kZVBvaW50ID4+PiA2KSAmIDB4M2YpKTtcclxuICAgICAgICAgICAgdXRmOENvZGVVbml0cy5wdXNoKDB4ODAgKyAoY29kZVBvaW50ICYgMHgzZikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXRmOENvZGVVbml0cy5wdXNoKDB4ZjAgKyAoY29kZVBvaW50ID4+PiAxOCkpO1xyXG4gICAgICAgICAgICB1dGY4Q29kZVVuaXRzLnB1c2goMHg4MCArICgoY29kZVBvaW50ID4+PiAxMikgJiAweDNmKSk7XHJcbiAgICAgICAgICAgIHV0ZjhDb2RlVW5pdHMucHVzaCgweDgwICsgKChjb2RlUG9pbnQgPj4+IDYpICYgMHgzZikpO1xyXG4gICAgICAgICAgICB1dGY4Q29kZVVuaXRzLnB1c2goMHg4MCArIChjb2RlUG9pbnQgJiAweDNmKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHV0ZjhDb2RlVW5pdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgZ2l2ZW4gc2VyaWVzIG9mIFVURi04IGNvZGUgdW5pdHMgaW50byBhIHN0cmluZy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGZ1bmN0aW9uIHV0ZjhkZWNvZGVcclxuICogQHBhcmFtIHtudW1iZXJbXX0gdXRmOENvZGVVbml0cyBUaGUgVVRGLTggY29kZSB1bml0cy5cclxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gdXRmOGRlY29kZSh1dGY4Q29kZVVuaXRzKSB7XHJcblx0dmFyIGNvZGVQb2ludHMgPSAgW107XHJcblx0dmFyIGlkeCA9IDA7XHJcblx0d2hpbGUgKGlkeCA8IHV0ZjhDb2RlVW5pdHMubGVuZ3RoKSB7XHJcblx0XHR2YXIgY29kZVVuaXQgPSB1dGY4Q29kZVVuaXRzW2lkeF07XHJcblx0XHQvLyBXZSBpZ25vcmUgZml2ZSBhbmQgc2l4IGJ5dGUgY2hhcmFjdGVycyFcclxuXHRcdGlmIChjb2RlVW5pdCA+IDB4ZWYgJiYgY29kZVVuaXQgPCAweGY4KSB7XHJcblx0XHRcdGNvZGVQb2ludHMucHVzaCgodXRmOENvZGVVbml0c1tpZHhdIC0gMHhmMCA8PCAxOCkgKyAodXRmOENvZGVVbml0c1tpZHggKyAxXSAtIDB4ODAgPDwgMTIpICsgKHV0ZjhDb2RlVW5pdHNbaWR4ICsgMl0gLSAweDgwIDw8IDYpICsgKHV0ZjhDb2RlVW5pdHNbaWR4ICsgM10gLSAweDgwKSk7XHJcblx0XHRcdGlkeCArPSA0O1xyXG5cdFx0fSBlbHNlIGlmIChjb2RlVW5pdCA+IDB4ZGYgJiYgY29kZVVuaXQgPCAweGYwKSB7XHJcblx0XHRcdGNvZGVQb2ludHMucHVzaCgodXRmOENvZGVVbml0c1tpZHhdIC0gMHhlMCA8PCAxMikgKyAodXRmOENvZGVVbml0c1tpZHggKyAxXSAtIDB4ODAgPDwgNikgKyAodXRmOENvZGVVbml0c1tpZHggKyAyXSAtIDB4ODApKTtcclxuXHRcdFx0aWR4ICs9IDM7XHJcblx0XHR9IGVsc2UgaWYgKGNvZGVVbml0ID4gMHhiZiAmJiBjb2RlVW5pdCA8IDB4ZTApIHtcclxuXHRcdFx0Y29kZVBvaW50cy5wdXNoKCh1dGY4Q29kZVVuaXRzW2lkeF0gLSAweGMwIDw8IDYpICsgKHV0ZjhDb2RlVW5pdHNbaWR4ICsgMV0gLSAweDgwKSk7XHJcblx0XHRcdGlkeCArPSAyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHV0ZjhDb2RlVW5pdHNbaWR4XSk7XHJcblx0XHRcdGlkeCArPSAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHVuaWNvZGVDb2RlUG9pbnRzVG9TdHJpbmcoY29kZVBvaW50cyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzaXplIGluIGJ5dGVzIG5lZWRlZCB0byB3cml0ZSB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggdGhlIGdpdmVuIGVuY29kaW5nIGludG8gYSBidWZmZXIuXHJcbiAqIEN1cnJlbnRseSBvbmx5IEFTQ0lJIGFuZCBVVEYtOCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQGZ1bmN0aW9uIGJ5dGVTaXplRm9yU3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBzaXplLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nID0gXCJVVEYtOFwiXSBUaGUgZW5jb2RpbmcgdG8gdXNlLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc2l6ZSBpbiBieXRlcyBuZWVkZWQgdG8gc3RvcmUgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgZ2l2ZW4gZW5jb2RpbmcuXHJcbiAqL1xyXG5leHBvcnRzLmJ5dGVTaXplRm9yU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZywgZW5jb2RpbmcpIHtcclxuXHR2YXIgY29kZVBvaW50cyA9IHN0cmluZ1RvVW5pY29kZUNvZGVQb2ludHMoc3RyaW5nKTtcclxuXHRlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcudG9Mb3dlckNhc2UoKSA6IFwidXRmLThcIjtcclxuXHJcblx0c3dpdGNoIChlbmNvZGluZykge1xyXG5cdFx0Y2FzZSBcImFzY2lpXCI6XHJcblx0XHRcdHJldHVybiBjb2RlUG9pbnRzLmxlbmd0aDtcclxuXHRcdGNhc2UgXCJ1dGY4XCI6XHJcblx0XHRjYXNlIFwidXRmLThcIjpcclxuXHRcdFx0cmV0dXJuIGNvZGVQb2ludHMucmVkdWNlKGZ1bmN0aW9uIChieXRlU2l6ZSwgY29kZVBvaW50KSB7XHJcblx0XHRcdFx0cmV0dXJuIGJ5dGVTaXplICsgKGNvZGVQb2ludCA8IDB4MDA4MCA/IDEgOiAoY29kZVBvaW50IDwgMHgwODAwID8gMiA6IChjb2RlUG9pbnQgPCAweDEwMDAwID8gMyA6IDQpKSk7XHJcblx0XHRcdH0sIDApO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgdGhlIGdpdmVuIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZW5jb2RpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgaW50byB0aGUgYnVmZmVyLlxyXG4gKiBJZiBsaXR0bGVFbmRpYW4gaXMgdHJ1ZSwgbXVsdGktYnl0ZSB2YWx1ZXMgd2lsbCBiZSB3cml0dGVuIGluIGxpdHRsZUVuZGlhbiBmb3JtYXQuXHJcbiAqIEN1cnJlbnRseSBvbmx5IEFTQ0lJIGFuZCBVVEYtOCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQgd2hpY2ggbWFrZXMgZW5kaWFubmVzcyBhIG5vbiBpc3N1ZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAZnVuY3Rpb24gc2V0U3RyaW5nXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld30gYXJyYXlCdWZmZXIgVGhlIGJ1ZmZlciB3aGVyZSB0aGUgc3RyaW5nIHNob3VsZCBiZSB3cml0dGVuIGludG8uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBpbiBieXRlcyBhdCB3aGljaCB0aGUgc3RyaW5nIHNob3VsZCBiZWdpbiBpbnNpZGUgdGhlIGJ1ZmZlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHdyaXRlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nID0gXCJVVEYtOFwiXSBUaGUgZW5jb2RpbmcgdG8gdXNlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsaXR0bGVFbmRpYW4gPSBmYWxzZV0gSWYgdHJ1ZSBmb3IgbXVsdGkgYnl0ZSBjaGFyYWN0ZXJzIHdpbGwgYmUgd3JpdHRlbiBpbiBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cclxuICovXHJcbmV4cG9ydHMuc2V0U3RyaW5nID0gZnVuY3Rpb24gKGFycmF5QnVmZmVyLCBvZmZzZXQsIHN0cmluZywgZW5jb2RpbmcsIGxpdHRsZUVuZGlhbikge1xyXG4gICAgdmFyIGJ5dGVzID0gdG9VaW50OEFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQpO1xyXG5cdGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZy50b0xvd2VyQ2FzZSgpIDogXCJ1dGYtOFwiO1xyXG5cclxuXHRzd2l0Y2ggKGVuY29kaW5nKSB7XHJcblx0XHRjYXNlIFwiYXNjaWlcIjpcclxuXHRcdFx0Ynl0ZXMuc2V0KHN0cmluZ1RvVW5pY29kZUNvZGVQb2ludHMoc3RyaW5nKS5tYXAoZnVuY3Rpb24gKGNvZGVQb2ludCkgeyByZXR1cm4gY29kZVBvaW50ICUgMTI4OyB9KSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBcInV0ZjhcIjpcclxuXHRcdGNhc2UgXCJ1dGYtOFwiOlxyXG5cdFx0XHRieXRlcy5zZXQodXRmOGVuY29kZShzdHJpbmcpKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gdGhlIGdpdmVuIGJ1ZmZlciBhdCB0aGUgY2hvc2VuIG9mZnNldC5cclxuICogVGhlIHN0cmluZyB3aWxsIGJlIHdyaXR0ZW4gdXNpbmcgQVNDSUkgZW5jb2RpbmcgYW5kIHN1Y2NlZWRlZCBieSBhIE5VTCBieXRlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBmdW5jdGlvbiBzZXRDU3RyaW5nXHJcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgaW4gYnl0ZXMgZm9yIHRoZSBzdHJpbmcgdG8gYmVnaW4gaW5zaWRlIHRoZSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB3cml0ZS5cclxuICovXHJcbmV4cG9ydHMuc2V0Q1N0cmluZyA9IGZ1bmN0aW9uKGFycmF5QnVmZmVyLCBvZmZzZXQsIHN0cmluZykge1xyXG4gICAgdmFyIGxhc3RDaGFyYWN0ZXJJZHggPSBvZmZzZXQgKyB0aGlzLmJ5dGVTaXplRm9yU3RyaW5nKHN0cmluZywgXCJhc2NpaVwiKTtcclxuICAgIHRoaXMuc2V0U3RyaW5nKGFycmF5QnVmZmVyLCBvZmZzZXQsIHN0cmluZywgXCJhc2NpaVwiKTtcclxuICAgIHZhciBieXRlcyA9IHRvVWludDhBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0KTtcclxuXHRieXRlc1tsYXN0Q2hhcmFjdGVySWR4XSA9IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgdGhlIGdpdmVuIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBidWZmZXIgc3RhcnRpbmcgYXQgb2Zmc2V0LCByZWFkaW5nIGxlbmd0aCBieXRlcywgdXNpbmcgdGhlIHNwZWNpZmllZCBlbmNvZGluZy5cclxuICogSWYgbGl0dGxlRW5kaWFuIGlzIHRydWUsIG11bHRpLWJ5dGUgdmFsdWVzIGFyZSBleHBlY3RlZCB0byBiZXcgaW4gbGl0dGxlRW5kaWFuIGZvcm1hdC5cclxuICogQ3VycmVudGx5IG9ubHkgQVNDSUkgYW5kIFVURi04IGVuY29kaW5nIGlzIHN1cHBvcnRlZCB3aGljaCBtYWtlcyBlbmRpYW5uZXNzIGEgbm9uIGlzc3VlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBmdW5jdGlvbiBnZXRTdHJpbmdcclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBidWZmZXIgdG8gcmVhZCBmcm9tLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgaW4gYnl0ZXMgYXQgd2hpY2ggdG8gc3RhcnQgcmVhZGluZy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBUaGUgZW5jb2Rpbmcgb2YgdGhlIHN0cmluZy5cclxuICogQHBhcmFtIHtib29sZWFufSBbbGl0dGxlRW5kaWFuID0gZmFsc2VdIElmIHRydWUgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzIGFyZSBleHBlY3RlZCB0byBiZSBpbiBsaXR0bGUgZW5kaWFuIGZvcm1hdC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0cy5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuKSB7XHJcblx0Ly8gQ2hlY2sgaWYgbGVuZ3RoIGlzIG9taXR0ZWQgYW5kIGVuY29kaW5nIGlzIHNldC5cclxuXHRpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0ZW5jb2RpbmcgPSBsZW5ndGg7XHJcblx0XHRsZW5ndGggPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcudG9Mb3dlckNhc2UoKSA6IFwidXRmLThcIjtcclxuXHJcblx0dmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodG9VaW50OEFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGxlbmd0aCkpO1xyXG5cclxuXHRzd2l0Y2ggKGVuY29kaW5nKSB7XHJcblx0XHRjYXNlIFwiYXNjaWlcIjpcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMubWFwKGZ1bmN0aW9uIChieXRlKSB7IHJldHVybiBieXRlICUgMTI4OyB9KSk7XHJcblx0XHRjYXNlIFwidXRmOFwiOlxyXG5cdFx0Y2FzZSBcInV0Zi04XCI6XHJcblx0XHRcdHJldHVybiB1dGY4ZGVjb2RlKGJ5dGVzKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBOVUwgdGVybWluYXRlZCBBU0NJSSBlbmNvZGVkIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBidWZmZXIgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIG9mZnNldC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAZnVuY3Rpb24gZ2V0Q1N0cmluZ1xyXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld3xBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBpbiBieXRlcyB0byBzdGFydCByZWFkaW5nLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyBUaGUgcmVhZCBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnRzLmdldENTdHJpbmcgPSBmdW5jdGlvbiAoYXJyYXlCdWZmZXIsIG9mZnNldCkge1xyXG5cdHZhciBieXRlcyA9IHRvVWludDhBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0KTtcclxuXHJcbiAgICB2YXIgYXNjaWlDb2RlVW5pdHMgPSBbXTtcclxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGJ5dGVzLmJ5dGVMZW5ndGg7ICsraWR4KSB7XHJcbiAgICAgICAgdmFyIGMgPSBieXRlc1tpZHhdO1xyXG4gICAgICAgIGlmIChjID09PSAweDAwKVxyXG4gICAgICAgICAgICBicmVhaztcclxuXHQgICAgYXNjaWlDb2RlVW5pdHMucHVzaChjKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFzY2lpQ29kZVVuaXRzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIEFycmF5QnVmZmVyIGZpbGxlZCB3aXRoIHRoZSBnaXZlbiBzdHJpbmcuXHJcbiAqIFRoZSBzdHJpbmcgd2lsbCBiZSBBU0NJSSBlbmNvZGVkIGFuZCBzdWNjZWVkZWQgYnkgYSBOVUwgY2hhcmFjdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgZm9yIHdoaWNoIGEgYnVmZmVyIHNob3VsZCBiZSBjcmVhdGVkLlxyXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0cy5idWZmZXJGb3JDU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG5cdC8vIEFkZCBvbmUgYnl0ZSBmb3IgdGhlIE5VTCBjaGFyYWN0ZXJcclxuXHR2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnl0ZVNpemVGb3JTdHJpbmcoc3RyaW5nLCBcImFzY2lpXCIpICsgMSk7XHJcblx0dGhpcy5zZXRDU3RyaW5nKGJ1ZmZlciwgMCwgc3RyaW5nKTtcclxuXHRyZXR1cm4gYnVmZmVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gQXJyYXlCdWZmZXIgZmlsbGVkIHdpdGggdGhlIGdpdmVuIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZW5jb2RpbmcuXHJcbiAqIElmIGxpdHRsZUVuZGlhbiBpcyB0cnVlLCBtdWx0aS1ieXRlIHZhbHVlcyB3aWxsIGJlIHdyaXR0ZW4gaW4gbGl0dGxlRW5kaWFuIGZvcm1hdC5cclxuICogQ3VycmVudGx5IG9ubHkgQVNDSUkgYW5kIFVURi04IGVuY29kaW5nIGlzIHN1cHBvcnRlZCB3aGljaCBtYWtlcyBlbmRpYW5uZXNzIGEgbm9uIGlzc3VlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBmdW5jdGlvbiBidWZmZXJGb3JTdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGZvciB3aGljaCBhIGJ1ZmZlciBzaG91bGQgYmUgY3JlYXRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFRoZSBlbmNvZGluZyB0byB1c2UuXHJcbiAqIEBwYXJhbSB7Ym9vbH0gW2xpdHRsZUVuZGlhbiA9IGZhbHNlXSBJZiB0cnVlIG11bHRpLWJ5dGUgY2hhcmFjdGVycyB3aWxsIGJlIHdyaXR0ZW4gaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXHJcbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gQW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgZ2l2ZW4gc3RyaW5nLlxyXG4gKi9cclxuZXhwb3J0cy5idWZmZXJGb3JTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuKSB7XHJcblx0dmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ5dGVTaXplRm9yU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpKTtcclxuICAgIHRoaXMuc2V0U3RyaW5nKGJ1ZmZlciwgMCwgc3RyaW5nLCBlbmNvZGluZywgbGl0dGxlRW5kaWFuKTtcclxuICAgIHJldHVybiBidWZmZXI7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiB3b3JrZXIoKSB7XG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZG93bmxvYWREZWNvZGluZ0Z1bmN0aW9uYWxpdHkoZXZlbnQuZGF0YS5kZWNvZGluZ1NwZWNpZmljYXRpb24pO1xuICAgICAgICBkZWNvZGVEYXRhKGV2ZW50LmRhdGEuYnVmZmVyLCBldmVudC5kYXRhLmxpdHRsZUVuZGlhbik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBkb3dubG9hZERlY29kaW5nRnVuY3Rpb25hbGl0eSh1cmwpIHtcbiAgICAgICAgc2VsZi5tb2R1bGUgPSB7fTtcbiAgICAgICAgc2VsZi5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuICAgICAgICBzZWxmLmV4cG9ydHMgPSBzZWxmLm1vZHVsZS5leHBvcnRzO1xuXG4gICAgICAgIGltcG9ydFNjcmlwdHModXJsKTtcbiAgICAgICAgdmFyIGRlY29kaW5nRnVuY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIGRlY29kaW5nRnVuY3Rpb24gPSBzZWxmLm1vZHVsZS5leHBvcnRzO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIGRlY29kaW5nRnVuY3Rpb24gPSBzZWxmLm1vZHVsZS5leHBvcnRzLmRlY29kZTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlY29kZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgZGVjb2RpbmdGdW5jdGlvbiA9IGRlY29kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgZGVjb2RpbmcgZnVuY3Rpb25cIik7XG4gICAgICAgIHNlbGYuZGVjb2RpbmdGdW5jdGlvbiA9IHdyYXBwRGVjb2RpbmdGdW5jdGlvbihkZWNvZGluZ0Z1bmN0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cmFwcERlY29kaW5nRnVuY3Rpb24oZGVjb2RpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgYXJpdHkgPSBkZWNvZGluZ0Z1bmN0aW9uLmxlbmd0aDtcbiAgICAgICAgLy8gVmFyaWFibGUgYXJndW1lbnQgbGlzdCBtZWFucyB3ZSBjb25zaWRlciB0aGlzIGZ1bmN0aW9uIHRvIGJlIGFzeW5jLiBhbmQgdG8gZXhwZWN0XG4gICAgICAgIC8vIGFuIEFycmF5QnVmZmVyLCBvZmZzZXQsIGxlbmd0aCBhbmQgZW5kaWFubmVzcyBhcyBwYXJhbWV0ZXIuXG4gICAgICAgIGlmIChhcml0eSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGluZ0Z1bmN0aW9uO1xuICAgICAgICAvLyBBbiBhcml0eSBvZiB0d28gbWVhbnMgd2UgaGF2ZSBhIHN5bmMuIGZ1bmN0aW9uIHRha2luZyBhIERhdGFWaWV3IGFuZCB0aGUgZW5kaWFubmVzcy5cbiAgICAgICAgaWYgKGFyaXR5ID09PSAyKVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChidWZmZXIsIGxpdHRsZUVuZGlhbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVjb2RpbmdGdW5jdGlvbihidWZmZXIsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAoYXJpdHkgPT09IDMpXG4gICAgICAgICAgICByZXR1cm4gIGRlY29kaW5nRnVuY3Rpb247XG5cbiAgICAgICAgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGRlY29kaW5nIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZURhdGEoYnVmZmVyLCBsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgc2VsZi5kZWNvZGluZ0Z1bmN0aW9uKGJ1ZmZlciwgbGl0dGxlRW5kaWFuLCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gRGVjb2RpbmdXb3JrZXJQb29sKHBvb2xTaXplKSB7XG4gICAgdGhpcy5fcG9vbFNpemUgPSBwb29sU2l6ZSB8fCA0O1xuICAgIHRoaXMuX3Bvb2wgPSBbXTtcbiAgICB0aGlzLl90YXNrUXVldWUgPSBbXTtcblxuICAgIHRoaXMuX2ZpbGxQb29sKCk7XG59XG5cbkRlY29kaW5nV29ya2VyUG9vbC5wcm90b3R5cGUuc2NoZWR1bGVUYXNrID0gZnVuY3Rpb24gKGRlY29kaW5nVGFzaywgY2FsbGJhY2spIHtcbiAgICB0aGlzLl90YXNrUXVldWUucHVzaCh7XG4gICAgICAgIGRlY29kaW5nVGFzazogZGVjb2RpbmdUYXNrLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbn07XG5cbkRlY29kaW5nV29ya2VyUG9vbC5wcm90b3R5cGUuX3Byb2Nlc3NRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcG9vbC5sZW5ndGggPT09IDAgfHwgdGhpcy5fdGFza1F1ZXVlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHRhc2tJbmZvID0gdGhpcy5fdGFza1F1ZXVlLnNoaWZ0KCk7XG4gICAgdmFyIHdvcmtlciA9IHRoaXMuX3Bvb2wuc2hpZnQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNlbGYuX3Bvb2wucHVzaCh0aGlzKTtcbiAgICAgICAgdGFza0luZm8uY2FsbGJhY2sobnVsbCwgZXZlbnQuZGF0YSk7XG4gICAgICAgIHNlbGYuX3Byb2Nlc3NRdWV1ZSgpO1xuICAgIH07XG5cbiAgICB3b3JrZXIub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzZWxmLl9wb29sLnB1c2godGhpcyk7XG4gICAgICAgIHRhc2tJbmZvLmNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2VsZi5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfTtcblxuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh0YXNrSW5mby5kZWNvZGluZ1Rhc2ssIFt0YXNrSW5mby5kZWNvZGluZ1Rhc2suYnVmZmVyXSk7XG59O1xuXG5EZWNvZGluZ1dvcmtlclBvb2wucHJvdG90eXBlLl9maWxsUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Bvb2xTaXplOyArK2kpXG4gICAgICAgIHRoaXMuX3Bvb2wucHVzaCh0aGlzLl9jcmVhdGVXb3JrZXIoKSk7XG59O1xuXG5EZWNvZGluZ1dvcmtlclBvb2wucHJvdG90eXBlLl9jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0ciA9IHdvcmtlci50b1N0cmluZygpICsgXCJcXG53b3JrZXIoKTtcIjtcbiAgICByZXR1cm4gbmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtzdHJdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwifSApKSk7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEZWNvZGluZ1dvcmtlclBvb2w7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBEZWNvZGluZ1dvcmtlclBvb2wgPSByZXF1aXJlKFwiLi9kZWNvZGluZ193b3JrZXJfcG9vbFwiKTtcclxuXHJcbnZhciBwb29sID0gbmV3IERlY29kaW5nV29ya2VyUG9vbCgpO1xyXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVjb2RpbmdTcGVjaWZpY2F0aW9uLCBidWZmZXIsIGxpdHRsZUVuZGlhbiwgY2FsbGJhY2spIHtcclxuICAgIHBvb2wuc2NoZWR1bGVUYXNrKHtcclxuICAgICAgICBkZWNvZGluZ1NwZWNpZmljYXRpb246IGRlY29kaW5nU3BlY2lmaWNhdGlvbixcclxuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcclxuICAgICAgICBsaXR0bGVFbmRpYW46IGxpdHRsZUVuZGlhblxyXG4gICAgfSwgY2FsbGJhY2spXHJcbn07XHJcblxyXG4iLCIvLyAjIENodW5rXG5cbi8vIEEgYGNodW5rYCBpcyBhbiBpbmRlcGVuZGVudCBwYXJ0IG9mIGEgYmxhc3Qgc3RyZWFtIHRoYXQgY2FuIGJlIHByb2Nlc3NlZCBieSB0aGUgY2xpZW50IGluZGl2aWR1YWxseSBhbmQgd2l0aG91dFxuLy8gYW55IGluZm9ybWF0aW9uIG9mIG90aGVyIGNodW5rcyBpbiB0aGUgc3RyZWFtIGV4Y2VwdCBmb3IgdGhlIHByZWFtYmxlLlxuLy8gQSBgY2h1bmtgIG1heSBjb250YWluIG11bHRpcGxlIGVuY29kZWRWYWx1ZXMgZnJvbSB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuLy8gSG93ZXZlciwgaXQgd2lsbCBuZXZlciBjb250YWluIHBhcnRpYWxsIGRhdGEgc3VjaCB0aGF0IGFub3RoZXIgYGNodW5rYCBpcyBuZWNlc3NhcnkgdG8gZGVjb2RlIGEgdmFsdWUuXG5cbi8vICMjIFN0cnVjdHVyZVxuXG4vLyBBIGNodW5rIGhhcyB0aGUgZm9sbG93aW5nIGJpbmFyeSBzdHJ1Y3R1cmUuXG4vL1xuLy8gT2N0ZXRzIDAtLTM6IE92ZXJhbGwgY2h1bmtzIHNpemUgKE9DUykuXG4vLyBPY3RldHMgNC0tNzogSGVhZGVyIGRlZmluaXRpb24gc2l6ZSAoSFMpLlxuLy8gT2N0ZXRzIDgtLTgrPEhTPjogRGVmaW5pdGlvbnMgb2YgdGhlIHBheWxvYWQgaW4gdGhpcyBjaHVuay5cbi8vIE9jdGV0czogOSs8SFM+LS08T0NTPjogUGF5bG9hZC5cblxuLy8gIyMjIEhlYWRlciBkZWZpbml0aW9uXG5cbi8vIEEgY2h1bmtzIGhlYWRlciBkZWZpbml0aW9uIGlzIGFuIGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbi8vIEluIEphdmFTY3JpcHQgdGhpcyBzaW1wbHkgbWFwcyB0byBvYmplY3RzLlxuLy8gVGhlIGhlYWRlciBkZWZpbml0aW9uIG9mIGVhY2ggY2h1bmsgaXMgZW5jb2RlZCBhbmQgY2FuIGJlIGRlY29kZWQgdXNpbmcgdGhlIHByb2NlZHVyZVxuLy8gc3BlY2lmaWVkIGluIHRoZSBwcmVhbWJsZSBvZiB0aGUgc3RyZWFtLlxuLy8gRWFjaCBkZWZpbml0aW9uIGlzIHN0cnVjdHVyZWQgYXMgZm9sbG93czpcblxuLy8gLSBwYXRoOiBBIEpQYXRoIHNwZWNpZnlpbmcgdGhlIG9yaWdpbmFsIHBhdGggb2YgdGhlIHZhbHVlIGluIHRoZVxuLy8gLSBvZmZzZXQ6IEJ5dGUgb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgY2h1bmsncyBwYXlsb2FkIHdoZXJlIHRoZSBlbmNvZGVkIGRhdGEgc3RhcnRzLlxuLy8gLSBzaXplOiBCeXRlIGxlbmd0aCBvZiB0aGUgZW5jb2RlZCBkYXRhLlxuLy8gLSBkZWNvZGluZ1NwZWNpZmljYXRpb246IEEgVVJMIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgZGVjb2RpbmcgcHJvY2VkdXJlIG5lY2Vzc2FyeSB0byBkZWNvZGUgdGhlIGRhdGFcbi8vIGRlZmluZWQgaW4gdGhpcyBlbnRyeS5cbi8vIC0gbWV0YWRhdGE6IFBvc3NpYmxlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHZhbHVlLlxuXG4vLyAjIyMgUGF5bG9hZFxuXG4vLyBBIGNodW5rcyBwYXlsb2FkIGlzIGEgZmxhdCBgQXJyYXlCdWZmZXJgIG9mIGFyYml0cmFyeSBzaXplLlxuLy8gSXQgY29udGFpbnMgYWxsIGVuY29kZWREYXRhIHNwZWNpZmllZCBpbiB0aGUgaGVhZGVyIGRlZmluaXRpb25zLlxuLy8gVGhlIHNpemUgb2YgZWFjaCBjaHVuaydzIHBheWxvYWQgY2FuIGJlIGNhbGN1bGF0ZWQgYXM6XG4vLyA8T0NTPi05KzxIUz4uXG5cbi8vICMjIyBTaWduYWwgRW5kIE9mIFN0cmVhbVxuXG4vLyBBIHNwZWNpYWwgY2h1bmssIHRoZSBzaWduYWwgZW5kIG9mIHN0cmVhbSBjaHVuaywgY29udGFpbnMgbm8gcGF5bG9hZCBhbmQgdGh1cyBubyBoZWFkZXIgZGVmaW5pdGlvbnMuXG4vLyBUaGlzIGNodW5rIHNpZ25hbHMgdGhlIHJlY2VpdmVyIHRoZSBlbmQgb2YgdGhlIHN0cmVhbS5cbi8vIEl0IGlzIHRoZXJlZm9yZSBub3QgdmFsaWQgdG8gY2FsbCBhIGNodW5rcyB0b0J1ZmZlciBtZXRob2QgaWYgbm8gcGF5bG9hZCB3YXMgYWRkZWQgYmVmb3JlaGFuZC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBCbGFzdEVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbi8vIENvbnN0cnVjdHMgYSBuZXcgY2h1bmsgdGhhdCBjYW4gYmUgZmlsbGVkIHdpdGggZGF0YS5cbi8vIEEgbmV3bHkgY29uc3RydWN0ZWQgY2h1bmsgd2lsbCBoYXZlIGEgcGF5bG9hZCBvZiBzaXplIDAgYW5kIGEgaGVhZGVyIGRlZmluaXRpb24gc2l6ZSBvZiAwLlxuLy8gSXQgaXMgaW52YWxpZCB0byBjYWxsIHRvQnVmZmVyIG9uIGEgZnJlc2ggY2h1bmshXG5mdW5jdGlvbiBDaHVuaygpIHtcbiAgICB0aGlzLl9oZWFkZXJEZWZpbml0aW9ucyA9IFtdO1xuXG4gICAgdGhpcy5fcGF5bG9hZCA9IFtdO1xuICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaHVuay5wcm90b3R5cGUsIHtcbiAgICBwYXlsb2FkOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wYXlsb2FkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwYXlsb2FkU2l6ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50T2Zmc2V0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoZWFkZXJEZWZpbml0aW9uczoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJEZWZpbml0aW9ucztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vL0FkZHMgdGhlIGdpdmVuIHBheWxvYWQgdG8gdGhlIGNodW5rLlxuLy8gQSBoZWFkZXIgZGVmaW5pdGlvbiBlbnRyeSB3aWxsIGJlIGdlbmVyYXRlZCB3aXRoIHRoZSBnaXZlbiBwYXRoLCB0aGUgZGVjb2RpbmdTcGVjaWZpY2F0aW9uIGFuZCBtZXRhZGF0YS5cbkNodW5rLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZW5jb2RlZERhdGEpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW5jb2RlZERhdGEuZW5jb2RlZFZhbHVlKSlcbiAgICAgICAgZW5jb2RlZERhdGEuZW5jb2RlZFZhbHVlID0gW2VuY29kZWREYXRhLmVuY29kZWRWYWx1ZV07XG5cbiAgICBlbmNvZGVkRGF0YS5lbmNvZGVkVmFsdWUgPSBlbmNvZGVkRGF0YS5lbmNvZGVkVmFsdWUubWFwKGZ1bmN0aW9uICh0eXBlZEFycmF5T3JCdWZmZXIpIHtcbiAgICAgICAgIGlmICh0eXBlZEFycmF5T3JCdWZmZXIuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlPckJ1ZmZlci5idWZmZXI7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVkQXJyYXlPckJ1ZmZlcjtcbiAgICB9KTtcblxuICAgIHZhciBzaXplID0gZW5jb2RlZERhdGEuZW5jb2RlZFZhbHVlLnJlZHVjZShmdW5jdGlvbiAoY3VycmVudFNpemUsIGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gY3VycmVudFNpemUgKyBsZW5ndGgoYnVmZmVyKTtcbiAgICB9LCAwKTtcblxuICAgIHRoaXMuX3BheWxvYWQgPSB0aGlzLl9wYXlsb2FkLmNvbmNhdChlbmNvZGVkRGF0YS5lbmNvZGVkVmFsdWUpO1xuICAgIHRoaXMuX2hlYWRlckRlZmluaXRpb25zLnB1c2goe1xuICAgICAgICBwYXRoOiBlbmNvZGVkRGF0YS5wYXRoLFxuICAgICAgICBvZmZzZXQ6IHRoaXMuX2N1cnJlbnRPZmZzZXQsXG4gICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgIGRlY29kaW5nU3BlY2lmaWNhdGlvbjogZW5jb2RlZERhdGEuZGVjb2RpbmdTcGVjaWZpY2F0aW9uLFxuICAgICAgICBtZXRhZGF0YTogZW5jb2RlZERhdGEubWV0YWRhdGFcbiAgICB9KTtcbiAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ICs9IHNpemU7XG59O1xuXG5mdW5jdGlvbiBsZW5ndGgoYnVmZmVyKSB7XG5cdHJldHVybiB0eXBlb2YgYnVmZmVyLmJ5dGVMZW5ndGggIT09IFwidW5kZWZpbmVkXCIgPyBidWZmZXIuYnl0ZUxlbmd0aCA6IGJ1ZmZlci5sZW5ndGg7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENodW5rO1xuXG4iLCIvLyAjIENodW5rZXJcblxuLy8gVGhlIGBDaHVua2VyYCByZXByZXNlbnRzIHRoZSBzZWNvbmQgc3RlcCBpbiB0aGUgYmxhc3QgcGlwZWxpbmUgYW5kIGlzIGEgTm9kZUpTIHRyYW5zZm9ybSBzdHJlYW0uXG4vLyBJdCB0YWtlcyBlbmNvZGVkRGF0YSBhbmQgdHJhbnNmb3JtcyB0aGVtIGludG8gYmxhc3QgY2h1bmtzLlxuXG5cInVzZSBzdHJpY3RcIlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuVHJhbnNmb3JtO1xuXG52YXIgQ2h1bmsgPSByZXF1aXJlKFwiLi9jaHVua1wiKTtcbnZhciBjYWxsSW1tZWRpYXRlID0gcmVxdWlyZShcIi4vdXRpbC9jYWxsX2ltbWVkaWF0ZVwiKTtcblxuLy8gQ29uc3RydWN0cyBhIENodW5rZXIuXG4vLyBgY2h1bmtTaXplYCBtYXkgc3BlY2lmeSB0aGUgc2l6ZSBvZiBhIGNodW5rIGluIGJ5dGVzLlxuLy8gVGhpcyBzaXplLCBob3dldmVyLCBpcyBvbmx5IGEgc29mdGxpbWl0IGFuZCBjaHVua3MgbWF5IGNvbnRhaW4gbW9yZSBvciBsZXNzIGJ5dGVzIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZlxuLy8gaW5kaXZpZHVhbCB2YWx1ZXMuXG5mdW5jdGlvbiBDaHVua2VyKG9wdGlvbnMpIHtcblx0VHJhbnNmb3JtLmNhbGwodGhpcywge1xuXHRcdG9iamVjdE1vZGU6IHRydWVcblx0fSk7XG5cbiAgICB0aGlzLl9jaHVuayA9IG5ldyBDaHVuaygpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fY2h1bmtTaXplID0gb3B0aW9ucy5jaHVua1NpemUgfHwgKDEgPDwgMzApO1xuICAgIHRoaXMuX2FzeW5jID0gdHlwZW9mIG9wdGlvbnMuYXN5bmMgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmFzeW5jIDogdHJ1ZTtcbn1cblxudXRpbC5pbmhlcml0cyhDaHVua2VyLCBUcmFuc2Zvcm0pO1xuXG5DaHVua2VyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGVuY29kZWREYXRhLCBfLCBjYWxsYmFjaykge1xuICAgIGNhbGxJbW1lZGlhdGUodGhpcy5fYXBwZW5kVG9DaHVuay5iaW5kKHRoaXMsIGVuY29kZWREYXRhLCBjYWxsYmFjayksIHRoaXMuX2FzeW5jKTtcbn07XG5cbkNodW5rZXIucHJvdG90eXBlLl9hcHBlbmRUb0NodW5rID0gZnVuY3Rpb24gKGVuY29kZWREYXRhLCBjYWxsYmFjaykge1xuXHR0aGlzLl9jaHVuay5hZGQoZW5jb2RlZERhdGEpO1xuICAgIGlmICh0aGlzLl9jaHVuay5wYXlsb2FkU2l6ZSA+IHRoaXMuX2NodW5rU2l6ZSkge1xuICAgICAgICB0aGlzLnB1c2godGhpcy5fY2h1bmspO1xuICAgICAgICB0aGlzLl9jaHVuayA9IG5ldyBDaHVuaygpO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xufTtcblxuQ2h1bmtlci5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2NodW5rLnBheWxvYWRTaXplID4gMCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNhbGxJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5wdXNoKHNlbGYuX2NodW5rKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRoaXMuX2FzeW5jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENodW5rZXI7XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuVHJhbnNmb3JtO1xuXG52YXIgY2FsbEltbWVkaWF0ZSA9IHJlcXVpcmUoXCIuL3V0aWwvY2FsbF9pbW1lZGlhdGVcIik7XG5cbmZ1bmN0aW9uIERlY2h1bmtlcihvcHRpb25zKSB7XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywge1xuICAgICAgICBvYmplY3RNb2RlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuX2FzeW5jID0gdHlwZW9mIG9wdGlvbnMuYXN5bmMgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmFzeW5jIDogdHJ1ZTtcbn1cblxudXRpbC5pbmhlcml0cyhEZWNodW5rZXIsIFRyYW5zZm9ybSk7XG5cbkRlY2h1bmtlci5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgXywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY2FsbEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENodW5rcyBnZW5lcmF0ZWQgYnkgdGhlIGNodW5rZXIgaGF2ZSBhbiBhcnJheSBvZiBBcnJheUJ1ZmZlcnMgYXMgcGF5bG9hZC5cbiAgICAgICAgLy8gQ2h1bmtzIHJlY2VpdmVkIGJ5IHRoZSBzdHJlYW0gcmVjZWl2ZXIsIGhvd2V2ZXIsIG9ubHkgaGF2ZSBhIHNpbmdsZSBwYXlsb2FkIEFycmF5QnVmZmVyLlxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2h1bmsucGF5bG9hZCkpXG4gICAgICAgICAgICBjaHVuay5wYXlsb2FkID0gW2NodW5rLnBheWxvYWRdO1xuXG4gICAgICAgIGNodW5rLmhlYWRlckRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlckRlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBoZWFkZXJEZWZpbml0aW9uLm9mZnNldDtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBjaHVuay5wYXlsb2FkWzBdO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBidWZmZXIgZm9yIHRoZSBnaXZlbiBvZmZzZXRcbiAgICAgICAgICAgIHZhciBzaXplT2ZQcmV2aW91c0J1ZmZlcnMgPSBjaHVuay5wYXlsb2FkWzBdLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNodW5rLnBheWxvYWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDw9IHNpemVPZlByZXZpb3VzQnVmZmVycyArIGNodW5rLnBheWxvYWRbaV0uYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBjaHVuay5wYXlsb2FkW2ldO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgLSBzaXplT2ZQcmV2aW91c0J1ZmZlcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpemVPZlByZXZpb3VzQnVmZmVycyArPSBjaHVuay5wYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYnVmZmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmVtaXQoXCJlcm9yXCIsIG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgYnVmZmVyIGZvciB0aGUgZ2l2ZW4gb2Zmc2V0IVwiKSk7XG5cbiAgICAgICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlOiBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBoZWFkZXJEZWZpbml0aW9uLnNpemUpLFxuICAgICAgICAgICAgICAgIHBhdGg6IGhlYWRlckRlZmluaXRpb24ucGF0aCxcbiAgICAgICAgICAgICAgICBkZWNvZGluZ1NwZWNpZmljYXRpb246IGhlYWRlckRlZmluaXRpb24uZGVjb2RpbmdTcGVjaWZpY2F0aW9uLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBoZWFkZXJEZWZpbml0aW9uLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGxpdHRsZUVuZGlhbjogY2h1bmsubGl0dGxlRW5kaWFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSwgdGhpcy5fYXN5bmMpO1xufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRGVjaHVua2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xyXG5cclxuZnVuY3Rpb24gQmxhc3RFcnJvcihtZXNzYWdlLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcclxuXHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG59O1xyXG5cclxudXRpbC5pbmhlcml0cyhCbGFzdEVycm9yLCBFcnJvcik7XHJcblxyXG5CbGFzdEVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJCbGFzdCBFcnJvclwiO1xyXG5cclxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmxhc3RFcnJvcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5leHBvcnRzLk9iamVjdEVuY29kZXIgPSByZXF1aXJlKFwiLi9vYmplY3RfZW5jb2RlclwiKTtcclxuZXhwb3J0cy5DaHVua2VyID0gcmVxdWlyZShcIi4vY2h1bmtlclwiKTtcclxuZXhwb3J0cy5TdHJlYW1HZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9zdHJlYW1fZ2VuZXJhdG9yXCIpO1xyXG5leHBvcnRzLlN0cmVhbVJlY2VpdmVyID0gcmVxdWlyZShcIi4vc3RyZWFtX3JlY2VpdmVyXCIpO1xyXG5leHBvcnRzLkRlY2h1bmtlciA9IHJlcXVpcmUoXCIuL2RlY2h1bmtlclwiKTtcclxuZXhwb3J0cy5WYWx1ZURlY29kZXIgPSByZXF1aXJlKFwiLi92YWx1ZV9kZWNvZGVyXCIpO1xyXG5leHBvcnRzLk9iamVjdEFzc2VtYmxlciA9IHJlcXVpcmUoXCIuL29iamVjdF9hc3NlbWJsZXJcIik7XHJcblxyXG5leHBvcnRzLlByZWFtYmxlID0gcmVxdWlyZShcIi4vcHJlYW1ibGVcIik7XHJcbmV4cG9ydHMuQ2h1bmsgPSByZXF1aXJlKFwiLi9jaHVua1wiKTtcclxuXHJcbmV4cG9ydHMuRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcclxuXHJcbmV4cG9ydHMud3JhcFN5bmNGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL3V0aWwvd3JhcF9zeW5jX2Z1bmN0aW9uXCIpO1xyXG5leHBvcnRzLmlzTGl0dGxlRW5kaWFuQXJjaGl0ZWN0dXJlID0gcmVxdWlyZShcIi4vdXRpbC9pc19saXR0bGVfZW5kaWFuX2FyY2hpdGVjdHVyZVwiKTtcclxuIiwiKGZ1bmN0aW9uIChfX2Rpcm5hbWUpe1xuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgY2hpbGQgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcclxuXHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkZWNvZGluZ1NwZWNpZmljYXRpb24sIGJ1ZmZlciwgbGl0dGxlRW5kaWFuLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIGMgPSBjaGlsZC5mb3JrKF9fZGlybmFtZSArIFwiL2NoaWxkX21vZHVsZVwiKTtcclxuICAgIGMub24oXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcInJlc3VsdFwiOlxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbmV3IFVpbnQ4QXJyYXkobWVzc2FnZS5yZXN1bHQpLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgYy5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlcnJvcikge1xyXG5cdCAgICBjLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjLnNlbmQoe1xyXG4gICAgICAgIGRlY29kaW5nU3BlY2lmaWNhdGlvbjogZGVjb2RpbmdTcGVjaWZpY2F0aW9uLFxyXG4gICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxyXG5cdCAgICBsaXR0bGVFbmRpYW46IGxpdHRsZUVuZGlhblxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cbn0pLmNhbGwodGhpcyxcIi8uLi9ub2RlX21vZHVsZXMvYmxhc3QvbGliL25vZGVcIikiLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuVHJhbnNmb3JtO1xuXG52YXIganBhdGggPSByZXF1aXJlKFwianBhdGhcIik7XG5cbnZhciBjYWxsSW1tZWRpYXRlID0gcmVxdWlyZShcIi4vdXRpbC9jYWxsX2ltbWVkaWF0ZVwiKTtcblxuZnVuY3Rpb24gT2JqZWN0QXNzZW1ibGVyKG9wdGlvbnMpIHtcbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuX2RlY29kZWRPYmplY3QgPSB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuX2FzeW5jID0gdHlwZW9mIG9wdGlvbnMuYXN5bmMgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmFzeW5jIDogdHJ1ZTtcbn1cblxudXRpbC5pbmhlcml0cyhPYmplY3RBc3NlbWJsZXIsIFRyYW5zZm9ybSk7XG5cbk9iamVjdEFzc2VtYmxlci5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkZWNvZGVkRGF0YSwgXywgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY2FsbEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGpwYXRoLmV2YWx1YXRlKGRlY29kZWREYXRhLnBhdGgsIHNlbGYuX2RlY29kZWRPYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc1Jvb3QpXG4gICAgICAgICAgICAgICAgc2VsZi5fZGVjb2RlZE9iamVjdCA9IGRlY29kZWREYXRhLnZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGRlY29kZWREYXRhLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9LCB0aGlzLl9hc3luYyk7XG59O1xuXG5PYmplY3RBc3NlbWJsZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjYWxsSW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wdXNoKHNlbGYuX2RlY29kZWRPYmplY3QpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH0sIHRoaXMuX2FzeW5jKTtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdEFzc2VtYmxlcjtcbiIsIi8vICMgT2JqZWN0RW5jb2RlclxyXG5cclxuLy8gQW4gYE9iamVjdEVuY29kZXJgIGlzIGEgTm9kZUpTIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCB0cmFuc2Zvcm1zIGEgZ2l2ZW4gb2JqZWN0IHVzaW5nIHRoZSBzcGVjaWZpZWQgZW5jb2RlcnMuXHJcbi8vIEVuY29kZXJzIGFyZSBtYXBwZWQgdG8gdmFsdWVzIHVzaW5nIEpQYXRoIGV4cHJlc3Npb25zLlxyXG4vLyBgYGBqYXZhc2NyaXB0XHJcbi8vIHtcclxuLy9cdFx0cGF0aDogL3NlbGVjdG9yXHJcbi8vXHRcdGVuY29kZXI6IGVuY29kZXJGb3JWYWx1ZUF0UGF0aFxyXG4vLyB9XHJcbi8vIGBgYFxyXG4vLyBBbiBhcnJheSBvZiB0aGVzZSBtYXBwaW5ncyBpcyBwYXNzZWQgdG8gdGhlIHdyaXRlIGZ1bmN0aW9ucyBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4vLyBPbmx5IHZhbHVlcyB0aGF0IGFyZSBzZWxlY3RlZCBieSB0aGUgSlBhdGggZXhwcmVzc2lvbnMgYXJlIHRyYW5zZm9ybWVkLlxyXG4vLyBUaGUgcGF0aC1lbmNvZGVyIG1hcHBpbmcgY2FuIG9wdGlvbmFsbHkgaW5jbHVkZSBhbHNvIG1ldGFkYXRhIHRoYXQgaXMgbm90IGVuY29kZWQgdW5jb25kaXRpb25hbGx5XHJcbi8vIGZvcndhcmRlZCB0aHJvdWdoIHRoZSBzdHJlYW0uXHJcblxyXG5cclxuLy8gIyMgRW5jb2RlclxyXG5cclxuLy8gQW4gZW5jb2RlciBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIGludGVyZmFjZTpcclxuXHJcbi8vIC0gQSBmdW5jdGlvbiBgZW5jb2RlYCB0aGF0IGdpdmVuIGEgdmFsdWUgcmV0dXJucyBhbiBgQXJyYXlCdWZmZXJgLlxyXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSB2YWx1ZSB0byBlbmNvZGUgYW5kIGEgYm9vbGVhbiBzcGVjaWZ5aW5nIGlmIHRoZSByZXN1bHRpbmcgYnVmZmVyXHJcbi8vIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuIChgdHJ1ZWApIG9yIGJpZy1lbmRpYW4gKGBmYWxzZWApIGZvcm1hdC5cclxuLy8gRW5kaWFubmVzIGlzIHNwZWNpZmllZCB3aXRoIHVzaW5nIGEgYm9vbGVhbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBpbnRlcmZhY2Ugb2YgdGhlIERhdGFWaWV3IGluIHRoZVxyXG4vLyBUeXBlZEFycmF5IHNwZWNpZmljYXRpb24gYW5kIGNhbiBzYXZlbHkgYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYWxsIGBEYXRhVmlldyNnZXRgIGFuZCBgRGF0YVZpZXcjc2V0YCBtZXRob2RzLlxyXG4vLyBPcHRpb25hbGx5IHRoZSBmdW5jdGlvbiBjYW4gdGFrZSBhIHRoaXJkIGFyZ3VtZW50LCBhIGNhbGxiYWNrLCBpbiBjYXNlIHRoZSBlbmNvZGluZyBpcyBhc3luY2hyb25vdXMuXHJcbi8vIEFuIGBlbmNvZGVgIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhyZWUgb3IgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnQgaXMgY29uc2lkZXJlZCB0byBiZSBhc3luY2hyb25vdXMuXHJcbi8vIFRoZSBwcm92aWRlZCBjYWxsYmFjayBleHBlY3RzIHR3byBwYXJhbWV0ZXJzOlxyXG4vL1xyXG4vLyAxLiBBbiBlcnJvciBvYmplY3QgaW4gY2FzZSBhbnl0aGluZyB3ZW50IHdyb25nLlxyXG4vLyAyLiBUaGUgYEFycmF5QnVmZmVyYCBjb250YWluaW5nIHRoZSBlbmNvZGVkIHZhbHVlLlxyXG4vL1xyXG4vLyBJZiB0aGUgZnVuY3Rpb24gaXMgc3luY2hyb25vdXMsIGVycm9ycyBzaG91ZCBiZSByZXBvcnRlZCBieSB0aHJvd2luZyBhbiBleGNlcHRpb24uXHJcbi8vXHJcbi8vIC0gQSBwcm9wZXJ0eSBgZGVjb2RpbmdTcGVjaWZpY2F0aW9uYCB0aGF0IGNvbnRhaW5zIGEgVVJMIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgZGVjb2RpbmcgcHJvY2VkdXJlXHJcbi8vIG5lY2Vzc2FyeSB0byBkZWNvZGUgdGhlIG9yaWdpbmFsIGRhdGEgZnJvbSB0aGUgYEFycmF5QnVmZmVyYCByZXR1cm5lZCBieSB0aGUgYGVuY29kZWAgZnVuY3Rpb24uXHJcbi8vIFRoaXMgVVJMIG1heWJlIHF1ZXJpZWQgZm9yIGEgZGVjb2RpbmcgaW1wbGVtZW50YXRpb24gYXQgdGhlIGNsaWVudCBzaWRlIHVzaW5nIGFuIEhUVFAtR0VUIHJlcXVlc3RcclxuLy8gd2l0aCBhbiBhY2NlcHQtaGVhZGVyOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIi5cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcclxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcclxuXHJcbnZhciBhc3luYyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcclxudmFyIGpwYXRoID0gcmVxdWlyZShcImpwYXRoXCIpO1xyXG5cclxudmFyIGlzTGl0dGxlRW5kaWFuQXJjaGl0ZWN0dXJlID0gcmVxdWlyZShcIi4vdXRpbC9pc19saXR0bGVfZW5kaWFuX2FyY2hpdGVjdHVyZVwiKTtcclxudmFyIHdyYXBTeW5jRnVuY3Rpb24gPSByZXF1aXJlKFwiLi91dGlsL3dyYXBfc3luY19mdW5jdGlvblwiKTtcclxudmFyIGNhbGxJbW1lZGlhdGUgPSByZXF1aXJlKFwiLi91dGlsL2NhbGxfaW1tZWRpYXRlXCIpO1xyXG5cclxuLy8gQ3JlYXRlcyBhbiBPYmplY3RFbmNvZGVyIGluc3RhbmNlLlxyXG4vLyBJZiBsaXR0bGVFbmRpYW4gaXMgdW5kZWZpbmVkIHRoZSBjdXJyZW50IHN5c3RlbSBhcmNoaXRlY3R1cmUncyBlbmRpYW5uZXNzIHdpbGwgYmUgdXNlZC5cclxuLy8gVGhlIGdpdmVuIHZhbHVlIGZvciBsaXR0bGVFbmRpYW4gd2lsbCBiZSBmb3J3YXJkZWQgdG8gYWxsIGVuY29kZXJzLlxyXG5mdW5jdGlvbiBPYmplY3RFbmNvZGVyKG9wdGlvbnMpIHtcclxuXHRUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7XHJcblx0XHRvYmplY3RNb2RlOiB0cnVlXHJcblx0fSk7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgdGhpcy5fbGl0dGxlRW5kaWFuID0gdHlwZW9mIG9wdGlvbnMubGl0dGxlRW5kaWFuICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5saXR0bGVFbmRpYW4gOiBpc0xpdHRsZUVuZGlhbkFyY2hpdGVjdHVyZSgpO1xyXG4gICAgdGhpcy5fYXN5bmMgPSB0eXBlb2Ygb3B0aW9ucy5hc3luYyAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuYXN5bmMgOiB0cnVlO1xyXG59XHJcblxyXG51dGlsLmluaGVyaXRzKE9iamVjdEVuY29kZXIsIFRyYW5zZm9ybSk7XHJcblxyXG4vLyBTdGFydHMgdGhlIGVuY29kaW5nIG9mIHRoZSBnaXZlbiBvYmplY3QgY29uc2lkZXJpbmcgdGhlIGdpdmVuIHBhdGggZW5jb2RlciBtYXBwaW5ncy5cclxuLy8gV2UgZG8gbm90IHN0YXJ0IHRoZSBlbmNvZGluZyBwcm9jZXNzIGRpcmVjdGx5LCBidXQgZGVsYXkgZW5jb2RpbmcgdXNpbmcgc2V0SW1tZWRpYXRlLlxyXG4vLyBFbmNvZGluZyB3aWxsIHN0YXJ0IGFzIHNvb24gYXMgdGhlIFZNIGhhcyByZXRha2VuIGNvbnRyb2wgYW5kIGNvbXBsZXRlZCBvdGhlciBwZW5kaW5nIG9wZXJhdGlvbnMuXHJcbi8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIG1pbWljIHRoZSBiZWhhdmlvciBvZiBhbGwgTm9kZUpTIHN0cmVhbXMgdGhhdCBhcmUgYXN5bmNocm9ub3VzLlxyXG4vLyBUaGUgdXNlciBjYW4gbm93IHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBhZnRlciBjYWxsaW5nIHdyaXRlL2VuZCB3aXRob3V0IHJpc2tpbmcgdG9cclxuLy8gbWlzcyBldmVudHMgc2luY2UgdGhlIGFjdHVhbCBlbmNvZGluZyB3aWxsIHN0YXJ0IGFzIGVhcmx5IGFzIHRoZSB1c2VycyBjdXJyZW50IGNvbnRyb2wgZmxvdyBlbmRzLlxyXG5PYmplY3RFbmNvZGVyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKG9iamVjdFRvRW5jb2RlLCBzZWxlY3Rvck9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICBjYWxsSW1tZWRpYXRlKHRoaXMuX2VuY29kZS5iaW5kKHRoaXMsIG9iamVjdFRvRW5jb2RlLCBzZWxlY3Rvck9wdGlvbnMsIGNhbGxiYWNrKSwgdGhpcy5fYXN5bmMpO1xyXG59O1xyXG5cclxuT2JqZWN0RW5jb2Rlci5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIChvYmplY3RUb0VuY29kZSwgc2VsZWN0b3JPcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIHVubWF0Y2hlZFBhcnRzID0gb2JqZWN0VG9FbmNvZGU7XHJcbiAgICB2YXIgc2VsZWN0b3JPcHRpb25zQ291bnQgPSBzZWxlY3Rvck9wdGlvbnMubGVuZ3RoO1xyXG4gICAgdmFyIGN1cnJlbnRTZWxlY3RvcklkeCA9IDA7XHJcblx0YXN5bmMuZWFjaFNlcmllcyhzZWxlY3Rvck9wdGlvbnMsIGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIHJlc3VsdHMgPSBqcGF0aC5ldmFsdWF0ZShvcHRpb25zLnBhdGgsIHVubWF0Y2hlZFBhcnRzKVxyXG5cdFx0YXN5bmMuZWFjaChyZXN1bHRzLmRlZmluZWRSZXN1bHRzLCBmdW5jdGlvbiAocmVzdWx0LCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgZW5jb2RlciA9IG9wdGlvbnMuZW5jb2RlcjtcclxuXHRcdFx0d3JhcFN5bmNGdW5jdGlvbihlbmNvZGVyLmVuY29kZS5iaW5kKGVuY29kZXIpKShyZXN1bHQudmFsdWUsIHNlbGYuX2xpdHRsZUVuZGlhbiwgZnVuY3Rpb24gKGVycm9yLCBlbmNvZGVkVmFsdWUpIHtcclxuXHRcdFx0XHRpZiAoZXJyb3IpXHJcblx0XHRcdFx0XHRyZXR1cm4gc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xyXG5cdFx0XHRcdHNlbGYucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFZhbHVlOiBlbmNvZGVkVmFsdWUsXHJcblx0XHRcdFx0XHRwYXRoOiByZXN1bHQucGF0aCxcclxuXHRcdFx0XHRcdGRlY29kaW5nU3BlY2lmaWNhdGlvbjogZW5jb2Rlci5kZWNvZGluZ1NwZWNpZmljYXRpb24sXHJcblx0XHRcdFx0XHRtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSwgY2FsbGJhY2spO1xyXG4gICAgICAgICsrY3VycmVudFNlbGVjdG9ySWR4O1xyXG4gICAgICAgIC8vIE9ubHkgZXZhbHVhdGUgdW5tYXRjaGVkIHBhcnQgaWYgdGhlcmUgaXMgYW5vdGhlciBzZWxlY3RvciBmb2xsb3dpbmdcclxuLy8gICAgICAgIGlmIChjdXJyZW50U2VsZWN0b3JJZHggPCBzZWxlY3Rvck9wdGlvbnNDb3VudClcclxuLy9cdFx0ICAgIHVubWF0Y2hlZFBhcnRzID0ganBhdGguZXh0cmFjdFVuY292ZXJlZFBhcnRzKG9wdGlvbnMucGF0aCwgdW5tYXRjaGVkUGFydHMpO1xyXG5cclxuXHR9LCBjYWxsYmFjayk7XHJcbn07XHJcblxyXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBPYmplY3RFbmNvZGVyO1xyXG4iLCIvLyAjIFByZWFtYmxlXG5cbi8vIFRoZSBwcmVhbWJsZSBvZiBhIGJsYXN0IG9jdGV0IHN0cmVhbSBjb21wcmlzZXMgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOlxuLy9cbi8vIC0gU2lnbmF0dXJlOiBBIHVpbnQzMiB2YWx1ZSBlcXVhbCB0byBgMHg2MjZDNzM3NGAgKEFTQ0lJIGVuY29kZWQgXCJibHN0XCIpLlxuLy8gVGhpcyBzaWduYXR1cmUgdmFsdWUgaXMgZm9yIGlkZW50aWZpY2F0aW9uIGFzIHdlbGwgYXMgZW5kaWFubmVzcyBkZXRlY3Rpb24gb2YgdGhlIGluY29taW5nIHN0cmVhbS5cbi8vIC0gTWFqb3IgVmVyc2lvbjogQSB1aW50OCB2YWx1ZSB0aGF0IHNwZWNpZmllcyB0aGUgbWFqb3IgdmVyc2lvbiBvZiB0aGUgaW5jb21pbmcgc3RyZWFtJ3MgZm9ybWF0LlxuLy8gLSBNaW5vciBWZXJzaW9uOiBBIHVpbnQ4IHZhbHVlIHRoYXQgc3BlY2lmaWVzIHRoZSBtaW5vciB2ZXJzaW9uIG9mIHRoZSBpbmNvbWluZyBzdHJlYW07cyBmb3JtYXQuXG4vLyAtIEhlYWRlciBEZWNvZGluZyBTcGVjaWZpY2F0aW9uOiBBIE5VTCBcIlxcMFwiIHRlcm1pbmF0ZWQgQVNDSUkgZW5jb2RlZCBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIGRlY29kaW5nIHByb2NlZHVyZSB0b1xuLy8gZW5jb2RlIGEgY2h1bmtzIGhlYWRlciBpbmZvcm1hdGlvbi5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhYm9wcyA9IHJlcXVpcmUoXCJhYm9wc1wiKTtcblxudmFyIFByZWFtYmxlID0ge307XG5cbi8vIEFTQ0lJIGJsc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFByZWFtYmxlLCB7XG5cdC8qKlxuXHQgKiBUaGUgc2lnbmF0dXJlIGJ5dGVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIG9jdGV0IHN0cmVhbSBhbmQgaXRzIGVuZGlhbm5lc3MuXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICogQHByb3BlcnR5IHNpZ25hdHVyZVxuXHQgKiBAY29uc3RhbnRcblx0ICogQHR5cGUge3VpbnQzMn1cblx0ICovXG5cdHNpZ25hdHVyZToge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIDB4NjI2QzczNzQ7XG5cdFx0XHQvLyBBU0NJSSBibHN0XG5cdFx0fVxuXHR9LFxuXHQvKipcblx0ICogTWlub3IgdmVyc2lvbiBudW1iZXJcblx0ICpcblx0ICogU2l6ZTogMSBPY3RldHNcblx0ICogQHB1YmxpY1xuXHQgKiBAcHJvcGVydHkgbWFqb3JWZXJzaW9uXG5cdCAqIEBjb25zdGFudFxuXHQgKiBAdHlwZSB7aW50fVxuXHQgKi9cblx0bWFqb3JWZXJzaW9uOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gMHgwMDtcblx0XHR9XG5cdH0sXG5cdC8qKlxuXHQgKiBNaW5vciB2ZXJzaW9uIG51bWJlclxuXHQgKlxuXHQgKiBTaXplOiAxIE9jdGV0c1xuXHQgKiBAcHVibGljXG5cdCAqIEBwcm9wZXJ0eSBtaW5vclZlcnNpb25cblx0ICogQGNvbnN0YW50XG5cdCAqIEB0eXBlIHtpbnR9XG5cdCAqL1xuXHRtaW5vclZlcnNpb246IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAweDAxO1xuXHRcdH1cblx0fVxufSk7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGJsYXN0IHByZWFtYmxlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByZWFtYmxlIGluIHRoZSBnaXZlbiBlbmRpYW5uZXNzLlxuICogVGhpcyBpbmNsdWRlcyA0IG9jdGV0cyBzaWduYXR1cmUgYnl0ZXMgKyAxIG9jdGV0IG1ham9yIHZlcnNpb24gbnVtYmVyICsgMSBvY3RldCBtaW5vciB2ZXJzaW9uIG51bWJlciArIHZhcmlhYmxlIGxlbmd0aFxuICogQVNDSUkgZW5jb2RlZCBOVUwgdGVybWluYXRlZCBVUkwgZm9yIHRoZSBoZWFkZXIgZGVjb2Rpbmcgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uIGNyZWF0ZVByZWFtYmxlQnVmZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyRGVjb2RpbmdTcGVjaWZpY2F0aW9uIEEgVVJMIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgZGVjb2RpbmcgcHJvY2VkdXJlIHRvIGRlY29kZSB0aGUgaGVhZGVyXG4gKiBpbmZvcm1hdGlvbiBvZiB0aGUgY2h1bmtzIGluIHRoZSBzdHJlYW0uXG4gKiBAcGFyYW0ge2Jvb2x9IFtsaXR0bGVFbmRpYW4gPSBmYWxzZV0gSWYgdHJ1ZSB0aGUgYnVmZmVyIHdpbGwgYmUgd3JpdHRlbiBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBBbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHRoZSBwcmVhbWJsZSBvY3RldCBzdHJlYW0uXG4gKi9cblByZWFtYmxlLmJ1ZmZlciA9IGZ1bmN0aW9uIChoZWFkZXJEZWNvZGluZ1NwZWNpZmljYXRpb24sIGxpdHRsZUVuZGlhbikge1xuXHQvLyBUaGUgc2l6ZSBvZiB0aGUgYnVmZmVyOlxuXHQvLyA0IG9jdGV0IHNpZ25hdHVyZSArIDEgb2N0ZXQgbWlub3IgdmVyc2lvbiArIDEgb2N0ZXQgbWFqb3IgdmVyc2lvbiArIEhlYWRlckRlY29kZXJVUkwgYXMgYXNjaWkgKyBOVUxMIGJ5dGVcblx0dmFyIHVybFNpemUgPSBhYm9wcy5ieXRlU2l6ZUZvclN0cmluZyhoZWFkZXJEZWNvZGluZ1NwZWNpZmljYXRpb24sIFwiYXNjaWlcIikgKyAxO1xuXHR2YXIgYnVmZmVyU2l6ZSA9IDQgKyAxICsgMSArIHVybFNpemU7XG5cdHZhciBidWZmZXJWaWV3ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihidWZmZXJTaXplKSk7XG5cdHZhciBidWZmZXJPZmZzZXQgPSAwO1xuXG5cdGJ1ZmZlclZpZXcuc2V0VWludDMyKGJ1ZmZlck9mZnNldCwgUHJlYW1ibGUuc2lnbmF0dXJlLCBsaXR0bGVFbmRpYW4pO1xuXHRidWZmZXJPZmZzZXQgKz0gNDtcblxuXHRidWZmZXJWaWV3LnNldFVpbnQ4KGJ1ZmZlck9mZnNldCwgUHJlYW1ibGUubWFqb3JWZXJzaW9uKTtcblx0YnVmZmVyT2Zmc2V0ICs9IDE7XG5cblx0YnVmZmVyVmlldy5zZXRVaW50OChidWZmZXJPZmZzZXQsIFByZWFtYmxlLm1pbm9yVmVyc2lvbik7XG5cdGJ1ZmZlck9mZnNldCArPSAxO1xuXG4gICAgYWJvcHMuc2V0Q1N0cmluZyhidWZmZXJWaWV3LCBidWZmZXJPZmZzZXQsIGhlYWRlckRlY29kaW5nU3BlY2lmaWNhdGlvbik7XG5cblx0cmV0dXJuIGJ1ZmZlclZpZXcuYnVmZmVyO1xufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUHJlYW1ibGU7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5pZiAocHJvY2Vzcy5icm93c2VyKVxyXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vYnJvd3Nlci9ydW5fZXh0ZXJuYWxfZGVjb2RpbmdcIik7XHJcbmVsc2VcclxuICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL25vZGUvcnVuX2V4dGVybmFsX2RlY29kaW5nXCIpO1xyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xuLy8gIyBTdHJlYW1HZW5lcmF0b3JcblxuLy8gR2VuZXJhdGVzIHRoZSBmaW5hbCBvdXRwdXQgc3RyZWFtIHRoYXQgY2FuIGJlIHNlbnQgb3ZlciB0aGUgd2lyZS5cbi8vIEl0IHRha2VzIGNodW5rcyBhcyBnZW5lcmF0ZWQgYnkgdGhlIENodW5rZXIgYW5kIGNhbGxzIHRoZWlyIHRvQnVmZmVyIG1ldGhvZC5cbi8vIFRoaXMgYnVmZmVyIGlzIHRoZW4gZW1pdHRlZCBpbiB0aGUgZGF0YSBldmVudC5cbi8vIEl0IGFsc28gZ2VuZXJhdGVzIHRoZSBwcmVhbWJsZSBvZiB0aGUgc3RyZWFtLlxuLy8gRm9yIGNvbnZpbmllbmNlIGl0IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gTm9kZUpTIGFuZCBCcm93c2VyIGVudmlyb25tZW50LlxuLy8gSW4gTm9kZUpTIHRoZSBidWZmZXJzIGFyZSBOb2RlSlMgYnVmZmVycyB0aGF0IGNhbiBiZSBwaXBlZCBpbnRvIGEgc2VydmVyJ3MgcmVzcG9uc2Ugb2JqZWN0LlxuXG5cInVzZSBzdHJpY3RcIlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuVHJhbnNmb3JtO1xuXG52YXIganNvbkNvZGVjID0gcmVxdWlyZShcImJsYXN0LWNvZGVjc1wiKS5qc29uO1xuXG52YXIgQmxhc3RFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xudmFyIFByZWFtYmxlID0gcmVxdWlyZShcIi4vcHJlYW1ibGVcIik7XG52YXIgQ2h1bmsgPSByZXF1aXJlKFwiLi9jaHVua1wiKTtcbnZhciB3cmFwU3luY0Z1bmN0aW9uID0gcmVxdWlyZShcIi4vdXRpbC93cmFwX3N5bmNfZnVuY3Rpb25cIik7XG52YXIgaXNMaXR0bGVFbmRpYW5BcmNoaXRlY3R1cmUgPSByZXF1aXJlKFwiLi91dGlsL2lzX2xpdHRsZV9lbmRpYW5fYXJjaGl0ZWN0dXJlXCIpO1xudmFyIGNhbGxJbW1lZGlhdGUgPSByZXF1aXJlKFwiLi91dGlsL2NhbGxfaW1tZWRpYXRlXCIpO1xuXG5mdW5jdGlvbiBTdHJlYW1HZW5lcmF0b3Iob3B0aW9ucykge1xuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPSBmYWxzZTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5faGVhZGVyRW5jb2RlciA9IG9wdGlvbnMuaGVhZGVyRW5jb2RlciB8fCB7XG5cdFx0ZW5jb2RlOiB3cmFwU3luY0Z1bmN0aW9uKGpzb25Db2RlYy5lbmNvZGUuYmluZChqc29uQ29kZWMpKSxcblx0XHRkZWNvZGluZ1NwZWNpZmljYXRpb246IFwiaHR0cDovL3d3dy5ibGFzdC1mb3JtYXQuY29tLzAuMS9oZWFkZXJEZWNvZGluZ1NwZWNpZmljYXRpb24vXCJcblx0fTtcblx0dGhpcy5fbGl0dGxlRW5kaWFuID0gdHlwZW9mIG9wdGlvbnMubGl0dGxlRW5kaWFuICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5saXR0bGVFbmRpYW4gOiBpc0xpdHRsZUVuZGlhbkFyY2hpdGVjdHVyZSgpO1xuICAgIHRoaXMuX2FzeW5jID0gdHlwZW9mIG9wdGlvbnMuYXN5bmMgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmFzeW5jIDogdHJ1ZTtcbn1cblxudXRpbC5pbmhlcml0cyhTdHJlYW1HZW5lcmF0b3IsIFRyYW5zZm9ybSk7XG5cblN0cmVhbUdlbmVyYXRvci5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgXywgY2FsbGJhY2spIHtcblx0aWYgKCF0aGlzLl9wcmVhbWJsZVB1c2hlZClcbiAgICAgICAgY2FsbEltbWVkaWF0ZSh0aGlzLl9wdXNoUHJlYW1ibGUuYmluZCh0aGlzKSwgdGhpcy5fYXN5bmMpO1xuICAgIGNhbGxJbW1lZGlhdGUodGhpcy5fZW5jb2RlQ2h1bmsuYmluZCh0aGlzLCBjaHVuaywgY2FsbGJhY2spLCB0aGlzLl9hc3luYyk7XG59O1xuXG5TdHJlYW1HZW5lcmF0b3IucHJvdG90eXBlLl9wdXNoUHJlYW1ibGUgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuX3B1c2hCdWZmZXIoUHJlYW1ibGUuYnVmZmVyKHRoaXMuX2hlYWRlckVuY29kZXIuZGVjb2RpbmdTcGVjaWZpY2F0aW9uLCB0aGlzLl9saXR0bGVFbmRpYW4pKTtcblx0dGhpcy5fcHJlYW1ibGVQdXNoZWQgPSB0cnVlO1xufTtcblxuU3RyZWFtR2VuZXJhdG9yLnByb3RvdHlwZS5fZW5jb2RlQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmssIGNhbGxiYWNrKSB7XG5cdHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9oZWFkZXJFbmNvZGVyLmVuY29kZShjaHVuay5oZWFkZXJEZWZpbml0aW9ucywgdGhpcy5fbGl0dGxlRW5kaWFuLCBmdW5jdGlvbiAoZXJyb3IsIGhlYWRlckRlZmluaXRpb25zQnVmZmVyKSB7XG4gICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG5cbiAgICAgICAgdmFyIGhlYWRlclNpemUgPSBoZWFkZXJEZWZpbml0aW9uc0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBvdmVyYWxsIGJ1ZmZlciBjb250YWlucyBub3Qgb25seSB0aGUgaGVhZGVyIGFuZCB0aGUgcGF5bG9hZCxcbiAgICAgICAgLy8gYnV0IDQgYnl0ZXMgZm9yIHRoZSBoZWFkZXIgc2l6ZSBhbmQgNCBieXRlcyBmb3IgdGhlIG92ZXJhbGwgY2h1bmsgc2l6ZTtcbiAgICAgICAgdmFyIG92ZXJhbGxDaHVua1NpemUgPSA0ICsgNCArIGhlYWRlclNpemUgKyBjaHVuay5wYXlsb2FkU2l6ZTtcbiAgICAgICAgdmFyIHNpemVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoOCk7XG4gICAgICAgIHZhciBzaXplVmlldyA9IG5ldyBEYXRhVmlldyhzaXplQnVmZmVyKTtcblxuICAgICAgICBzaXplVmlldy5zZXRVaW50MzIoMCwgb3ZlcmFsbENodW5rU2l6ZSwgc2VsZi5fbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgc2l6ZVZpZXcuc2V0VWludDMyKDQsIGhlYWRlclNpemUsIHNlbGYuX2xpdHRsZUVuZGlhbik7XG4gICAgICAgIHNlbGYuX3B1c2hCdWZmZXIoc2l6ZUJ1ZmZlcik7XG4gICAgICAgIHNlbGYuX3B1c2hCdWZmZXIoaGVhZGVyRGVmaW5pdGlvbnNCdWZmZXIpO1xuICAgICAgICBjaHVuay5wYXlsb2FkLmZvckVhY2goc2VsZi5fcHVzaEJ1ZmZlci5iaW5kKHNlbGYpKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbn07XG5cblN0cmVhbUdlbmVyYXRvci5wcm90b3R5cGUuX3B1c2hCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdHRoaXMucHVzaCh0b0J1ZmZlcihidWZmZXIpKTtcbn07XG5cblN0cmVhbUdlbmVyYXRvci5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNhbGxJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9wdXNoQnVmZmVyKG5ldyBBcnJheUJ1ZmZlcig0KSk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSwgdGhpcy5fYXN5bmMpO1xufTtcblxuZnVuY3Rpb24gdG9CdWZmZXIoYnVmZmVyKSB7XG5cdGlmIChwcm9jZXNzLmJyb3dzZXIpIHtcblx0XHRpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG5cdFx0XHRyZXR1cm4gYnVmZmVyO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiBidWZmZXIudG9BcnJheUJ1ZmZlcigpO1xuXHR9XG5cblx0aWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHRcdHJldHVybiBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuXHRlbHNlXG5cdFx0cmV0dXJuIGJ1ZmZlcjtcblxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1HZW5lcmF0b3I7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuVHJhbnNmb3JtO1xuXG52YXIgYWJvcHMgPSByZXF1aXJlKFwiYWJvcHNcIik7XG52YXIganNvbkNvZGVjID0gcmVxdWlyZShcImJsYXN0LWNvZGVjc1wiKS5qc29uO1xuXG52YXIgQmxhc3RFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xudmFyIFByZWFtYmxlID0gcmVxdWlyZShcIi4vcHJlYW1ibGVcIik7XG52YXIgd3JhcFN5bmNGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL3V0aWwvd3JhcF9zeW5jX2Z1bmN0aW9uXCIpO1xudmFyIGlzTGl0dGxlRW5kaWFuQXJjaGl0ZWN0dXJlID0gcmVxdWlyZShcIi4vdXRpbC9pc19saXR0bGVfZW5kaWFuX2FyY2hpdGVjdHVyZVwiKTtcbnZhciBjYWxsSW1tZWRpYXRlID0gcmVxdWlyZShcIi4vdXRpbC9jYWxsX2ltbWVkaWF0ZVwiKTtcblxuZnVuY3Rpb24gU3RyZWFtUmVjZWl2ZXIob3B0aW9ucykge1xuXHRUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcblxuXHR0aGlzLl93cml0YWJsZVN0YXRlLm9iamVjdE1vZGUgPSBmYWxzZTtcblx0dGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID0gdHJ1ZTtcblxuXHR0aGlzLl9wcmVhbWJsZVJlY2VpdmVkID0gZmFsc2U7XG5cdHRoaXMuX2xhc3RDaHVua1JlY2VpdmVkID0gZmFsc2U7XG5cdHRoaXMuX2xpdHRsZUVuZGlhbiA9IHVuZGVmaW5lZDtcblx0dGhpcy5faGVhZGVyRGVjb2RlciA9IGpzb25Db2RlYztcblxuXHR0aGlzLl9idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG5cdHRoaXMuX2N1cnJlbnRCdWZmZXJPZmZzZXQgPSAwO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fYXN5bmMgPSB0eXBlb2Ygb3B0aW9ucy5hc3luYyAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuYXN5bmMgOiB0cnVlO1xufVxuXG51dGlsLmluaGVyaXRzKFN0cmVhbVJlY2VpdmVyLCBUcmFuc2Zvcm0pO1xuXG5TdHJlYW1SZWNlaXZlci5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBfLCBjYWxsYmFjaykge1xuICAgIGNhbGxJbW1lZGlhdGUodGhpcy5fZGVjb2RlLmJpbmQodGhpcywgZGF0YSwgY2FsbGJhY2spLCB0aGlzLl9hc3luYyk7XG59O1xuXG5TdHJlYW1SZWNlaXZlci5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uIChkYXRhQnVmZmVyLCBjYWxsYmFjaykge1xuXHQvLyBXZSBkbyBub3QgZXhwZWN0IHRoYXQgYGRhdGFCdWZmZXJgIGlzIGEgY29tcGxldGUgY2h1bmsgb3IgcHJlYW1ibGUuXG5cdC8vIElmIHdlIGhhdmVuJ3QgcmVjZWl2ZWQgYSBwcmVhbWJsZSB5ZXQsIHdlIGV4cGVjdCB0aGUgZmlyc3QgZGF0YSB0byBlaXRoZXIgYmUgdGhlIGNvbXBsZXRlIG9yIGF0IGxlYXN0IGEgcGFydCBvZlxuXHQvLyB0aGUgcHJlYW1ibGUuXG5cdHRoaXMuX2J1ZmZlciA9IGFib3BzLmNvbmNhdCh0aGlzLl9idWZmZXIsIGRhdGFCdWZmZXIpO1xuXHRpZiAoIXRoaXMuX3ByZWFtYmxlUmVjZWl2ZWQpIHtcblx0XHR2YXIgYnl0ZXNSZWFkID0gdGhpcy5fZGVjb2RlUHJlYW1ibGUobmV3IERhdGFWaWV3KHRoaXMuX2J1ZmZlcikpO1xuXHRcdC8vIElmIGJ5dGVzIHdlcmUgcmVhZCB3ZSByZWNlaXZlZCBhIGNvbXBsZXRlIHByZWFtYmxlLlxuXHRcdGlmIChieXRlc1JlYWQgIT09IDApIHtcblx0XHRcdHRoaXMuX3ByZWFtYmxlUmVjZWl2ZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fY3VycmVudEJ1ZmZlck9mZnNldCA9IGJ5dGVzUmVhZDtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB0aGUgbGFzdCBjaHVuayAoTnVsbCBDaHVuaykgd2FzIGFscmVhZHkgcmVjZWl2ZWQgdGhlcmUgY2Fubm90IGJlIG1vcmUgZGF0YVxuXHRpZiAodGhpcy5fbGFzdENodW5rUmVjZWl2ZWQpXG5cdFx0cmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyBCbGFzdEVycm9yKFwiTGFzdCBjaHVuayBhbHJlYWR5IHJlY2VpdmVkIVwiKSk7XG5cblx0Ly8gV2UgY2FuIG9ubHkgc3RhcnQgZGVjb2RpbmcgYSBjaHVuayBpZiB0aGUgcHJlYW1ibGUgd2FzIGFscmVhZHkgcmVjZWl2ZWQgYW5kIGlmIGF0IGxlYXN0IDQgQnl0ZXMgY2FuIGJlIHJlYWQgdG8gZ2V0IHRoZSBjaHVua3Mgc2l6ZS5cblx0aWYgKCF0aGlzLl9wcmVhbWJsZVJlY2VpdmVkIHx8IHRoaXMuX2N1cnJlbnRCdWZmZXJPZmZzZXQgKyA0ID4gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuXG5cdC8vIFdlIHRyeSB0byBkZWNvZGUgY2h1bmtzIHVudGlsIG5vdGhpbmcgY2FuIGJlIHJlYWQgb3IgdGhlIGJ1ZmZlciBpcyBlbXB0eS5cblx0dmFyIGJ5dGVzUmVhZDtcblx0ZG8ge1xuXHRcdGJ5dGVzUmVhZCA9IHRoaXMuX2RlY29kZUNodW5rKG5ldyBEYXRhVmlldyh0aGlzLl9idWZmZXIsIHRoaXMuX2N1cnJlbnRCdWZmZXJPZmZzZXQpKTtcblx0XHQvLyBUaGlzIGlzIHNhdmUuIElmIGJ5dGVzUmVhZCBpcyB6ZXJvIG5vdGhpbmcgaGFwcGVucy5cblx0XHR0aGlzLl9jdXJyZW50QnVmZmVyT2Zmc2V0ICs9IGJ5dGVzUmVhZDtcblx0fSB3aGlsZSAoYnl0ZXNSZWFkID4gMCAmJiB0aGlzLl9jdXJyZW50QnVmZmVyT2Zmc2V0IDwgdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGggJiYgIXRoaXMuX2xhc3RDaHVua1JlY2VpdmVkKTtcblxuXHQvLyBEaXNjYXJkIGN1cnJlbnQgYnVmZmVyIGlmIHJlYWQgY29tcGxldGVseS5cblx0aWYgKHRoaXMuX2N1cnJlbnRCdWZmZXJPZmZzZXQgPT09IHRoaXMuX2J1ZmZlci5ieXRlTGVuZ3RoKSB7XG5cdFx0dGhpcy5fYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuXHRcdHRoaXMuX2N1cnJlbnRCdWZmZXJPZmZzZXQgPSAwO1xuXHR9XG4gICAgY2FsbGJhY2soKTtcbn07XG5cblN0cmVhbVJlY2VpdmVyLnByb3RvdHlwZS5fZGVjb2RlUHJlYW1ibGUgPSBmdW5jdGlvbiAoYnVmZmVyVmlldykge1xuXHQvLyBXZSBrbm93IHRoYXQgZXZlcnkgcHJlYW1ibGUgaGFzIHRvIGhhdmUgYXQgbGVhc3Rcblx0Ly8gNCBCeXRlIFNpZ25hdHVyZSArIDIgQnl0ZSBWZXJzaW9uIGluZm9ybWF0aW9uICsgNSBCeXRlIEhlYWRlciBkZWNvZGluZyBzcGVjaWZpY2F0aW9uIGFuZCBudWxsIGJ5dGUuXG5cdC8vIFdlIGNhbiBhc3N1bWUgNSBieXRlIGZvciB0aGUgaGVhZGVyIGRlY29kaW5nIHNwZWNpZmljYXRpb24gYmVjYXVzZSBhIFVSTCBoYXMgdG8gaGF2ZSBhdCBsZWFzdCA0IGNoYXJhY3RlcnMgdG8gYmUgdmFsaWQsXG5cdC8vIE9uZSBjaGFyYWN0ZXIgZG9tYWluIG5hbWUgcGx1cyBhIGRvdCBhbmQgbWluLiB0d28gY2hhcmFjdGVycyB0bGQuXG5cdGlmIChidWZmZXJWaWV3LmJ5dGVMZW5ndGggPCAxMSlcblx0XHRyZXR1cm4gMDtcblxuXHR2YXIgc2lnbmF0dXJlID0gYnVmZmVyVmlldy5nZXRVaW50MzIoMCk7XG5cdC8vIElmIHRoZSBzaWduYXR1cmUgYnl0ZSBkb2VzIG5vdCBtYXRjaCB3ZSBmbGlwIGVuZGlhbm5lc3MuXG5cdGlmIChzaWduYXR1cmUgPT09IFByZWFtYmxlLnNpZ25hdHVyZSlcblx0XHR0aGlzLl9saXR0bGVFbmRpYW4gPSBmYWxzZTtcblx0ZWxzZSBpZiAoZmxpcEVuZGlhbm5lc3NJbnQzMihzaWduYXR1cmUpID09PSBQcmVhbWJsZS5zaWduYXR1cmUpXG5cdFx0dGhpcy5fbGl0dGxlRW5kaWFuID0gdHJ1ZTtcblx0ZWxzZVxuXHRcdHJldHVybiB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgQmxhc3RFcnJvcihcIkNvdWxkIG5vdCBpZGVudGlmeSBwcmVhbWJsZSEgU2lnbmF0dXJlIGJ5dGVzIGRvIG5vdCBtYXRjaCFcIikpO1xuXG5cdHRoaXMuX21ham9yVmVyc2lvbiA9IGJ1ZmZlclZpZXcuZ2V0VWludDgoNCk7XG5cdHRoaXMuX21pbm9yVmVyc2lvbiA9IGJ1ZmZlclZpZXcuZ2V0VWludDgoNSk7XG5cdHZhciBvZmZzZXQgPSA2O1xuICAgIHRoaXMuX2hlYWRlckRlY29kaW5nU3BlY2lmaWNhdGlvbiA9IGFib3BzLmdldENTdHJpbmcoYnVmZmVyVmlldywgb2Zmc2V0KTtcbiAgICAvLyBPbmUgYnl0ZSBmb3IgdGhlIE5VTCBjaGFyXG4gICAgb2Zmc2V0ICs9IHRoaXMuX2hlYWRlckRlY29kaW5nU3BlY2lmaWNhdGlvbi5sZW5ndGggKyAxO1xuXG5cdGlmIChvZmZzZXQgPiA2KVxuXHRcdHJldHVybiBvZmZzZXQ7XG5cblx0cmV0dXJuIDA7XG59O1xuXG5mdW5jdGlvbiBmbGlwRW5kaWFubmVzc0ludDMyKG4pIHtcblx0cmV0dXJuICgobiA+PiAyNCkgJiAweGZmKSB8ICgobiA8PCA4KSAmIDB4ZmYwMDAwKSB8ICgobiA+PiA4KSAmIDB4ZmYwMCkgfCAoKG4gPDwgMjQpICYgMHhmZjAwMDAwMCk7XG59XG5cblN0cmVhbVJlY2VpdmVyLnByb3RvdHlwZS5fZGVjb2RlQ2h1bmsgPSBmdW5jdGlvbiAoYnVmZmVyVmlldykge1xuXHR2YXIgY2h1bmtTaXplID0gYnVmZmVyVmlldy5nZXRVaW50MzIoMCwgdGhpcy5fbGl0dGxlRW5kaWFuKTtcblxuXHRpZiAoYnVmZmVyVmlldy5ieXRlTGVuZ3RoIDwgY2h1bmtTaXplKVxuXHRcdHJldHVybiAwO1xuXG5cdC8vIExhc3QgY2h1bmsgaGFzIHNpemUgMC5cblx0aWYgKGNodW5rU2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9sYXN0Q2h1bmtSZWNlaXZlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cblxuXHR2YXIgaGVhZGVyU2l6ZSA9IGJ1ZmZlclZpZXcuZ2V0VWludDMyKDQsIHRoaXMuX2xpdHRsZUVuZGlhbik7XG5cdHZhciBoZWFkZXJEZWZpbml0aW9ucyA9IHRoaXMuX2hlYWRlckRlY29kZXIuZGVjb2RlKGJ1ZmZlclZpZXcuYnVmZmVyLnNsaWNlKGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCArIDgsIGJ1ZmZlclZpZXcuYnl0ZU9mZnNldCArIDggKyBoZWFkZXJTaXplKSk7XG5cdHZhciBwYXlsb2FkT2Zmc2V0ID0gOCArIGhlYWRlclNpemU7XG5cbiAgICAvLyBBZGp1c3QgdGhlIG9mZnNldCBzdWNoIHRoYXQgd2UgY2FuIHNoYXJlIGEgc2luZ2xlIEFycmF5QnVmZmVyLlxuICAgIGhlYWRlckRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgZGVmaW5pdGlvbi5vZmZzZXQgKz0gYnVmZmVyVmlldy5ieXRlT2Zmc2V0ICsgcGF5bG9hZE9mZnNldDtcbiAgICB9KTtcblxuICAgIHRoaXMucHVzaCh7XG4gICAgICAgIHBheWxvYWQ6IGJ1ZmZlclZpZXcuYnVmZmVyLFxuICAgICAgICBoZWFkZXJEZWZpbml0aW9uczogaGVhZGVyRGVmaW5pdGlvbnMsXG4gICAgICAgIGxpdHRsZUVuZGlhbjogdGhpcy5fbGl0dGxlRW5kaWFuXG4gICAgfSk7XG5cblx0cmV0dXJuIGNodW5rU2l6ZTtcbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3RyZWFtUmVjZWl2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhc3luYykge1xuICAgIGlmIChhc3luYylcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICBlbHNlXG4gICAgICAgIGZuKCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERhdGFWaWV3I2dldFVpbnQxNiB3aWxsIHJlYWQgMSBvbiBiaWctZW5kaWFuIHN5c3RlbXMuXG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhuZXcgVWludDE2QXJyYXkoWzI1Nl0pLmJ1ZmZlcikuZ2V0VWludDE2KDAsIHRydWUpID09PSAyNTY7XG59O1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGFyaXR5ID0gZm4ubGVuZ3RoO1xuICAgIC8vIFZhcmlhYmxlIGFyZ3VtZW50IGxpc3QgbWVhbnMgd2UgY29uc2lkZXIgdGhpcyBmdW5jdGlvbiB0byBiZSBhc3luYy5cbiAgICBpZiAoYXJpdHkgPT09IDApXG4gICAgICAgIHJldHVybiBmbjtcbiAgICAvLyBBbiBhcml0eSBvZiB0d28gbWVhbnMgd2UgaGF2ZSBhIHN5bmMuIGZ1bmN0aW9uLCBzbyB3ZSB3cmFwIGl0LlxuICAgIGlmIChhcml0eSA9PT0gMilcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhT3JCdWZmZXIsIGxpdHRsZUVuZGlhbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZuKGRhdGFPckJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIGlmIChhcml0eSA9PT0gMylcbiAgICAgICAgcmV0dXJuIGZuO1xuXG4gICAgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGRlY29kaW5nIGZ1bmN0aW9uXCIpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZShcInN0cmVhbVwiKS5UcmFuc2Zvcm07XG5cbnZhciBydW5FeHRlcm5hbERlY29kaW5nID0gcmVxdWlyZShcIi4vcnVuX2V4dGVybmFsX2RlY29kaW5nXCIpO1xudmFyIHdyYXBTeW5jRnVuY3Rpb24gPSByZXF1aXJlKFwiLi91dGlsL3dyYXBfc3luY19mdW5jdGlvblwiKTtcbnZhciBjYWxsSW1tZWRpYXRlID0gcmVxdWlyZShcIi4vdXRpbC9jYWxsX2ltbWVkaWF0ZVwiKTtcblxuZnVuY3Rpb24gVmFsdWVEZWNvZGVyKG9wdGlvbnMpIHtcbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7XG4gICAgICAgIG9iamVjdE1vZGU6IHRydWVcbiAgICB9KTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9kZWNvZGluZ1NwZWNpZmljYXRpb25NYXAgPSBvcHRpb25zLmRlY29kaW5nU3BlY2lmaWNhdGlvbk1hcCB8fCB7fTtcbiAgICB0aGlzLl9hc3luYyA9IHR5cGVvZiBvcHRpb25zLmFzeW5jICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5hc3luYyA6IHRydWU7XG59XG5cbnV0aWwuaW5oZXJpdHMoVmFsdWVEZWNvZGVyLCBUcmFuc2Zvcm0pO1xuXG5WYWx1ZURlY29kZXIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZW5jb2RlZERhdGEsIF8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNhbGxJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVjb2RlRnVuY3Rpb24gPSBydW5FeHRlcm5hbERlY29kaW5nLmJpbmQodW5kZWZpbmVkLCBlbmNvZGVkRGF0YS5kZWNvZGluZ1NwZWNpZmljYXRpb24pO1xuXG4gICAgICAgIHZhciBjb2RlYyA9IHNlbGYuX2RlY29kaW5nU3BlY2lmaWNhdGlvbk1hcFtlbmNvZGVkRGF0YS5kZWNvZGluZ1NwZWNpZmljYXRpb25dXG4gICAgICAgIGlmIChjb2RlYylcbiAgICAgICAgICAgIGRlY29kZUZ1bmN0aW9uID0gd3JhcFN5bmNGdW5jdGlvbihjb2RlYy5kZWNvZGUgPyBjb2RlYy5kZWNvZGUgOiBjb2RlYyk7XG4gICAgICAgIGRlY29kZUZ1bmN0aW9uKGVuY29kZWREYXRhLmVuY29kZWRWYWx1ZSwgZW5jb2RlZERhdGEubGl0dGxlRW5kaWFuLCBmdW5jdGlvbiAoZXJyb3IsIGRlY29kZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG5cbiAgICAgICAgICAgIHNlbGYucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlY29kZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBwYXRoOiBlbmNvZGVkRGF0YS5wYXRoLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBlbmNvZGVkRGF0YS5tZXRhZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9LCB0aGlzLl9hc3luYyk7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBWYWx1ZURlY29kZXI7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgcm9vdCA9IHRoaXM7XG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIubWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yKHgsIGksIGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgX3JlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICAgIGlmIChhcnIucmVkdWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShpdGVyYXRvciwgbWVtbyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHZhciBfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cblxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShwcm9jZXNzLm5leHRUaWNrKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIG9ubHlfb25jZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaCA9IGFzeW5jLmVhY2g7XG5cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2NvbXBsZXRlZF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID0gYXN5bmMuZWFjaFNlcmllcztcblxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZuID0gX2VhY2hMaW1pdChsaW1pdCk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xuXG4gICAgdmFyIF9lYWNoTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgaWYgKCFhcnIubGVuZ3RoIHx8IGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiBzdGFydGVkIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyW3N0YXJ0ZWQgLSAxXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBfYXN5bmNNYXAgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbeC5pbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFyYWxsZWxMaW1pdChsaW1pdCwgX2FzeW5jTWFwKTtcbiAgICB9O1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGluamVjdCBhbGlhc1xuICAgIGFzeW5jLmluamVjdCA9IGFzeW5jLnJlZHVjZTtcbiAgICAvLyBmb2xkbCBhbGlhc1xuICAgIGFzeW5jLmZvbGRsID0gYXN5bmMucmVkdWNlO1xuXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb2xkciBhbGlhc1xuICAgIGFzeW5jLmZvbGRyID0gYXN5bmMucmVkdWNlUmlnaHQ7XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XG4gICAgLy8gc2VsZWN0IGFsaWFzXG4gICAgYXN5bmMuc2VsZWN0ID0gYXN5bmMuZmlsdGVyO1xuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcblxuICAgIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XG5cbiAgICB2YXIgX2RldGVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZGV0ZWN0ID0gZG9QYXJhbGxlbChfZGV0ZWN0KTtcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBkb1NlcmllcyhfZGV0ZWN0KTtcblxuICAgIGFzeW5jLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbnkgYWxpYXNcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xuXG4gICAgYXN5bmMuZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYWxsIGFsaWFzXG4gICAgYXN5bmMuYWxsID0gYXN5bmMuZXZlcnk7XG5cbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoZm4pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhc2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9lYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfa2V5cyhyZXN1bHRzKS5sZW5ndGggPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2VhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gKHRhc2tzW2tdIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gW3Rhc2tzW2tdXTogdGFza3Nba107XG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2VhY2goX2tleXMocmVzdWx0cyksIGZ1bmN0aW9uKHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIE1hdGguYWJzKHRhc2subGVuZ3RoIC0gMSkpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgdmFyIF9wYXJhbGxlbCA9IGZ1bmN0aW9uKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGVhY2hmbi5tYXAodGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogYXN5bmMubWFwLCBlYWNoOiBhc3luYy5lYWNoIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogX21hcExpbWl0KGxpbWl0KSwgZWFjaDogX2VhY2hMaW1pdChsaW1pdCkgfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAodGFza3MuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBhc3luYy5tYXBTZXJpZXModGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXBwbHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2NvbmNhdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYikge1xuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy51bnRpbCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9VbnRpbChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHBvcywgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZihkYXRhLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgICAgIHZhciBxID0ge1xuICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmVtcHR5ICYmIHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4gJiYgcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKHRhc2suZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciB3b3JraW5nICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXTtcblxuICAgICAgICB2YXIgY2FyZ28gPSB7XG4gICAgICAgICAgICB0YXNrczogdGFza3MsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluKSBjYXJnby5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gdHlwZW9mIHBheWxvYWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrcy5zcGxpY2UoMCwgcGF5bG9hZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhc2tzLnNwbGljZSgwKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZ287XG4gICAgfTtcblxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xuXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXAoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXNTZXJpZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwU2VyaWVzKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHZhciBmbnMgPSBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1dKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2FwcGx5RWFjaCA9IGZ1bmN0aW9uIChlYWNoZm4sIGZucyAvKmFyZ3MuLi4qLykge1xuICAgICAgICB2YXIgZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnbztcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuYXBwbHlFYWNoID0gZG9QYXJhbGxlbChfYXBwbHlFYWNoKTtcbiAgICBhc3luYy5hcHBseUVhY2hTZXJpZXMgPSBkb1NlcmllcyhfYXBwbHlFYWNoKTtcblxuICAgIGFzeW5jLmZvcmV2ZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbihuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTm9kZS5qc1xuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xuICAgIH1cblxufSgpKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIikpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhYm9wcyA9IHJlcXVpcmUoXCJhYm9wc1wiKTtcblxudmFyIGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeSA9IHJlcXVpcmUoXCIuLi91dGlsL2ZsaXBfZW5kaWFubmVzc19pZl9uZWNlc3NhcnlcIik7XG5cbnZhciBub3JtYWwgPSAoMSA8PCAwKTtcbnZhciB0YW5nZW50ID0gKDEgPDwgMSk7XG52YXIgdGV4Y29vcmQgPSAoMSA8PCAyKTtcbnZhciBjb2xvciA9ICgxIDw8IDMpO1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChtZXNoLCBsaXR0bGVFbmRpYW4pIHtcbiAgICB2YXIgdmVydGV4Q291bnQgPSBtZXNoLnBvc2l0aW9uLmxlbmd0aCAvIDMuMDtcbiAgICB2YXIgYXR0cmlicyA9IDA7XG5cbiAgICB2YXIgYnVmZmVycyA9IFtmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5wb3NpdGlvbiwgbGl0dGxlRW5kaWFuKV07XG5cbiAgICBpZiAobWVzaC5ub3JtYWwpIHtcbiAgICAgICAgYXR0cmlicyB8PSBub3JtYWw7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5ub3JtYWwsIGxpdHRsZUVuZGlhbikpXG4gICAgfVxuICAgIGlmIChtZXNoLnRhbmdlbnQpIHtcbiAgICAgICAgYXR0cmlicyB8PSB0YW5nZW50O1xuICAgICAgICBidWZmZXJzLnB1c2goZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gudGFuZ2VudCwgbGl0dGxlRW5kaWFuKSk7XG4gICAgfVxuICAgIGlmIChtZXNoLnRleGNvb3JkKSB7XG4gICAgICAgIGF0dHJpYnMgfD0gdGV4Y29vcmQ7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC50ZXhjb29yZCwgbGl0dGxlRW5kaWFuKSk7XG4gICAgfVxuICAgIGlmIChtZXNoLmNvbG9yKSB7XG4gICAgICAgIGF0dHJpYnMgfD0gY29sb3I7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5jb2xvciwgbGl0dGxlRW5kaWFuKSk7XG4gICAgfVxuICAgIGJ1ZmZlcnMucHVzaChmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5pbmRleCwgbGl0dGxlRW5kaWFuKSk7XG5cbiAgICAvLyAzIGJ5dGVzIHBhZGRpbmcgdG8gYWxpZ24gZm9sbG93aW5nIGJ1ZmZlciB0byA0IGJ5dGUgYm91bmRhcmllcyBhcyBuZWNjZXNzYXJ5LlxuICAgIGJ1ZmZlcnMudW5zaGlmdChuZXcgQXJyYXlCdWZmZXIoMykpO1xuICAgIGJ1ZmZlcnMudW5zaGlmdChuZXcgVWludDhBcnJheShbYXR0cmlic10pKTtcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobmV3IFVpbnQzMkFycmF5KFt2ZXJ0ZXhDb3VudF0pLCBsaXR0bGVFbmRpYW4pKTtcblxuICAgIHJldHVybiBidWZmZXJzO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBsaXR0bGVFbmRpYW4pIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIHZhciB2ZXJ0ZXhDb3VudCA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB2YXIgYXR0cmlicyA9IHZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcblxuICAgIHZhciBtZXNoID0ge1xuICAgICAgICBwb3NpdGlvbjogZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIHZlcnRleENvdW50ICogMyksIGxpdHRsZUVuZGlhbilcbiAgICB9O1xuICAgIG9mZnNldCArPSB2ZXJ0ZXhDb3VudCAqIDMgKiBtZXNoLnBvc2l0aW9uLkJZVEVTX1BFUl9FTEVNRU5UO1xuXG4gICAgaWYgKGF0dHJpYnMgJiBub3JtYWwpIHtcbiAgICAgICAgbWVzaC5ub3JtYWwgPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIG9mZnNldCwgdmVydGV4Q291bnQgKiAzKSwgbGl0dGxlRW5kaWFuKTtcbiAgICAgICAgb2Zmc2V0ICs9IHZlcnRleENvdW50ICogMyAqIG1lc2gubm9ybWFsLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIH1cbiAgICBpZiAoYXR0cmlicyAmIHRhbmdlbnQpIHtcbiAgICAgICAgbWVzaC50YW5nZW50ID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIHZlcnRleENvdW50ICogMyksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIG9mZnNldCArPSB2ZXJ0ZXhDb3VudCAqIDMgKiBtZXNoLnRhbmdlbnQuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgfVxuICAgIGlmIChhdHRyaWJzICYgdGV4Y29vcmQpIHtcbiAgICAgICAgbWVzaC50ZXhjb29yZCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCB2ZXJ0ZXhDb3VudCAqIDIpLCBsaXR0bGVFbmRpYW4pO1xuICAgICAgICBvZmZzZXQgKz0gdmVydGV4Q291bnQgKiAyICogbWVzaC50ZXhjb29yZC5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnMgJiBjb2xvcikge1xuICAgICAgICBtZXNoLmNvbG9yID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIHZlcnRleENvdW50ICogNCksIGxpdHRsZUVuZGlhbik7XG4gICAgICAgIG9mZnNldCArPSB2ZXJ0ZXhDb3VudCAqIDQgKiBtZXNoLmNvbG9yLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIH1cblxuICAgIG1lc2guaW5kZXggPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobmV3IFVpbnQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0KSwgbGl0dGxlRW5kaWFuKTtcblxuICAgIHJldHVybiBtZXNoO1xufTtcbiIsIi8vICMgSlNPTiBDb2RlY1xyXG5cclxuLy8gVGhpcyBzaW1wbGUgY29kZWMgc2ltcGx5IHVzZXMgYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIHRvIGVuY29kZSBhbmQgZGVjb2RlIHRoZSBnaXZlbiBkYXRhLlxyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgYWJvcHMgPSByZXF1aXJlKFwiYWJvcHNcIik7XHJcblxyXG4vKipcclxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gdmFsdWUgdXNpbmcgSlNPTi5zdHJpbmdpZnkuXHJcbiAqIFRoaXMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHdpbGwgYmUgd3JpdHRlbiBpbnRvIGFuIEFycmF5QnVmZmVyIHVzaW5nIFVURi04IGVuY29kaW5nLlxyXG4gKiBUaGUgc2Vjb25kIGR1bW15IHBhcmFtZXRlciBpcyBvbmx5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGNvcmUgbGlicmFyeSB0aGF0IGV4cGVjdHNcclxuICogZW5jb2RlcnMgdG8gcHJvdmlkZSBhIGxpdHRsZS1lbmRpYW4gcGFyYW1ldGVyIHRvIHNwZWNpZnkgdGhlIGZvcm1hdCBpbiB3aGljaCBtdWx0aS1ieXRlIHZhbHVlcyB3aWxsXHJcbiAqIGJlIHdyaXR0ZW4gaW50byBhIGJ1ZmZlci5cclxuICogU2luY2Ugd2Ugd3JpdGUgVVRGLTggZW5jb2RlZCBzdHJpbmdzIGVuZGlhbm5lc3MgaXMgaXJyZWxldmFudC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCBUaGUgdmFsdWUgdG8gZW5jb2RlLlxyXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IEFuIEFycmF5QnVmZmVyIGNvbnRhaW5pbmcgdGhlIFVURi04IGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS5cclxuICovXHJcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iamVjdCwgXykge1xyXG4gICAgcmV0dXJuIGFib3BzLmJ1ZmZlckZvclN0cmluZyhKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIHRoZSBnaXZlbiBEYXRhVmlldyB1c2luZyBKU09OLnBhcnNlLlxyXG4gKiBJdCByZWFkcyB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcgcmVmZXJlbmNlZCBieSB0aGUgRGF0YVZpZXcgYW5kIHBhcnNlcyB0aGF0IHN0cmluZyBhc3N1bWluZyB0aGF0XHJcbiAqIGl0IGlzIGEgc3RyaW5nIHNlcmlhbGl6YXRpb24gcHJvZHVjZWQgYnkgSlNPTi5zdHJpbmdpZnkgb3Igc29tZXRoaW5nIGVxdWl2YWxlbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IHZpZXcgVGhlIERhdGFWaWV3IHRoYXQgc3BlY2lmaWVzIHRoZSBidWZmZXIgYW5kIHRoZSByYW5nZSBmcm9tIHdoaWNoIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gd2lsbCBiZSBleHRyYWN0ZWQuXHJcbiAqIEByZXR1cm5zIHtNaXhlZH1cclxuICovXHJcbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgXykge1xyXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYWJvcHMuZ2V0U3RyaW5nKGJ1ZmZlciwgMCwgXCJ1dGYtOFwiKSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbzNkZ2MgPSByZXF1aXJlKFwibzNkZ2NcIik7XG5cbnZhciBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkgPSByZXF1aXJlKFwiLi4vdXRpbC9mbGlwX2VuZGlhbm5lc3NfaWZfbmVjZXNzYXJ5XCIpO1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChtZXNoLCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gbzNkZ2MudG9CdWZmZXIoe1xuICAgICAgICBwb3NpdGlvbjogZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gucG9zaXRpb24sIGxpdHRsZUVuZGlhbiksXG4gICAgICAgIG5vcm1hbDogbWVzaC5ub3JtYWwgPyBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5ub3JtYWwsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIHRhbmdlbnQ6IG1lc2gudGFuZ2VudCA/IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLnRhbmdlbnQsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIHRleGNvb3JkOiBtZXNoLnRleGNvb3JkID8gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gudGV4Y29vcmQsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbG9yOiBtZXNoLmNvbG9yID8gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2guY29sb3IsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIGluZGV4OiBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5pbmRleCwgbGl0dGxlRW5kaWFuKVxuICAgIH0sIHRydWUpO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBsaXR0bGVFbmRpYW4pIHtcbiAgICB2YXIgbWVzaCA9IG8zZGdjLmZyb21CdWZmZXIoYnVmZmVyKTtcblxuICAgIG1lc2gucG9zaXRpb24gPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5wb3NpdGlvbiwgbGl0dGxlRW5kaWFuKTtcbiAgICBtZXNoLmluZGV4ID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2guaW5kZXgsIGxpdHRsZUVuZGlhbik7XG4gICAgaWYgKG1lc2gubm9ybWFsKVxuICAgICAgICBtZXNoLm5vcm1hbCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLm5vcm1hbCwgbGl0dGxlRW5kaWFuKTtcbiAgICBpZiAobWVzaC50YW5nZW50KVxuICAgICAgICBtZXNoLnRhbmdlbnQgPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC50YW5nZW50LCBsaXR0bGVFbmRpYW4pO1xuICAgIGlmIChtZXNoLnRleGNvb3JkKVxuICAgICAgICBtZXNoLnRleGNvb3JkID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gudGV4Y29vcmQsIGxpdHRsZUVuZGlhbik7XG4gICAgaWYgKG1lc2guY29sb3IpXG4gICAgICAgIG1lc2guY29sb3IgPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5jb2xvciwgbGl0dGxlRW5kaWFuKTtcblxuICAgIHJldHVybiBtZXNoO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbzNkZ2MgPSByZXF1aXJlKFwibzNkZ2NcIik7XG5cbnZhciBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkgPSByZXF1aXJlKFwiLi4vdXRpbC9mbGlwX2VuZGlhbm5lc3NfaWZfbmVjZXNzYXJ5XCIpO1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChtZXNoLCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gbzNkZ2MudG9CdWZmZXIoe1xuICAgICAgICBwb3NpdGlvbjogZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gucG9zaXRpb24sIGxpdHRsZUVuZGlhbiksXG4gICAgICAgIG5vcm1hbDogbWVzaC5ub3JtYWwgPyBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5ub3JtYWwsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIHRhbmdlbnQ6IG1lc2gudGFuZ2VudCA/IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLnRhbmdlbnQsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIHRleGNvb3JkOiBtZXNoLnRleGNvb3JkID8gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gudGV4Y29vcmQsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbG9yOiBtZXNoLmNvbG9yID8gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2guY29sb3IsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIGluZGV4OiBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5pbmRleCwgbGl0dGxlRW5kaWFuKVxuICAgIH0pO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBsaXR0bGVFbmRpYW4pIHtcbiAgICB2YXIgbWVzaCA9IG8zZGdjLmZyb21CdWZmZXIoYnVmZmVyKTtcblxuICAgIG1lc2gucG9zaXRpb24gPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5wb3NpdGlvbiwgbGl0dGxlRW5kaWFuKTtcbiAgICBtZXNoLmluZGV4ID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2guaW5kZXgsIGxpdHRsZUVuZGlhbik7XG4gICAgaWYgKG1lc2gubm9ybWFsKVxuICAgICAgICBtZXNoLm5vcm1hbCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLm5vcm1hbCwgbGl0dGxlRW5kaWFuKTtcbiAgICBpZiAobWVzaC50YW5nZW50KVxuICAgICAgICBtZXNoLnRhbmdlbnQgPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC50YW5nZW50LCBsaXR0bGVFbmRpYW4pO1xuICAgIGlmIChtZXNoLnRleGNvb3JkKVxuICAgICAgICBtZXNoLnRleGNvb3JkID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gudGV4Y29vcmQsIGxpdHRsZUVuZGlhbik7XG4gICAgaWYgKG1lc2guY29sb3IpXG4gICAgICAgIG1lc2guY29sb3IgPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5jb2xvciwgbGl0dGxlRW5kaWFuKTtcblxuICAgIHJldHVybiBtZXNoO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgb3BlbmN0bSA9IHJlcXVpcmUoXCJvcGVuY3RtXCIpO1xuXG52YXIgZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5ID0gcmVxdWlyZShcIi4uL3V0aWwvZmxpcF9lbmRpYW5uZXNzX2lmX25lY2Vzc2FyeVwiKTtcblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobWVzaCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIG9wZW5jdG0udG9CdWZmZXIoe1xuICAgICAgICBwb3NpdGlvbjogZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gucG9zaXRpb24sIGxpdHRsZUVuZGlhbiksXG4gICAgICAgIG5vcm1hbDogbWVzaC5ub3JtYWwgPyBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5ub3JtYWwsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIHRhbmdlbnQ6IG1lc2gudGFuZ2VudCA/IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLnRhbmdlbnQsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIHRleGNvb3JkOiBtZXNoLnRleGNvb3JkID8gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gudGV4Y29vcmQsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbG9yOiBtZXNoLmNvbG9yID8gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2guY29sb3IsIGxpdHRsZUVuZGlhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIGluZGV4OiBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5pbmRleCwgbGl0dGxlRW5kaWFuKVxuICAgIH0pO1xufTtcblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBsaXR0bGVFbmRpYW4pIHtcbiAgICB2YXIgbWVzaCA9IG9wZW5jdG0uZnJvbUJ1ZmZlcihidWZmZXIpO1xuXG4gICAgbWVzaC5wb3NpdGlvbiA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLnBvc2l0aW9uLCBsaXR0bGVFbmRpYW4pO1xuICAgIG1lc2guaW5kZXggPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC5pbmRleCwgbGl0dGxlRW5kaWFuKTtcbiAgICBpZiAobWVzaC5ub3JtYWwpXG4gICAgICAgIG1lc2gubm9ybWFsID0gZmxpcEVuZGlhbmVzc0lmTmVjZXNzYXJ5KG1lc2gubm9ybWFsLCBsaXR0bGVFbmRpYW4pO1xuICAgIGlmIChtZXNoLnRhbmdlbnQpXG4gICAgICAgIG1lc2gudGFuZ2VudCA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLnRhbmdlbnQsIGxpdHRsZUVuZGlhbik7XG4gICAgaWYgKG1lc2gudGV4Y29vcmQpXG4gICAgICAgIG1lc2gudGV4Y29vcmQgPSBmbGlwRW5kaWFuZXNzSWZOZWNlc3NhcnkobWVzaC50ZXhjb29yZCwgbGl0dGxlRW5kaWFuKTtcbiAgICBpZiAobWVzaC5jb2xvcilcbiAgICAgICAgbWVzaC5jb2xvciA9IGZsaXBFbmRpYW5lc3NJZk5lY2Vzc2FyeShtZXNoLmNvbG9yLCBsaXR0bGVFbmRpYW4pO1xuXG4gICAgcmV0dXJuIG1lc2g7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgbGl0dGxlRW5kaWFuKSB7XG5cdHJldHVybiBidWZmZXI7XG59O1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChidWZmZXIsIGxpdHRsZUVuZGlhbikge1xuXHRyZXR1cm4gYnVmZmVyO1xufTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5qc29uID0gcmVxdWlyZShcIi4vY29kZWNzL2pzb25cIik7XG5leHBvcnRzLnBhc3N0aHJvdWdoID0gcmVxdWlyZShcIi4vY29kZWNzL3Bhc3N0aHJvdWdoXCIpO1xuZXhwb3J0cy5hc3NpbXBNZXNoID0gcmVxdWlyZShcIi4vY29kZWNzL2Fzc2ltcF9tZXNoXCIpO1xuZXhwb3J0cy5vcGVuY3RtID0gcmVxdWlyZShcIi4vY29kZWNzL29wZW5jdG1cIik7XG5leHBvcnRzLm8zZGdjID0gcmVxdWlyZShcIi4vY29kZWNzL28zZGdjXCIpO1xuZXhwb3J0cy5vM2RnY0FTQ0lJID0gcmVxdWlyZShcIi4vY29kZWNzL28zZGdjX2FzY2lpXCIpO1xuXG5leHBvcnRzLmlzTGl0dGxlRW5kaWFuQXJjaGl0ZWN0dXJlID0gcmVxdWlyZShcIi4vdXRpbC9pc19saXR0bGVfZW5kaWFuX2FyY2hpdGVjdHVyZVwiKTtcblxuaWYgKCFwcm9jZXNzLmJyb3dzZXIpXG4gICAgZXhwb3J0cy5zZXJ2ZUNvZGVjcyA9IHJlcXVpcmUoXCIuL3V0aWwvXCIgKyBcImFwcGVuZF9yb3V0ZXNcIik7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgYWJvcHMgPSByZXF1aXJlKFwiYWJvcHNcIik7XG52YXIgaXNMaXR0bGVFbmRpYW5BcmNoaXRlY3R1cmUgPSByZXF1aXJlKFwiLi9pc19saXR0bGVfZW5kaWFuX2FyY2hpdGVjdHVyZVwiKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHR5cGVkQXJyYXksIGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChsaXR0bGVFbmRpYW4gIT09IGlzTGl0dGxlRW5kaWFuQXJjaGl0ZWN0dXJlKCkpXG4gICAgICAgIHJldHVybiBhYm9wcy5mbGlwRW5kaWFubmVzcyh0eXBlZEFycmF5KTtcbiAgICByZXR1cm4gdHlwZWRBcnJheTtcbn07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuaWYgKCFwcm9jZXNzLmJyb3dzZXIpXG5cdGV4cG9ydHMudG9CdWZmZXIgPSByZXF1aXJlKFwiLi9idWlsZC9SZWxlYXNlL1wiICsgXCJvM2RnY1wiKTtcblxuZXhwb3J0cy5mcm9tQnVmZmVyID0gcmVxdWlyZShcIi4vbGliL2Zyb21fYnVmZmVyXCIpO1xuXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbzNkZ2MgPSByZXF1aXJlKFwiLi9vM2RnY1wiKTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0dmFyIHN0cmVhbSA9IG5ldyBvM2RnYy5CaW5hcnlTdHJlYW0oZGF0YSk7XG5cblx0dmFyIGRlY29kZXIgPSBuZXcgbzNkZ2MuU0MzRE1DRGVjb2RlcigpO1xuXHR2YXIgaWZzID0gbmV3IG8zZGdjLkluZGV4ZWRGYWNlU2V0KCk7XG5cdGRlY29kZXIuRGVjb2RlSGVhZGVyKGlmcywgc3RyZWFtKTtcblxuICAgIHZhciBtZXNoID0ge307XG5cdG1lc2guaW5kZXggPSBuZXcgVWludDMyQXJyYXkoMyAqIGlmcy5HZXROQ29vcmRJbmRleCgpKVxuXHRpZnMuU2V0Q29vcmRJbmRleChtZXNoLmluZGV4KTtcblxuICAgIG1lc2gucG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KDMgKiBpZnMuR2V0TkNvb3JkKCkpO1xuXHRpZnMuU2V0Q29vcmQobWVzaC5wb3NpdGlvbik7XG5cbiAgICBpZiAoaWZzLkdldE5Ob3JtYWwoKSA+IDApIHtcblx0ICAgIG1lc2gubm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheSgzICogaWZzLkdldE5Ob3JtYWwoKSk7XG5cdCAgICBpZnMuU2V0Tm9ybWFsKG1lc2gubm9ybWFsKTtcbiAgICB9XG5cbiAgICB2YXIgdGV4Y29vcmQgPSBnZXRGbG9hdEF0dHJpYnV0ZShpZnMsIDApO1xuICAgIGlmICh0ZXhjb29yZClcbiAgICAgICAgbWVzaC50ZXhjb29yZCA9IHRleGNvb3JkO1xuXG4gICAgdmFyIHRhbmdlbnQgPSBnZXRGbG9hdEF0dHJpYnV0ZShpZnMsIDEpO1xuICAgIGlmICh0YW5nZW50KVxuICAgICAgICBtZXNoLnRhbmdlbnQgPSB0YW5nZW50O1xuXG4gICAgdmFyIGNvbG9yID0gZ2V0RmxvYXRBdHRyaWJ1dGUoaWZzLCAyKTtcbiAgICBpZiAoY29sb3IpXG4gICAgICAgIG1lc2guY29sb3IgPSBjb2xvcjtcblxuXHRkZWNvZGVyLkRlY29kZVBsYXlsb2FkKGlmcywgc3RyZWFtKTtcblxuICAgIHJldHVybiBtZXNoO1xufTtcblxuZnVuY3Rpb24gZ2V0RmxvYXRBdHRyaWJ1dGUoaWZzLCBpZHgpIHtcbiAgICBpZiAoaWZzLkdldE5GbG9hdEF0dHJpYnV0ZShpZHgpID4gMCkge1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShpZnMuR2V0RmxvYXRBdHRyaWJ1dGVEaW0oaWR4KSAqIGlmcy5HZXRORmxvYXRBdHRyaWJ1dGUoaWR4KSk7XG4gICAgICAgIGlmcy5TZXRGbG9hdEF0dHJpYnV0ZShpZHgsIHZhbHVlcyk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLypnbG9iYWwgQXJyYXlCdWZmZXIsIFVpbnQzMkFycmF5LCBJbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEludDhBcnJheSwgVWludDhBcnJheSwgd2luZG93LCBwZXJmb3JtYW5jZSwgQ29uc29sZSovXG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTMgS2hhbGVkIE1hbW1vdSAtIEFkdmFuY2VkIE1pY3JvIERldmljZXMsIEluYy5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgd2luZG93ID0gZ2xvYmFsO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBtb2R1bGUsIGxvY2FsO1xuICAgIG1vZHVsZSA9IHt9O1xuICAgIGxvY2FsID0ge307XG4gICAgbG9jYWwuTzNER0NfQklOQVJZX1NUUkVBTV9CSVRTX1BFUl9TWU1CT0wwID0gNztcbiAgICBsb2NhbC5PM0RHQ19CSU5BUllfU1RSRUFNX01BWF9TWU1CT0wwID0gMTI3OyAvLyAoKDEgPDwgTzNER0NfQklOQVJZX1NUUkVBTV9CSVRTX1BFUl9TWU1CT0wwKSA+Pj4gMCkgLSAxO1xuICAgIGxvY2FsLk8zREdDX0JJTkFSWV9TVFJFQU1fQklUU19QRVJfU1lNQk9MMSA9IDY7XG4gICAgbG9jYWwuTzNER0NfQklOQVJZX1NUUkVBTV9NQVhfU1lNQk9MMSA9IDYzOyAvLyAoKDEgPDwgTzNER0NfQklOQVJZX1NUUkVBTV9CSVRTX1BFUl9TWU1CT0wxKSA+Pj4gMCkgLSAxO1xuICAgIGxvY2FsLk8zREdDX0JJTkFSWV9TVFJFQU1fTlVNX1NZTUJPTFNfVUlOVDMyID0gNTsgLy8gTWF0aC5mbG9vcigoMzIgKyBPM0RHQ19CSU5BUllfU1RSRUFNX0JJVFNfUEVSX1NZTUJPTDAgLSAxKSAvIE8zREdDX0JJTkFSWV9TVFJFQU1fQklUU19QRVJfU1lNQk9MMCk7XG4gICAgbG9jYWwuTzNER0NfQklHX0VORElBTiA9IDA7XG4gICAgbG9jYWwuTzNER0NfTElUVExFX0VORElBTiA9IDE7XG4gICAgbG9jYWwuTzNER0NfTUFYX0RPVUJMRSA9IDEuNzk3NjllKzMwODtcbiAgICBsb2NhbC5PM0RHQ19NSU5fTE9ORyA9IC0yMTQ3NDgzNjQ3O1xuICAgIGxvY2FsLk8zREdDX01BWF9MT05HID0gMjE0NzQ4MzY0NztcbiAgICBsb2NhbC5PM0RHQ19NQVhfVUNIQVI4ID0gMjU1O1xuICAgIGxvY2FsLk8zREdDX01BWF9URkFOX1NJWkUgPSAyNTY7XG4gICAgbG9jYWwuTzNER0NfTUFYX1VMT05HID0gNDI5NDk2NzI5NTtcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfU1RBUlRfQ09ERSA9IDB4MDAwMDFGMTtcbiAgICBsb2NhbC5PM0RHQ19EVl9TVEFSVF9DT0RFID0gMHgwMDAwMUYyO1xuICAgIGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0ZMT0FUX0FUVFJJQlVURVMgPSAyNTY7XG4gICAgbG9jYWwuTzNER0NfU0MzRE1DX01BWF9OVU1fSU5UX0FUVFJJQlVURVMgPSAyNTY7XG4gICAgbG9jYWwuTzNER0NfU0MzRE1DX01BWF9ESU1fQVRUUklCVVRFUyA9IDMyO1xuICAgIGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfUFJFRElDVElPTl9ORUlHSEJPUlMgPSAyO1xuICAgIGxvY2FsLk8zREdDX1NDM0RNQ19CSU5BUklaQVRJT05fRkwgPSAwOyAvLyBGaXhlZCBMZW5ndGggKG5vdCBzdXBwb3J0ZWQpXG4gICAgbG9jYWwuTzNER0NfU0MzRE1DX0JJTkFSSVpBVElPTl9CUCA9IDE7IC8vIEJQQyAobm90IHN1cHBvcnRlZClcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfQklOQVJJWkFUSU9OX0ZDID0gMjsgLy8gNCBiaXRzIENvZGluZyAobm90IHN1cHBvcnRlZClcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfQklOQVJJWkFUSU9OX0FDID0gMzsgLy8gQXJpdGhtZXRpYyBDb2RpbmcgKG5vdCBzdXBwb3J0ZWQpXG4gICAgbG9jYWwuTzNER0NfU0MzRE1DX0JJTkFSSVpBVElPTl9BQ19FR0MgPSA0OyAvLyBBcml0aG1ldGljIENvZGluZyAmIEVHQ2tcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfQklOQVJJWkFUSU9OX0FTQ0lJID0gNTsgLy8gQXJpdGhtZXRpYyBDb2RpbmcgJiBFR0NrXG4gICAgbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfVU5LT1dOID0gMDtcbiAgICBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9BU0NJSSA9IDE7XG4gICAgbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfQklOQVJZID0gMjtcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfTk9fUFJFRElDVElPTiA9IDA7IC8vIHN1cHBvcnRlZFxuICAgIGxvY2FsLk8zREdDX1NDM0RNQ19ESUZGRVJFTlRJQUxfUFJFRElDVElPTiA9IDE7IC8vIHN1cHBvcnRlZFxuICAgIGxvY2FsLk8zREdDX1NDM0RNQ19YT1JfUFJFRElDVElPTiA9IDI7IC8vIG5vdCBzdXBwb3J0ZWRcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfQURBUFRJVkVfRElGRkVSRU5USUFMX1BSRURJQ1RJT04gPSAzOyAvLyBub3Qgc3VwcG9ydGVkXG4gICAgbG9jYWwuTzNER0NfU0MzRE1DX0NJUkNVTEFSX0RJRkZFUkVOVElBTF9QUkVESUNUSU9OID0gNDsgLy8gbm90IHN1cHBvcnRlZFxuICAgIGxvY2FsLk8zREdDX1NDM0RNQ19QQVJBTExFTE9HUkFNX1BSRURJQ1RJT04gPSA1OyAvLyBzdXBwb3J0ZWRcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfU1VSRl9OT1JNQUxTX1BSRURJQ1RJT04gPSA2OyAvLyBzdXBwb3J0ZWRcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfRU5DT0RFX01PREVfUUJDUiA9IDA7IC8vIG5vdCBzdXBwb3J0ZWRcbiAgICBsb2NhbC5PM0RHQ19TQzNETUNfRU5DT0RFX01PREVfU1ZBID0gMTsgLy8gbm90IHN1cHBvcnRlZFxuICAgIGxvY2FsLk8zREdDX1NDM0RNQ19FTkNPREVfTU9ERV9URkFOID0gMjsgLy8gc3VwcG9ydGVkXG4gICAgbG9jYWwuTzNER0NfRFlOQU1JQ19WRUNUT1JfRU5DT0RFX01PREVfTElGVCA9IDA7XG4gICAgbG9jYWwuTzNER0NfTUlOX05FSUdIQk9SU19TSVpFID0gMTI4O1xuICAgIGxvY2FsLk8zREdDX01JTl9OVU1fTkVJR0hCT1JTX1NJWkUgPSAxNjtcbiAgICBsb2NhbC5PM0RHQ19URkFOU19NSU5fU0laRV9BTExPQ0FURURfVkVSVElDRVNfQlVGRkVSID0gMTI4O1xuICAgIGxvY2FsLk8zREdDX1RGQU5TX01JTl9TSVpFX1RGQU5fU0laRV9CVUZGRVIgPSA4O1xuICAgIGxvY2FsLk8zREdDX0RFRkFVTFRfVkVDVE9SX1NJWkUgPSAzMjtcblxuICAgIG1vZHVsZS5PM0RHQ19JRlNfRkxPQVRfQVRUUklCVVRFX1RZUEVfVU5LT1dOID0gMDtcbiAgICBtb2R1bGUuTzNER0NfSUZTX0ZMT0FUX0FUVFJJQlVURV9UWVBFX1BPU0lUSU9OID0gMTtcbiAgICBtb2R1bGUuTzNER0NfSUZTX0ZMT0FUX0FUVFJJQlVURV9UWVBFX05PUk1BTCA9IDI7XG4gICAgbW9kdWxlLk8zREdDX0lGU19GTE9BVF9BVFRSSUJVVEVfVFlQRV9DT0xPUiA9IDM7XG4gICAgbW9kdWxlLk8zREdDX0lGU19GTE9BVF9BVFRSSUJVVEVfVFlQRV9URVhDT09SRCA9IDQ7XG4gICAgbW9kdWxlLk8zREdDX0lGU19GTE9BVF9BVFRSSUJVVEVfVFlQRV9XRUlHSFQgPSA1O1xuICAgIG1vZHVsZS5PM0RHQ19JRlNfSU5UX0FUVFJJQlVURV9UWVBFX1VOS09XTiA9IDA7XG4gICAgbW9kdWxlLk8zREdDX0lGU19JTlRfQVRUUklCVVRFX1RZUEVfSU5ERVggPSAxO1xuICAgIG1vZHVsZS5PM0RHQ19JRlNfSU5UX0FUVFJJQlVURV9UWVBFX0pPSU5UX0lEID0gMjtcbiAgICBtb2R1bGUuTzNER0NfSUZTX0lOVF9BVFRSSUJVVEVfVFlQRV9JTkRFWF9CVUZGRVJfSUQgPSAzO1xuXG4gICAgbW9kdWxlLk8zREdDX09LID0gMDtcbiAgICBtb2R1bGUuTzNER0NfRVJST1JfQlVGRkVSX0ZVTEwgPSAxO1xuICAgIG1vZHVsZS5PM0RHQ19FUlJPUl9DT1JSVVBURURfU1RSRUFNID0gNTtcbiAgICBtb2R1bGUuTzNER0NfRVJST1JfTk9OX1NVUFBPUlRFRF9GRUFUVVJFID0gNjtcbiAgICBtb2R1bGUuTzNER0NfRVJST1JfQUMgPSA3O1xuXG4gICAgZnVuY3Rpb24gU3lzdGVtRW5kaWFubmVzcygpIHtcbiAgICAgICAgdmFyIGEsIGIsIGM7XG4gICAgICAgIGIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGEgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gICAgICAgIGMgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAgICAgYVswXSA9IDE7XG4gICAgICAgIGlmIChjWzBdID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWwuTzNER0NfTElUVExFX0VORElBTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWwuTzNER0NfQklHX0VORElBTjtcbiAgICB9XG4gICAgLy8gU0MzRE1DU3RhdHMgY2xhc3NcbiAgICBtb2R1bGUuU0MzRE1DU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV90aW1lQ29vcmQgPSAwO1xuICAgICAgICB0aGlzLm1fdGltZU5vcm1hbCA9IDA7XG4gICAgICAgIHRoaXMubV90aW1lQ29vcmRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubV90aW1lRmxvYXRBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkFycmF5KGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0ZMT0FUX0FUVFJJQlVURVMpO1xuICAgICAgICB0aGlzLm1fdGltZUludEF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQXJyYXkobG9jYWwuTzNER0NfU0MzRE1DX01BWF9OVU1fSU5UX0FUVFJJQlVURVMpO1xuICAgICAgICB0aGlzLm1fdGltZVJlb3JkZXIgPSAwO1xuICAgICAgICB0aGlzLm1fc3RyZWFtU2l6ZUNvb3JkID0gMDtcbiAgICAgICAgdGhpcy5tX3N0cmVhbVNpemVOb3JtYWwgPSAwO1xuICAgICAgICB0aGlzLm1fc3RyZWFtU2l6ZUNvb3JkSW5kZXggPSAwO1xuICAgICAgICB0aGlzLm1fc3RyZWFtU2l6ZUZsb2F0QXR0cmlidXRlID0gbmV3IFVpbnQzMkFycmF5KGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0ZMT0FUX0FUVFJJQlVURVMpO1xuICAgICAgICB0aGlzLm1fc3RyZWFtU2l6ZUludEF0dHJpYnV0ZSA9IG5ldyBVaW50MzJBcnJheShsb2NhbC5PM0RHQ19TQzNETUNfTUFYX05VTV9JTlRfQVRUUklCVVRFUyk7XG4gICAgfTtcbiAgICAvLyBTQzNETUNUcmlwbGV0IGNsYXNzXG4gICAgbW9kdWxlLlNDM0RNQ1RyaXBsZXQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICB0aGlzLm1fYSA9IGE7XG4gICAgICAgIHRoaXMubV9iID0gYjtcbiAgICAgICAgdGhpcy5tX2MgPSBjO1xuICAgIH07XG4gICAgbW9kdWxlLlNDM0RNQ1RyaXBsZXQucHJvdG90eXBlLkxlc3MgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICh0aGlzLm1fYyAhPT0gcmhzLm1fYykge1xuICAgICAgICAgICAgcmVzID0gKHRoaXMubV9jIDwgcmhzLm1fYyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tX2IgIT09IHJocy5tX2IpIHtcbiAgICAgICAgICAgIHJlcyA9ICh0aGlzLm1fYiA8IHJocy5tX2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gKHRoaXMubV9hIDwgcmhzLm1fYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNUcmlwbGV0LnByb3RvdHlwZS5FcXVhbCA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1fYyA9PT0gcmhzLm1fYyAmJiB0aGlzLm1fYiA9PT0gcmhzLm1fYiAmJiB0aGlzLm1fYSA9PT0gcmhzLm1fYSk7XG4gICAgfTtcbiAgICAvLyBTQzNETUNQcmVkaWN0b3IgY2xhc3NcbiAgICBtb2R1bGUuU0MzRE1DUHJlZGljdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1faWQgPSBuZXcgbW9kdWxlLlNDM0RNQ1RyaXBsZXQoLTEsIC0xLCAtMSk7XG4gICAgICAgIHRoaXMubV9wcmVkID0gbmV3IEZsb2F0MzJBcnJheShsb2NhbC5PM0RHQ19TQzNETUNfTUFYX0RJTV9BVFRSSUJVVEVTKTtcbiAgICB9O1xuICAgIC8vIGZpeCBtZTogb3B0aW1pemUgdGhpcyBmdW5jdGlvbiAoZS5nLiwgYmluYXJ5IHNlYXJjaClcbiAgICBmdW5jdGlvbiBJbnNlcnRQcmVkaWN0b3IoZSwgblByZWQsIGxpc3QsIGRpbUZsb2F0QXJyYXkpIHtcbiAgICAgICAgdmFyIHBvcywgZm91bmRPckluc2VydGVkLCBqLCBqMSwgajAsIGgsIGk7XG4gICAgICAgIHBvcyA9IC0xO1xuICAgICAgICBmb3VuZE9ySW5zZXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgajEgPSBuUHJlZC5tX3ZhbHVlO1xuICAgICAgICBqMCA9IDA7XG4gICAgICAgIGZvciAoaiA9IGowOyBqIDwgajE7ICsraikge1xuICAgICAgICAgICAgaWYgKGUuRXF1YWwobGlzdFtqXS5tX2lkKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kT3JJbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUuTGVzcyhsaXN0W2pdLm1faWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5QcmVkLm1fdmFsdWUgPCBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX1BSRURJQ1RJT05fTkVJR0hCT1JTKSB7XG4gICAgICAgICAgICAgICAgICAgICsrblByZWQubV92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChoID0gblByZWQubV92YWx1ZSAtIDE7IGggPiBqOyAtLWgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdFtoXS5tX2lkLm1fYSA9IGxpc3RbaCAtIDFdLm1faWQubV9hO1xuICAgICAgICAgICAgICAgICAgICBsaXN0W2hdLm1faWQubV9iID0gbGlzdFtoIC0gMV0ubV9pZC5tX2I7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaF0ubV9pZC5tX2MgPSBsaXN0W2ggLSAxXS5tX2lkLm1fYztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpbUZsb2F0QXJyYXk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdFtoXS5tX3ByZWRbaV0gPSBsaXN0W2ggLSAxXS5tX3ByZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdFtqXS5tX2lkLm1fYSA9IGUubV9hO1xuICAgICAgICAgICAgICAgIGxpc3Rbal0ubV9pZC5tX2IgPSBlLm1fYjtcbiAgICAgICAgICAgICAgICBsaXN0W2pdLm1faWQubV9jID0gZS5tX2M7XG4gICAgICAgICAgICAgICAgcG9zID0gajtcbiAgICAgICAgICAgICAgICBmb3VuZE9ySW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZm91bmRPckluc2VydGVkICYmIG5QcmVkLm1fdmFsdWUgPCBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX1BSRURJQ1RJT05fTkVJR0hCT1JTKSB7XG4gICAgICAgICAgICBwb3MgPSBuUHJlZC5tX3ZhbHVlKys7XG4gICAgICAgICAgICBsaXN0W3Bvc10ubV9pZC5tX2EgPSBlLm1fYTtcbiAgICAgICAgICAgIGxpc3RbcG9zXS5tX2lkLm1fYiA9IGUubV9iO1xuICAgICAgICAgICAgbGlzdFtwb3NdLm1faWQubV9jID0gZS5tX2M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLy8gVGltZXIgY2xhc3NcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge307XG4gICAgfVxuICAgIGlmICghd2luZG93LnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgICBsb2NhbC5ub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgIGxvY2FsLm5vd09mZnNldCA9IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbG9jYWwubm93T2Zmc2V0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBtb2R1bGUuVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9zdGFydCA9IDA7XG4gICAgICAgIHRoaXMubV9lbmQgPSAwO1xuICAgIH07XG4gICAgbW9kdWxlLlRpbWVyLnByb3RvdHlwZS5UaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9zdGFydCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xuICAgIG1vZHVsZS5UaW1lci5wcm90b3R5cGUuVG9jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fZW5kID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gICAgbW9kdWxlLlRpbWVyLnByb3RvdHlwZS5HZXRFbGFwc2VkVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9lbmQgLSB0aGlzLm1fc3RhcnQ7XG4gICAgfTtcbiAgICAvLyBWZWMzIGNsYXNzXG4gICAgbW9kdWxlLlZlYzMgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICB0aGlzLm1feCA9IHg7XG4gICAgICAgIHRoaXMubV95ID0geTtcbiAgICAgICAgdGhpcy5tX3ogPSB6O1xuICAgIH07XG4gICAgbW9kdWxlLlZlYzMucHJvdG90eXBlLlNldCA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgIHRoaXMubV94ID0geDtcbiAgICAgICAgdGhpcy5tX3kgPSB5O1xuICAgICAgICB0aGlzLm1feiA9IHo7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjMy5wcm90b3R5cGUuU3ViID0gZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgIHRoaXMubV94ID0gbGhzLm1feCAtIHJocy5tX3g7XG4gICAgICAgIHRoaXMubV95ID0gbGhzLm1feSAtIHJocy5tX3k7XG4gICAgICAgIHRoaXMubV96ID0gbGhzLm1feiAtIHJocy5tX3o7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjMy5wcm90b3R5cGUuQWRkID0gZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgIHRoaXMubV94ID0gbGhzLm1feCArIHJocy5tX3g7XG4gICAgICAgIHRoaXMubV95ID0gbGhzLm1feSArIHJocy5tX3k7XG4gICAgICAgIHRoaXMubV96ID0gbGhzLm1feiArIHJocy5tX3o7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjMy5wcm90b3R5cGUuU2VsZkFkZCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXMubV94ICs9IHYubV94O1xuICAgICAgICB0aGlzLm1feSArPSB2Lm1feTtcbiAgICAgICAgdGhpcy5tX3ogKz0gdi5tX3o7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjMy5wcm90b3R5cGUuQ3Jvc3MgPSBmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgdGhpcy5tX3ggPSBsaHMubV95ICogcmhzLm1feiAtIGxocy5tX3ogKiByaHMubV95O1xuICAgICAgICB0aGlzLm1feSA9IGxocy5tX3ogKiByaHMubV94IC0gbGhzLm1feCAqIHJocy5tX3o7XG4gICAgICAgIHRoaXMubV96ID0gbGhzLm1feCAqIHJocy5tX3kgLSBsaHMubV95ICogcmhzLm1feDtcbiAgICB9O1xuICAgIG1vZHVsZS5WZWMzLnByb3RvdHlwZS5HZXROb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubV94ICogdGhpcy5tX3ggKyB0aGlzLm1feSAqIHRoaXMubV95ICsgdGhpcy5tX3ogKiB0aGlzLm1feik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBTcGhlcmVUb0N1YmUodmluLCB2b3V0KSB7XG4gICAgICAgIHZhciBheCwgYXksIGF6O1xuICAgICAgICBheCA9IE1hdGguYWJzKHZpbi5tX3gpO1xuICAgICAgICBheSA9IE1hdGguYWJzKHZpbi5tX3kpO1xuICAgICAgICBheiA9IE1hdGguYWJzKHZpbi5tX3opO1xuICAgICAgICBpZiAoYXogPj0gYXggJiYgYXogPj0gYXkpIHtcbiAgICAgICAgICAgIGlmICh2aW4ubV96ID49IDApIHtcbiAgICAgICAgICAgICAgICB2b3V0Lm1feiA9IDA7XG4gICAgICAgICAgICAgICAgdm91dC5tX3ggPSB2aW4ubV94O1xuICAgICAgICAgICAgICAgIHZvdXQubV95ID0gdmluLm1feTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdm91dC5tX3ogPSAxO1xuICAgICAgICAgICAgICAgIHZvdXQubV94ID0gLXZpbi5tX3g7XG4gICAgICAgICAgICAgICAgdm91dC5tX3kgPSAtdmluLm1feTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChheSA+PSBheCAmJiBheSA+PSBheikge1xuICAgICAgICAgICAgaWYgKHZpbi5tX3kgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZvdXQubV96ID0gMjtcbiAgICAgICAgICAgICAgICB2b3V0Lm1feCA9IHZpbi5tX3o7XG4gICAgICAgICAgICAgICAgdm91dC5tX3kgPSB2aW4ubV94O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b3V0Lm1feiA9IDM7XG4gICAgICAgICAgICAgICAgdm91dC5tX3ggPSAtdmluLm1fejtcbiAgICAgICAgICAgICAgICB2b3V0Lm1feSA9IC12aW4ubV94O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZpbi5tX3ggPj0gMCkge1xuICAgICAgICAgICAgICAgIHZvdXQubV96ID0gNDtcbiAgICAgICAgICAgICAgICB2b3V0Lm1feCA9IHZpbi5tX3k7XG4gICAgICAgICAgICAgICAgdm91dC5tX3kgPSB2aW4ubV96O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b3V0Lm1feiA9IDU7XG4gICAgICAgICAgICAgICAgdm91dC5tX3ggPSAtdmluLm1feTtcbiAgICAgICAgICAgICAgICB2b3V0Lm1feSA9IC12aW4ubV96O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsLkN1YmVUb1NwaGVyZSA9IHtcbiAgICAgICAgMDogZnVuY3Rpb24gKHZpbiwgdm91dCkge1xuICAgICAgICAgICAgdm91dC5tX3ggPSB2aW4ubV94O1xuICAgICAgICAgICAgdm91dC5tX3kgPSB2aW4ubV95O1xuICAgICAgICAgICAgdm91dC5tX3ogPSBNYXRoLnNxcnQoTWF0aC5tYXgoMC4wLCAxLjAgLSB2b3V0Lm1feCAqIHZvdXQubV94IC0gdm91dC5tX3kgKiB2b3V0Lm1feSkpO1xuICAgICAgICB9LFxuICAgICAgICAxOiBmdW5jdGlvbiAodmluLCB2b3V0KSB7XG4gICAgICAgICAgICB2b3V0Lm1feCA9IC12aW4ubV94O1xuICAgICAgICAgICAgdm91dC5tX3kgPSAtdmluLm1feTtcbiAgICAgICAgICAgIHZvdXQubV96ID0gLU1hdGguc3FydChNYXRoLm1heCgwLjAsIDEuMCAtIHZvdXQubV94ICogdm91dC5tX3ggLSB2b3V0Lm1feSAqIHZvdXQubV95KSk7XG4gICAgICAgIH0sXG4gICAgICAgIDI6IGZ1bmN0aW9uICh2aW4sIHZvdXQpIHtcbiAgICAgICAgICAgIHZvdXQubV96ID0gdmluLm1feDtcbiAgICAgICAgICAgIHZvdXQubV94ID0gdmluLm1feTtcbiAgICAgICAgICAgIHZvdXQubV95ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAuMCwgMS4wIC0gdm91dC5tX3ggKiB2b3V0Lm1feCAtIHZvdXQubV96ICogdm91dC5tX3opKTtcbiAgICAgICAgfSxcbiAgICAgICAgMzogZnVuY3Rpb24gKHZpbiwgdm91dCkge1xuICAgICAgICAgICAgdm91dC5tX3ogPSAtdmluLm1feDtcbiAgICAgICAgICAgIHZvdXQubV94ID0gLXZpbi5tX3k7XG4gICAgICAgICAgICB2b3V0Lm1feSA9IC1NYXRoLnNxcnQoTWF0aC5tYXgoMC4wLCAxLjAgLSB2b3V0Lm1feCAqIHZvdXQubV94IC0gdm91dC5tX3ogKiB2b3V0Lm1feikpO1xuICAgICAgICB9LFxuICAgICAgICA0OiBmdW5jdGlvbiAodmluLCB2b3V0KSB7XG4gICAgICAgICAgICB2b3V0Lm1feSA9IHZpbi5tX3g7XG4gICAgICAgICAgICB2b3V0Lm1feiA9IHZpbi5tX3k7XG4gICAgICAgICAgICB2b3V0Lm1feCA9IE1hdGguc3FydChNYXRoLm1heCgwLjAsIDEuMCAtIHZvdXQubV95ICogdm91dC5tX3kgLSB2b3V0Lm1feiAqIHZvdXQubV96KSk7XG4gICAgICAgIH0sXG4gICAgICAgIDU6IGZ1bmN0aW9uICh2aW4sIHZvdXQpIHtcbiAgICAgICAgICAgIHZvdXQubV95ID0gLXZpbi5tX3g7XG4gICAgICAgICAgICB2b3V0Lm1feiA9IC12aW4ubV95O1xuICAgICAgICAgICAgdm91dC5tX3ggPSAtTWF0aC5zcXJ0KE1hdGgubWF4KDAuMCwgMS4wIC0gdm91dC5tX3kgKiB2b3V0Lm1feSAtIHZvdXQubV96ICogdm91dC5tX3opKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gSW50VG9VSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgPCAwKSA/ICgtMSAtICgyICogdmFsdWUpKSA6ICgyICogdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVSW50VG9JbnQodWlWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKHVpVmFsdWUgJiAxKSA/IC0oKHVpVmFsdWUgKyAxKSA+Pj4gMSkgOiAoKHVpVmFsdWUgPj4+IDEpKTtcbiAgICB9XG4gICAgbW9kdWxlLkl0ZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fY291bnQgPSAwO1xuICAgIH07XG4gICAgbW9kdWxlLk51bWJlclJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tX3ZhbHVlID0gMDtcbiAgICB9O1xuICAgIC8vIEJpbmFyeVN0cmVhbSBjbGFzc1xuICAgIG1vZHVsZS5CaW5hcnlTdHJlYW0gPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMubV9lbmRpYW5uZXNzID0gU3lzdGVtRW5kaWFubmVzcygpO1xuICAgICAgICB0aGlzLm1fYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLm1fc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tX2J1ZmZlcik7XG4gICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOCA9IG5ldyBVaW50OEFycmF5KHRoaXMubV9sb2NhbEJ1ZmZlcik7XG4gICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdGbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1fbG9jYWxCdWZmZXIpO1xuICAgICAgICB0aGlzLm1fbG9jYWxCdWZmZXJWaWV3VUludDMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMubV9sb2NhbEJ1ZmZlcik7XG4gICAgfTtcbiAgICBtb2R1bGUuQmluYXJ5U3RyZWFtLnByb3RvdHlwZS5SZWFkRmxvYXQzMkJpbiA9IGZ1bmN0aW9uIChic0l0ZXJhdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLm1fZW5kaWFubmVzcyA9PT0gbG9jYWwuTzNER0NfQklHX0VORElBTikge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFszXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFsyXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFsxXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFswXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFswXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFsxXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFsyXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFszXSA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxCdWZmZXJWaWV3RmxvYXQzMlswXTtcbiAgICB9O1xuICAgIG1vZHVsZS5CaW5hcnlTdHJlYW0ucHJvdG90eXBlLlJlYWRVSW50MzJCaW4gPSBmdW5jdGlvbiAoYnNJdGVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5tX2VuZGlhbm5lc3MgPT09IGxvY2FsLk8zREdDX0JJR19FTkRJQU4pIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbM10gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMl0gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMV0gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMF0gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMF0gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMV0gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMl0gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbM10gPSB0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VJbnQzMlswXTtcbiAgICB9O1xuICAgIG1vZHVsZS5CaW5hcnlTdHJlYW0ucHJvdG90eXBlLlJlYWRVQ2hhcjhCaW4gPSBmdW5jdGlvbiAoYnNJdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3N0cmVhbVtic0l0ZXJhdG9yLm1fY291bnQrK107XG4gICAgfTtcbiAgICBtb2R1bGUuQmluYXJ5U3RyZWFtLnByb3RvdHlwZS5SZWFkVUludDMyQVNDSUkgPSBmdW5jdGlvbiAoYnNJdGVyYXRvcikge1xuICAgICAgICB2YXIgdmFsdWUsIHNoaWZ0LCBpO1xuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxvY2FsLk8zREdDX0JJTkFSWV9TVFJFQU1fTlVNX1NZTUJPTFNfVUlOVDMyOyArK2kpIHtcbiAgICAgICAgICAgIHZhbHVlICs9ICh0aGlzLm1fc3RyZWFtW2JzSXRlcmF0b3IubV9jb3VudCsrXSA8PCBzaGlmdCkgPj4+IDA7XG4gICAgICAgICAgICBzaGlmdCArPSBsb2NhbC5PM0RHQ19CSU5BUllfU1RSRUFNX0JJVFNfUEVSX1NZTUJPTDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgbW9kdWxlLkJpbmFyeVN0cmVhbS5wcm90b3R5cGUuUmVhZEZsb2F0MzJBU0NJSSA9IGZ1bmN0aW9uIChic0l0ZXJhdG9yKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuUmVhZFVJbnQzMkFTQ0lJKGJzSXRlcmF0b3IpO1xuICAgICAgICBpZiAodGhpcy5tX2VuZGlhbm5lc3MgPT09IGxvY2FsLk8zREdDX0JJR19FTkRJQU4pIHtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbM10gPSB2YWx1ZSAmIGxvY2FsLk8zREdDX01BWF9VQ0hBUjg7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxCdWZmZXJWaWV3VUNoYXI4WzJdID0gdmFsdWUgJiBsb2NhbC5PM0RHQ19NQVhfVUNIQVI4O1xuICAgICAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFsxXSA9IHZhbHVlICYgbG9jYWwuTzNER0NfTUFYX1VDSEFSODtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMF0gPSB2YWx1ZSAmIGxvY2FsLk8zREdDX01BWF9VQ0hBUjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxCdWZmZXJWaWV3VUNoYXI4WzBdID0gdmFsdWUgJiBsb2NhbC5PM0RHQ19NQVhfVUNIQVI4O1xuICAgICAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgICAgICAgICAgdGhpcy5tX2xvY2FsQnVmZmVyVmlld1VDaGFyOFsxXSA9IHZhbHVlICYgbG9jYWwuTzNER0NfTUFYX1VDSEFSODtcbiAgICAgICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICAgICAgICAgIHRoaXMubV9sb2NhbEJ1ZmZlclZpZXdVQ2hhcjhbMl0gPSB2YWx1ZSAmIGxvY2FsLk8zREdDX01BWF9VQ0hBUjg7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgICAgICAgICB0aGlzLm1fbG9jYWxCdWZmZXJWaWV3VUNoYXI4WzNdID0gdmFsdWUgJiBsb2NhbC5PM0RHQ19NQVhfVUNIQVI4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1fbG9jYWxCdWZmZXJWaWV3RmxvYXQzMlswXTtcbiAgICB9O1xuICAgIG1vZHVsZS5CaW5hcnlTdHJlYW0ucHJvdG90eXBlLlJlYWRJbnRBU0NJSSA9IGZ1bmN0aW9uIChic0l0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBVSW50VG9JbnQodGhpcy5SZWFkVUludEFTQ0lJKGJzSXRlcmF0b3IpKTtcbiAgICB9O1xuICAgIG1vZHVsZS5CaW5hcnlTdHJlYW0ucHJvdG90eXBlLlJlYWRVSW50QVNDSUkgPSBmdW5jdGlvbiAoYnNJdGVyYXRvcikge1xuICAgICAgICB2YXIgaSwgeCwgdmFsdWU7XG4gICAgICAgIHZhbHVlID0gdGhpcy5tX3N0cmVhbVtic0l0ZXJhdG9yLm1fY291bnQrK107XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbG9jYWwuTzNER0NfQklOQVJZX1NUUkVBTV9NQVhfU1lNQk9MMCkge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgeCA9IHRoaXMubV9zdHJlYW1bYnNJdGVyYXRvci5tX2NvdW50KytdO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9ICgoeCA+Pj4gMSkgPDwgaSkgPj4+IDA7XG4gICAgICAgICAgICAgICAgaSArPSBsb2NhbC5PM0RHQ19CSU5BUllfU1RSRUFNX0JJVFNfUEVSX1NZTUJPTDE7XG4gICAgICAgICAgICB9IHdoaWxlICh4ICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgbW9kdWxlLkJpbmFyeVN0cmVhbS5wcm90b3R5cGUuUmVhZFVDaGFyQVNDSUkgPSBmdW5jdGlvbiAoYnNJdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3N0cmVhbVtic0l0ZXJhdG9yLm1fY291bnQrK107XG4gICAgfTtcbiAgICBtb2R1bGUuQmluYXJ5U3RyZWFtLnByb3RvdHlwZS5SZWFkRmxvYXQzMiA9IGZ1bmN0aW9uIChic0l0ZXJhdG9yLCBzdHJlYW1UeXBlKSB7XG4gICAgICAgIGlmIChzdHJlYW1UeXBlID09PSBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9BU0NJSSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuUmVhZEZsb2F0MzJBU0NJSShic0l0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5SZWFkRmxvYXQzMkJpbihic0l0ZXJhdG9yKTtcbiAgICB9O1xuICAgIG1vZHVsZS5CaW5hcnlTdHJlYW0ucHJvdG90eXBlLlJlYWRVSW50MzIgPSBmdW5jdGlvbiAoYnNJdGVyYXRvciwgc3RyZWFtVHlwZSkge1xuICAgICAgICBpZiAoc3RyZWFtVHlwZSA9PT0gbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlJlYWRVSW50MzJBU0NJSShic0l0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5SZWFkVUludDMyQmluKGJzSXRlcmF0b3IpO1xuICAgIH07XG4gICAgbW9kdWxlLkJpbmFyeVN0cmVhbS5wcm90b3R5cGUuUmVhZFVDaGFyID0gZnVuY3Rpb24gKGJzSXRlcmF0b3IsIHN0cmVhbVR5cGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbVR5cGUgPT09IGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0FTQ0lJKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5SZWFkVUNoYXJBU0NJSShic0l0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5SZWFkVUNoYXI4QmluKGJzSXRlcmF0b3IpO1xuICAgIH07XG4gICAgbW9kdWxlLkJpbmFyeVN0cmVhbS5wcm90b3R5cGUuR2V0QnVmZmVyID0gZnVuY3Rpb24gKGJzSXRlcmF0b3IsIHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMubV9idWZmZXIsIGJzSXRlcmF0b3IubV9jb3VudCwgc2l6ZSk7XG4gICAgfTtcblxuICAgIC8vIENvcHlyaWdodCAoYykgMjAwNCBBbWlyIFNhaWQgKHNhaWRAaWVlZS5vcmcpICYgV2lsbGlhbSBBLiBQZWFybG1hbiAocGVhcmx3QGVjc2UucnBpLmVkdSlcbiAgICAvLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICAgbG9jYWwuTzNER0NfQUNfTUlOX0xFTkdUSCA9IDB4MDEwMDAwMDA7ICAgLy8gdGhyZXNob2xkIGZvciByZW5vcm1hbGl6YXRpb25cbiAgICBsb2NhbC5PM0RHQ19BQ19NQVhfTEVOR1RIID0gMHhGRkZGRkZGRjsgICAgICAvLyBtYXhpbXVtIEFDIGludGVydmFsIGxlbmd0aFxuICAgIGxvY2FsLk8zREdDX0FDX0JNX0xFTkdUSF9TSElGVCA9IDEzOyAgICAgLy8gTWF4aW11bSB2YWx1ZXMgZm9yIGJpbmFyeSBtb2RlbHMgbGVuZ3RoIGJpdHMgZGlzY2FyZGVkIGJlZm9yZSBtdWx0LlxuICAgIGxvY2FsLk8zREdDX0FDX0JNX01BWF9DT1VOVCA9ICgxIDw8IGxvY2FsLk8zREdDX0FDX0JNX0xFTkdUSF9TSElGVCkgPj4+IDA7ICAvLyBmb3IgYWRhcHRpdmUgbW9kZWxzXG4gICAgbG9jYWwuTzNER0NfQUNfRE1fTEVOR1RIX1NISUZUID0gMTU7IC8vIE1heGltdW0gdmFsdWVzIGZvciBnZW5lcmFsIG1vZGVscyBsZW5ndGggYml0cyBkaXNjYXJkZWQgYmVmb3JlIG11bHQuXG4gICAgbG9jYWwuTzNER0NfQUNfRE1fTUFYX0NPVU5UID0gKDEgPDwgbG9jYWwuTzNER0NfQUNfRE1fTEVOR1RIX1NISUZUKSA+Pj4gMDsgIC8vIGZvciBhZGFwdGl2ZSBtb2RlbHNcbiAgICAvLyBTdGF0aWNCaXRNb2RlbCBjbGFzcyBcbiAgICBtb2R1bGUuU3RhdGljQml0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9iaXQwUHJvYiA9ICgxIDw8IChsb2NhbC5PM0RHQ19BQ19CTV9MRU5HVEhfU0hJRlQgLSAxKSkgPj4+IDA7IC8vIHAwID0gMC41XG4gICAgfTtcbiAgICBtb2R1bGUuU3RhdGljQml0TW9kZWwucHJvdG90eXBlLlNldFByb2JhYmlsaXR5ID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdGhpcy5tX2JpdDBQcm9iID0gTWF0aC5mbG9vcihwICogKCgxIDw8IGxvY2FsLk8zREdDX0FDX0JNX0xFTkdUSF9TSElGVCkgPj4+IDApKTtcbiAgICB9O1xuICAgIC8vIEFkYXB0aXZlQml0TW9kZWwgY2xhc3MgXG4gICAgbW9kdWxlLkFkYXB0aXZlQml0TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uIHRvIGVxdWlwcm9iYWJsZSBtb2RlbFxuICAgICAgICB0aGlzLm1fdXBkYXRlQ3ljbGUgPSA0O1xuICAgICAgICB0aGlzLm1fYml0c1VudGlsVXBkYXRlID0gNDtcbiAgICAgICAgdGhpcy5tX2JpdDBQcm9iID0gKDEgPDwgKGxvY2FsLk8zREdDX0FDX0JNX0xFTkdUSF9TSElGVCAtIDEpKSA+Pj4gMDtcbiAgICAgICAgdGhpcy5tX2JpdDBDb3VudCA9IDE7XG4gICAgICAgIHRoaXMubV9iaXRDb3VudCA9IDI7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRhcHRpdmVCaXRNb2RlbC5wcm90b3R5cGUuUmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV91cGRhdGVDeWNsZSA9IDQ7XG4gICAgICAgIHRoaXMubV9iaXRzVW50aWxVcGRhdGUgPSA0O1xuICAgICAgICB0aGlzLm1fYml0MFByb2IgPSAoMSA8PCAobG9jYWwuTzNER0NfQUNfQk1fTEVOR1RIX1NISUZUIC0gMSkpID4+PiAwO1xuICAgICAgICB0aGlzLm1fYml0MENvdW50ID0gMTtcbiAgICAgICAgdGhpcy5tX2JpdENvdW50ID0gMjtcbiAgICB9O1xuICAgIG1vZHVsZS5BZGFwdGl2ZUJpdE1vZGVsLnByb3RvdHlwZS5VcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGhhbHZlIGNvdW50cyB3aGVuIGEgdGhyZXNob2xkIGlzIHJlYWNoZWRcbiAgICAgICAgaWYgKCh0aGlzLm1fYml0Q291bnQgKz0gdGhpcy5tX3VwZGF0ZUN5Y2xlKSA+IGxvY2FsLk8zREdDX0FDX0JNX01BWF9DT1VOVCkge1xuICAgICAgICAgICAgdGhpcy5tX2JpdENvdW50ID0gKHRoaXMubV9iaXRDb3VudCArIDEpID4+PiAxO1xuICAgICAgICAgICAgdGhpcy5tX2JpdDBDb3VudCA9ICh0aGlzLm1fYml0MENvdW50ICsgMSkgPj4+IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5tX2JpdDBDb3VudCA9PT0gdGhpcy5tX2JpdENvdW50KSB7XG4gICAgICAgICAgICAgICAgKyt0aGlzLm1fYml0Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBzY2FsZWQgYml0IDAgcHJvYmFiaWxpdHlcbiAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5mbG9vcigweDgwMDAwMDAwIC8gdGhpcy5tX2JpdENvdW50KTtcbiAgICAgICAgdGhpcy5tX2JpdDBQcm9iID0gKHRoaXMubV9iaXQwQ291bnQgKiBzY2FsZSkgPj4+ICgzMSAtIGxvY2FsLk8zREdDX0FDX0JNX0xFTkdUSF9TSElGVCk7XG4gICAgICAgIC8vIHNldCBmcmVxdWVuY3kgb2YgbW9kZWwgdXBkYXRlc1xuICAgICAgICB0aGlzLm1fdXBkYXRlQ3ljbGUgPSAoNSAqIHRoaXMubV91cGRhdGVDeWNsZSkgPj4+IDI7XG4gICAgICAgIGlmICh0aGlzLm1fdXBkYXRlQ3ljbGUgPiA2NCkge1xuICAgICAgICAgICAgdGhpcy5tX3VwZGF0ZUN5Y2xlID0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX2JpdHNVbnRpbFVwZGF0ZSA9IHRoaXMubV91cGRhdGVDeWNsZTtcbiAgICB9O1xuICAgIC8vIEFkYXB0aXZlRGF0YU1vZGVsIGNsYXNzIFxuICAgIG1vZHVsZS5BZGFwdGl2ZURhdGFNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tX2J1ZmZlciA9IHt9O1xuICAgICAgICB0aGlzLm1fZGlzdHJpYnV0aW9uID0ge307XG4gICAgICAgIHRoaXMubV9zeW1ib2xDb3VudCA9IHt9O1xuICAgICAgICB0aGlzLm1fZGVjb2RlclRhYmxlID0ge307XG4gICAgICAgIHRoaXMubV90b3RhbENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX3VwZGF0ZUN5Y2xlID0gMDtcbiAgICAgICAgdGhpcy5tX3N5bWJvbHNVbnRpbFVwZGF0ZSA9IDA7XG4gICAgICAgIHRoaXMubV9kYXRhU3ltYm9scyA9IDA7XG4gICAgICAgIHRoaXMubV9sYXN0U3ltYm9sID0gMDtcbiAgICAgICAgdGhpcy5tX3RhYmxlU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubV90YWJsZVNoaWZ0ID0gMDtcbiAgICB9O1xuICAgIG1vZHVsZS5BZGFwdGl2ZURhdGFNb2RlbC5wcm90b3R5cGUuVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiwgc3VtLCBzLCBzY2FsZSwgaywgbWF4X2N5Y2xlLCB3O1xuICAgICAgICAvLyBoYWx2ZSBjb3VudHMgd2hlbiBhIHRocmVzaG9sZCBpcyByZWFjaGVkXG4gICAgICAgIGlmICgodGhpcy5tX3RvdGFsQ291bnQgKz0gdGhpcy5tX3VwZGF0ZUN5Y2xlKSA+IGxvY2FsLk8zREdDX0FDX0RNX01BWF9DT1VOVCkge1xuICAgICAgICAgICAgdGhpcy5tX3RvdGFsQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChuID0gMDsgbiA8IHRoaXMubV9kYXRhU3ltYm9sczsgKytuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3RvdGFsQ291bnQgKz0gKHRoaXMubV9zeW1ib2xDb3VudFtuXSA9ICh0aGlzLm1fc3ltYm9sQ291bnRbbl0gKyAxKSA+Pj4gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcHV0ZSBjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiwgZGVjb2RlciB0YWJsZVxuICAgICAgICBzdW0gPSAwO1xuICAgICAgICBzID0gMDtcbiAgICAgICAgc2NhbGUgPSBNYXRoLmZsb29yKDB4ODAwMDAwMDAgLyB0aGlzLm1fdG90YWxDb3VudCk7XG4gICAgICAgIGlmICh0aGlzLm1fdGFibGVTaXplID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdGhpcy5tX2RhdGFTeW1ib2xzOyArK2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZGlzdHJpYnV0aW9uW2tdID0gKHNjYWxlICogc3VtKSA+Pj4gKDMxIC0gbG9jYWwuTzNER0NfQUNfRE1fTEVOR1RIX1NISUZUKTtcbiAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5tX3N5bWJvbENvdW50W2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IHRoaXMubV9kYXRhU3ltYm9sczsgKytrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2Rpc3RyaWJ1dGlvbltrXSA9IChzY2FsZSAqIHN1bSkgPj4+ICgzMSAtIGxvY2FsLk8zREdDX0FDX0RNX0xFTkdUSF9TSElGVCk7XG4gICAgICAgICAgICAgICAgc3VtICs9IHRoaXMubV9zeW1ib2xDb3VudFtrXTtcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy5tX2Rpc3RyaWJ1dGlvbltrXSA+Pj4gdGhpcy5tX3RhYmxlU2hpZnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHMgPCB3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9kZWNvZGVyVGFibGVbKytzXSA9IGsgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9kZWNvZGVyVGFibGVbMF0gPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHMgPD0gdGhpcy5tX3RhYmxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9kZWNvZGVyVGFibGVbKytzXSA9IHRoaXMubV9kYXRhU3ltYm9scyAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGZyZXF1ZW5jeSBvZiBtb2RlbCB1cGRhdGVzXG4gICAgICAgIHRoaXMubV91cGRhdGVDeWNsZSA9ICg1ICogdGhpcy5tX3VwZGF0ZUN5Y2xlKSA+Pj4gMjtcbiAgICAgICAgbWF4X2N5Y2xlID0gKCh0aGlzLm1fZGF0YVN5bWJvbHMgKyA2KSA8PCAzKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMubV91cGRhdGVDeWNsZSA+IG1heF9jeWNsZSkge1xuICAgICAgICAgICAgdGhpcy5tX3VwZGF0ZUN5Y2xlID0gbWF4X2N5Y2xlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubV9zeW1ib2xzVW50aWxVcGRhdGUgPSB0aGlzLm1fdXBkYXRlQ3ljbGU7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRhcHRpdmVEYXRhTW9kZWwucHJvdG90eXBlLlJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgaWYgKHRoaXMubV9kYXRhU3ltYm9scyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc3RvcmUgcHJvYmFiaWxpdHkgZXN0aW1hdGVzIHRvIHVuaWZvcm0gZGlzdHJpYnV0aW9uXG4gICAgICAgIHRoaXMubV90b3RhbENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX3VwZGF0ZUN5Y2xlID0gdGhpcy5tX2RhdGFTeW1ib2xzO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdGhpcy5tX2RhdGFTeW1ib2xzOyArK2spIHtcbiAgICAgICAgICAgIHRoaXMubV9zeW1ib2xDb3VudFtrXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5VcGRhdGUoKTtcbiAgICAgICAgdGhpcy5tX3N5bWJvbHNVbnRpbFVwZGF0ZSA9IHRoaXMubV91cGRhdGVDeWNsZSA9ICh0aGlzLm1fZGF0YVN5bWJvbHMgKyA2KSA+Pj4gMTtcbiAgICB9O1xuICAgIG1vZHVsZS5BZGFwdGl2ZURhdGFNb2RlbC5wcm90b3R5cGUuU2V0QWxwaGFiZXQgPSBmdW5jdGlvbiAobnVtYmVyX29mX3N5bWJvbHMpIHtcbiAgICAgICAgaWYgKChudW1iZXJfb2Zfc3ltYm9scyA8IDIpIHx8IChudW1iZXJfb2Zfc3ltYm9scyA+ICgxIDw8IDExKSkpIHtcbiAgICAgICAgICAgIENvbnNvbGUubG9nKFwiaW52YWxpZCBudW1iZXIgb2YgZGF0YSBzeW1ib2xzXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19FUlJPUl9BQztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tX2RhdGFTeW1ib2xzICE9PSBudW1iZXJfb2Zfc3ltYm9scykgeyAvLyBhc3NpZ24gbWVtb3J5IGZvciBkYXRhIG1vZGVsXG4gICAgICAgICAgICB0aGlzLm1fZGF0YVN5bWJvbHMgPSBudW1iZXJfb2Zfc3ltYm9scztcbiAgICAgICAgICAgIHRoaXMubV9sYXN0U3ltYm9sID0gdGhpcy5tX2RhdGFTeW1ib2xzIC0gMTtcbiAgICAgICAgICAgIC8vIGRlZmluZSBzaXplIG9mIHRhYmxlIGZvciBmYXN0IGRlY29kaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5tX2RhdGFTeW1ib2xzID4gMTYpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFibGVfYml0cyA9IDM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMubV9kYXRhU3ltYm9scyA+ICgoMSA8PCAodGFibGVfYml0cyArIDIpKSA+Pj4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKyt0YWJsZV9iaXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1fdGFibGVTaXplID0gKDEgPDwgdGFibGVfYml0cykgPj4+IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3RhYmxlU2hpZnQgPSBsb2NhbC5PM0RHQ19BQ19ETV9MRU5HVEhfU0hJRlQgLSB0YWJsZV9iaXRzO1xuICAgICAgICAgICAgICAgIHRoaXMubV9idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCAqICgyICogdGhpcy5tX2RhdGFTeW1ib2xzICsgdGhpcy5tX3RhYmxlU2l6ZSArIDIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZGlzdHJpYnV0aW9uID0gbmV3IFVpbnQzMkFycmF5KHRoaXMubV9idWZmZXIsIDAsIHRoaXMubV9kYXRhU3ltYm9scyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3N5bWJvbENvdW50ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMubV9idWZmZXIsIDQgKiB0aGlzLm1fZGF0YVN5bWJvbHMsIHRoaXMubV9kYXRhU3ltYm9scyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2RlY29kZXJUYWJsZSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLm1fYnVmZmVyLCA4ICogdGhpcy5tX2RhdGFTeW1ib2xzLCB0aGlzLm1fdGFibGVTaXplICsgMik7XG4gICAgICAgICAgICB9IGVsc2Ugey8vIHNtYWxsIGFscGhhYmV0OiBubyB0YWJsZSBuZWVkZWRcbiAgICAgICAgICAgICAgICB0aGlzLm1fdGFibGVTaXplID0gdGhpcy5tX3RhYmxlU2hpZnQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubV9idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCAqIDIgKiB0aGlzLm1fZGF0YVN5bWJvbHMpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9kaXN0cmlidXRpb24gPSBuZXcgVWludDMyQXJyYXkodGhpcy5tX2J1ZmZlciwgMCwgdGhpcy5tX2RhdGFTeW1ib2xzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fc3ltYm9sQ291bnQgPSBuZXcgVWludDMyQXJyYXkodGhpcy5tX2J1ZmZlciwgNCAqIHRoaXMubV9kYXRhU3ltYm9scywgdGhpcy5tX2RhdGFTeW1ib2xzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fZGVjb2RlclRhYmxlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5SZXNldCgpOyAvLyBpbml0aWFsaXplIG1vZGVsXG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICAvLyBBcml0aG1ldGljRGVjb2RlciBjbGFzc1xuICAgIG1vZHVsZS5Bcml0aG1ldGljRGVjb2RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tX2NvZGVCdWZmZXIgPSB7fTtcbiAgICAgICAgdGhpcy5tX2FjU2hpZnQgPSAwO1xuICAgICAgICB0aGlzLm1fYmFzZSA9IDA7XG4gICAgICAgIHRoaXMubV92YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMubV9sZW5ndGggPSAwOyAvLyBhcml0aG1ldGljIGNvZGluZyBzdGF0ZVxuICAgICAgICB0aGlzLm1fYnVmZmVyU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubV9tb2RlID0gMDsgLy8gbW9kZTogMCA9IHVuZGVmLCAxID0gZW5jb2RlciwgMiA9IGRlY29kZXJcbiAgICB9O1xuICAgIG1vZHVsZS5Bcml0aG1ldGljRGVjb2Rlci5wcm90b3R5cGUuU2V0QnVmZmVyID0gZnVuY3Rpb24gKG1heF9jb2RlX2J5dGVzLCB1c2VyX2J1ZmZlcikge1xuICAgICAgICBpZiAobWF4X2NvZGVfYnl0ZXMgPT09IDApIHtcbiAgICAgICAgICAgIENvbnNvbGUubG9nKFwiaW52YWxpZCBjb2RlYyBidWZmZXIgc2l6ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfRVJST1JfQUM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubV9tb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBDb25zb2xlLmxvZyhcImNhbm5vdCBzZXQgYnVmZmVyIHdoaWxlIGVuY29kaW5nIG9yIGRlY29kaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19FUlJPUl9BQztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1fYnVmZmVyU2l6ZSA9IG1heF9jb2RlX2J5dGVzO1xuICAgICAgICB0aGlzLm1fY29kZUJ1ZmZlciA9IHVzZXJfYnVmZmVyO1xuICAgIH07XG4gICAgbW9kdWxlLkFyaXRobWV0aWNEZWNvZGVyLnByb3RvdHlwZS5TdGFydERlY29kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1fbW9kZSAhPT0gMCkge1xuICAgICAgICAgICAgQ29uc29sZS5sb2coXCJjYW5ub3Qgc3RhcnQgZGVjb2RlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfRVJST1JfQUM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubV9idWZmZXJTaXplID09PSAwKSB7XG4gICAgICAgICAgICBDb25zb2xlLmxvZyhcIm5vIGNvZGUgYnVmZmVyIHNldFwiKTtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfRVJST1JfQUM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBkZWNvZGVyOiBpbnRlcnZhbCwgcG9pbnRlciwgaW5pdGlhbCBjb2RlIHZhbHVlXG4gICAgICAgIHRoaXMubV9tb2RlID0gMjtcbiAgICAgICAgdGhpcy5tX2xlbmd0aCA9IGxvY2FsLk8zREdDX0FDX01BWF9MRU5HVEg7XG4gICAgICAgIHRoaXMubV9hY1NoaWZ0ID0gMztcbiAgICAgICAgdGhpcy5tX3ZhbHVlID0gKCh0aGlzLm1fY29kZUJ1ZmZlclswXSA8PCAyNCkgfCAodGhpcy5tX2NvZGVCdWZmZXJbMV0gPDwgMTYpIHwgKHRoaXMubV9jb2RlQnVmZmVyWzJdIDw8IDgpIHwgKHRoaXMubV9jb2RlQnVmZmVyWzNdKSkgPj4+IDA7XG4gICAgfTtcbiAgICBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIucHJvdG90eXBlLlN0b3BEZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tX21vZGUgIT09IDIpIHtcbiAgICAgICAgICAgIENvbnNvbGUubG9nKFwiaW52YWxpZCB0byBzdG9wIGRlY29kZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX0VSUk9SX0FDO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubV9tb2RlID0gMDtcbiAgICB9O1xuICAgIG1vZHVsZS5Bcml0aG1ldGljRGVjb2Rlci5wcm90b3R5cGUuR2V0Qml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fbGVuZ3RoID4+Pj0gMTsgLy8gaGFsdmUgaW50ZXJ2YWxcbiAgICAgICAgdmFyIGJpdCA9ICh0aGlzLm1fdmFsdWUgPj0gdGhpcy5tX2xlbmd0aCk7IC8vIGRlY29kZSBiaXRcbiAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgdGhpcy5tX3ZhbHVlIC09IHRoaXMubV9sZW5ndGg7IC8vIG1vdmUgYmFzZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1fbGVuZ3RoIDwgbG9jYWwuTzNER0NfQUNfTUlOX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhpcy5SZW5vcm1EZWNJbnRlcnZhbCgpOyAvLyByZW5vcm1hbGl6YXRpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYml0O1xuICAgIH07XG4gICAgbW9kdWxlLkFyaXRobWV0aWNEZWNvZGVyLnByb3RvdHlwZS5HZXRCaXRzID0gZnVuY3Rpb24gKGJpdHMpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKHRoaXMubV92YWx1ZSAvICh0aGlzLm1fbGVuZ3RoID4+Pj0gYml0cykpOyAvLyBkZWNvZGUgc3ltYm9sLCBjaGFuZ2UgbGVuZ3RoXG4gICAgICAgIHRoaXMubV92YWx1ZSAtPSB0aGlzLm1fbGVuZ3RoICogczsgLy8gdXBkYXRlIGludGVydmFsXG4gICAgICAgIGlmICh0aGlzLm1fbGVuZ3RoIDwgbG9jYWwuTzNER0NfQUNfTUlOX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhpcy5SZW5vcm1EZWNJbnRlcnZhbCgpOyAvLyByZW5vcm1hbGl6YXRpb25cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9O1xuICAgIG1vZHVsZS5Bcml0aG1ldGljRGVjb2Rlci5wcm90b3R5cGUuRGVjb2RlU3RhdGljQml0TW9kZWwgPSBmdW5jdGlvbiAoTSkge1xuICAgICAgICB2YXIgeCwgYml0O1xuICAgICAgICB4ID0gTS5tX2JpdDBQcm9iICogKHRoaXMubV9sZW5ndGggPj4+IGxvY2FsLk8zREdDX0FDX0JNX0xFTkdUSF9TSElGVCk7IC8vIHByb2R1Y3QgbCB4IHAwXG4gICAgICAgIGJpdCA9ICh0aGlzLm1fdmFsdWUgPj0geCk7IC8vIGRlY2lzaW9uXG4gICAgICAgIC8vIHVwZGF0ZSAmIHNoaWZ0IGludGVydmFsXG4gICAgICAgIGlmICghYml0KSB7XG4gICAgICAgICAgICB0aGlzLm1fbGVuZ3RoID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubV92YWx1ZSAtPSB4OyAvLyBzaGlmdGVkIGludGVydmFsIGJhc2UgPSAwXG4gICAgICAgICAgICB0aGlzLm1fbGVuZ3RoIC09IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubV9sZW5ndGggPCBsb2NhbC5PM0RHQ19BQ19NSU5fTEVOR1RIKSB7XG4gICAgICAgICAgICB0aGlzLlJlbm9ybURlY0ludGVydmFsKCk7IC8vIHJlbm9ybWFsaXphdGlvblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaXQ7IC8vIHJldHVybiBkYXRhIGJpdCB2YWx1ZVxuICAgIH07XG4gICAgbW9kdWxlLkFyaXRobWV0aWNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVBZGFwdGl2ZUJpdE1vZGVsID0gZnVuY3Rpb24gKE0pIHtcbiAgICAgICAgdmFyIHgsIGJpdDtcbiAgICAgICAgeCA9IE0ubV9iaXQwUHJvYiAqICh0aGlzLm1fbGVuZ3RoID4+PiBsb2NhbC5PM0RHQ19BQ19CTV9MRU5HVEhfU0hJRlQpOyAgIC8vIHByb2R1Y3QgbCB4IHAwXG4gICAgICAgIGJpdCA9ICh0aGlzLm1fdmFsdWUgPj0geCk7IC8vIGRlY2lzaW9uXG4gICAgICAgIC8vIHVwZGF0ZSBpbnRlcnZhbFxuICAgICAgICBpZiAoIWJpdCkge1xuICAgICAgICAgICAgdGhpcy5tX2xlbmd0aCA9IHg7XG4gICAgICAgICAgICArK00ubV9iaXQwQ291bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fdmFsdWUgLT0geDtcbiAgICAgICAgICAgIHRoaXMubV9sZW5ndGggLT0geDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tX2xlbmd0aCA8IGxvY2FsLk8zREdDX0FDX01JTl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRoaXMuUmVub3JtRGVjSW50ZXJ2YWwoKTsgLy8gcmVub3JtYWxpemF0aW9uXG4gICAgICAgIH1cbiAgICAgICAgaWYgKC0tTS5tX2JpdHNVbnRpbFVwZGF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgTS5VcGRhdGUoKTsgLy8gcGVyaW9kaWMgbW9kZWwgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdDsgLy8gcmV0dXJuIGRhdGEgYml0IHZhbHVlXG4gICAgfTtcbiAgICBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIucHJvdG90eXBlLkRlY29kZUFkYXB0aXZlRGF0YU1vZGVsID0gZnVuY3Rpb24gKE0pIHtcbiAgICAgICAgdmFyIG4sIHMsIHgsIHksIHQsIGR2LCB6LCBtO1xuICAgICAgICB5ID0gdGhpcy5tX2xlbmd0aDtcbiAgICAgICAgaWYgKE0ubV90YWJsZVNpemUgPiAwKSB7IC8vIHVzZSB0YWJsZSBsb29rLXVwIGZvciBmYXN0ZXIgZGVjb2RpbmdcbiAgICAgICAgICAgIGR2ID0gTWF0aC5mbG9vcih0aGlzLm1fdmFsdWUgLyAodGhpcy5tX2xlbmd0aCA+Pj49IGxvY2FsLk8zREdDX0FDX0RNX0xFTkdUSF9TSElGVCkpO1xuICAgICAgICAgICAgdCA9IGR2ID4+PiBNLm1fdGFibGVTaGlmdDtcbiAgICAgICAgICAgIHMgPSBNLm1fZGVjb2RlclRhYmxlW3RdOyAgICAgICAgIC8vIGluaXRpYWwgZGVjaXNpb24gYmFzZWQgb24gdGFibGUgbG9vay11cFxuICAgICAgICAgICAgbiA9IE0ubV9kZWNvZGVyVGFibGVbdCArIDFdICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gcyArIDEpIHsgLy8gZmluaXNoIHdpdGggYmlzZWN0aW9uIHNlYXJjaFxuICAgICAgICAgICAgICAgIG0gPSAocyArIG4pID4+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChNLm1fZGlzdHJpYnV0aW9uW21dID4gZHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IG07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcyA9IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcHV0ZSBwcm9kdWN0c1xuICAgICAgICAgICAgeCA9IE0ubV9kaXN0cmlidXRpb25bc10gKiB0aGlzLm1fbGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHMgIT09IE0ubV9sYXN0U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgeSA9IE0ubV9kaXN0cmlidXRpb25bcyArIDFdICogdGhpcy5tX2xlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gZGVjb2RlIHVzaW5nIG9ubHkgbXVsdGlwbGljYXRpb25zXG4gICAgICAgICAgICB4ID0gcyA9IDA7XG4gICAgICAgICAgICB0aGlzLm1fbGVuZ3RoID4+Pj0gbG9jYWwuTzNER0NfQUNfRE1fTEVOR1RIX1NISUZUO1xuICAgICAgICAgICAgbSA9IChuID0gTS5tX2RhdGFTeW1ib2xzKSA+Pj4gMTtcbiAgICAgICAgICAgIC8vIGRlY29kZSB2aWEgYmlzZWN0aW9uIHNlYXJjaFxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHogPSB0aGlzLm1fbGVuZ3RoICogTS5tX2Rpc3RyaWJ1dGlvblttXTtcbiAgICAgICAgICAgICAgICBpZiAoeiA+IHRoaXMubV92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBuID0gbTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHo7IC8vIHZhbHVlIGlzIHNtYWxsZXJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzID0gbTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHo7IC8vIHZhbHVlIGlzIGxhcmdlciBvciBlcXVhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKChtID0gKHMgKyBuKSA+Pj4gMSkgIT09IHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubV92YWx1ZSAtPSB4OyAvLyB1cGRhdGUgaW50ZXJ2YWxcbiAgICAgICAgdGhpcy5tX2xlbmd0aCA9IHkgLSB4O1xuICAgICAgICBpZiAodGhpcy5tX2xlbmd0aCA8IGxvY2FsLk8zREdDX0FDX01JTl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRoaXMuUmVub3JtRGVjSW50ZXJ2YWwoKTsgLy8gcmVub3JtYWxpemF0aW9uXG4gICAgICAgIH1cbiAgICAgICAgKytNLm1fc3ltYm9sQ291bnRbc107XG4gICAgICAgIGlmICgtLU0ubV9zeW1ib2xzVW50aWxVcGRhdGUgPT09IDApIHtcbiAgICAgICAgICAgIE0uVXBkYXRlKGZhbHNlKTsgLy8gcGVyaW9kaWMgbW9kZWwgdXBkYXRlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgICBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIucHJvdG90eXBlLkV4cEdvbG9tYkRlY29kZSA9IGZ1bmN0aW9uIChrLCBiTW9kZWwwLCBiTW9kZWwxKSB7XG4gICAgICAgIHZhciBzeW1ib2wsIGJpbmFyeV9zeW1ib2wsIGw7XG4gICAgICAgIHN5bWJvbCA9IDA7XG4gICAgICAgIGJpbmFyeV9zeW1ib2wgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBsID0gdGhpcy5EZWNvZGVBZGFwdGl2ZUJpdE1vZGVsKGJNb2RlbDEpO1xuICAgICAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgKz0gKDEgPDwgaykgPj4+IDA7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsKTtcbiAgICAgICAgd2hpbGUgKGstLSkgeyAvL25leHQgYmluYXJ5IHBhcnRcbiAgICAgICAgICAgIGlmICh0aGlzLkRlY29kZVN0YXRpY0JpdE1vZGVsKGJNb2RlbDApKSB7XG4gICAgICAgICAgICAgICAgYmluYXJ5X3N5bWJvbCA9IChiaW5hcnlfc3ltYm9sIHwgKDEgPDwgaykpID4+PiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc3ltYm9sICsgYmluYXJ5X3N5bWJvbCk7XG4gICAgfTtcbiAgICBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIucHJvdG90eXBlLlJlbm9ybURlY0ludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkbyB7IC8vIHJlYWQgbGVhc3Qtc2lnbmlmaWNhbnQgYnl0ZVxuICAgICAgICAgICAgdGhpcy5tX3ZhbHVlID0gKCh0aGlzLm1fdmFsdWUgPDwgOCkgfCB0aGlzLm1fY29kZUJ1ZmZlclsrK3RoaXMubV9hY1NoaWZ0XSkgPj4+IDA7XG4gICAgICAgICAgICB0aGlzLm1fbGVuZ3RoID0gKHRoaXMubV9sZW5ndGggPDwgOCkgPj4+IDA7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMubV9sZW5ndGggPCBsb2NhbC5PM0RHQ19BQ19NSU5fTEVOR1RIKTsgLy8gbGVuZ3RoIG11bHRpcGxpZWQgYnkgMjU2XG4gICAgfTtcbiAgICBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIucHJvdG90eXBlLkRlY29kZUludEFDRUdDID0gZnVuY3Rpb24gKG1Nb2RlbFZhbHVlcywgYk1vZGVsMCwgYk1vZGVsMSwgZXhwX2ssIE0pIHtcbiAgICAgICAgdmFyIHVpVmFsdWUgPSB0aGlzLkRlY29kZUFkYXB0aXZlRGF0YU1vZGVsKG1Nb2RlbFZhbHVlcyk7XG4gICAgICAgIGlmICh1aVZhbHVlID09PSBNKSB7XG4gICAgICAgICAgICB1aVZhbHVlICs9IHRoaXMuRXhwR29sb21iRGVjb2RlKGV4cF9rLCBiTW9kZWwwLCBiTW9kZWwxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVUludFRvSW50KHVpVmFsdWUpO1xuICAgIH07XG4gICAgbW9kdWxlLkFyaXRobWV0aWNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVVSW50QUNFR0MgPSBmdW5jdGlvbiAobU1vZGVsVmFsdWVzLCBiTW9kZWwwLCBiTW9kZWwxLCBleHBfaywgTSkge1xuICAgICAgICB2YXIgdWlWYWx1ZSA9IHRoaXMuRGVjb2RlQWRhcHRpdmVEYXRhTW9kZWwobU1vZGVsVmFsdWVzKTtcbiAgICAgICAgaWYgKHVpVmFsdWUgPT09IE0pIHtcbiAgICAgICAgICAgIHVpVmFsdWUgKz0gdGhpcy5FeHBHb2xvbWJEZWNvZGUoZXhwX2ssIGJNb2RlbDAsIGJNb2RlbDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aVZhbHVlO1xuICAgIH07XG5cbiAgICAvLyAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gICAgXG4gICAgLy8gRklGTyBjbGFzc1xuICAgIG1vZHVsZS5GSUZPID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLm1fYWxsb2NhdGVkID0gMDtcbiAgICAgICAgdGhpcy5tX3NpemUgPSAwO1xuICAgICAgICB0aGlzLm1fc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLm1fZW5kID0gMDtcbiAgICB9O1xuICAgIG1vZHVsZS5GSUZPLnByb3RvdHlwZS5DbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tX3N0YXJ0ID0gdGhpcy5tX2VuZCA9IHRoaXMubV9zaXplID0gMDtcbiAgICB9O1xuICAgIG1vZHVsZS5GSUZPLnByb3RvdHlwZS5HZXRBbGxvY2F0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2FsbG9jYXRlZDtcbiAgICB9O1xuICAgIG1vZHVsZS5GSUZPLnByb3RvdHlwZS5HZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3NpemU7XG4gICAgfTtcbiAgICBtb2R1bGUuRklGTy5wcm90b3R5cGUuQWxsb2NhdGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2l6ZSA+IHRoaXMubV9hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubV9hbGxvY2F0ZWQgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5tX2RhdGEgPSBuZXcgSW50MzJBcnJheSh0aGlzLm1fYWxsb2NhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLkNsZWFyKCk7XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuRklGTy5wcm90b3R5cGUuUG9wRmlyc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC0tdGhpcy5tX3NpemU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5tX3N0YXJ0Kys7XG4gICAgICAgIGlmICh0aGlzLm1fc3RhcnQgPT09IHRoaXMubV9hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubV9lbmQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1fZGF0YVtjdXJyZW50XTtcbiAgICB9O1xuICAgIG1vZHVsZS5GSUZPLnByb3RvdHlwZS5QdXNoQmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAtLXRoaXMubV9zaXplO1xuICAgICAgICB0aGlzLm1fZGF0YVt0aGlzLm1fZW5kXSA9IHZhbHVlO1xuICAgICAgICArK3RoaXMubV9zaXplO1xuICAgICAgICArK3RoaXMubV9lbmQ7XG4gICAgICAgIGlmICh0aGlzLm1fZW5kID09PSB0aGlzLm1fYWxsb2NhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1fZW5kID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSW5kZXhlZEZhY2VTZXQgY2xhc3NcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9uQ29vcmRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMubV9uQ29vcmQgPSAwO1xuICAgICAgICB0aGlzLm1fbk5vcm1hbCA9IDA7XG4gICAgICAgIHRoaXMubV9udW1GbG9hdEF0dHJpYnV0ZXMgPSAwO1xuICAgICAgICB0aGlzLm1fbnVtSW50QXR0cmlidXRlcyA9IDA7XG4gICAgICAgIHRoaXMubV9jcmVhc2VBbmdsZSA9IDMwLjA7XG4gICAgICAgIHRoaXMubV9jY3cgPSB0cnVlO1xuICAgICAgICB0aGlzLm1fc29saWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm1fY29udmV4ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tX2lzVHJpYW5ndWxhck1lc2ggPSB0cnVlO1xuICAgICAgICB0aGlzLm1fY29vcmRNaW4gPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICB0aGlzLm1fY29vcmRNYXggPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICB0aGlzLm1fbm9ybWFsTWluID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICAgICAgdGhpcy5tX25vcm1hbE1heCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgIHRoaXMubV9uRmxvYXRBdHRyaWJ1dGUgPSBuZXcgVWludDMyQXJyYXkobG9jYWwuTzNER0NfU0MzRE1DX01BWF9OVU1fRkxPQVRfQVRUUklCVVRFUyk7XG4gICAgICAgIHRoaXMubV9uSW50QXR0cmlidXRlID0gbmV3IFVpbnQzMkFycmF5KGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0lOVF9BVFRSSUJVVEVTKTtcbiAgICAgICAgdGhpcy5tX2RpbUZsb2F0QXR0cmlidXRlID0gbmV3IFVpbnQzMkFycmF5KGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0ZMT0FUX0FUVFJJQlVURVMpO1xuICAgICAgICB0aGlzLm1fZGltSW50QXR0cmlidXRlID0gbmV3IFVpbnQzMkFycmF5KGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0lOVF9BVFRSSUJVVEVTKTtcbiAgICAgICAgdGhpcy5tX3R5cGVGbG9hdEF0dHJpYnV0ZSA9IG5ldyBVaW50MzJBcnJheShsb2NhbC5PM0RHQ19TQzNETUNfTUFYX05VTV9GTE9BVF9BVFRSSUJVVEVTKTtcbiAgICAgICAgdGhpcy5tX3R5cGVJbnRBdHRyaWJ1dGUgPSBuZXcgVWludDMyQXJyYXkobG9jYWwuTzNER0NfU0MzRE1DX01BWF9OVU1fSU5UX0FUVFJJQlVURVMpO1xuICAgICAgICB0aGlzLm1fbWluRmxvYXRBdHRyaWJ1dGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCAqIGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0ZMT0FUX0FUVFJJQlVURVMgKiBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX0RJTV9BVFRSSUJVVEVTKTtcbiAgICAgICAgdGhpcy5tX21pbkZsb2F0QXR0cmlidXRlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1fbWluRmxvYXRBdHRyaWJ1dGVCdWZmZXIpO1xuICAgICAgICB0aGlzLm1fbWF4RmxvYXRBdHRyaWJ1dGVCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCAqIGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0ZMT0FUX0FUVFJJQlVURVMgKiBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX0RJTV9BVFRSSUJVVEVTKTtcbiAgICAgICAgdGhpcy5tX21heEZsb2F0QXR0cmlidXRlID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1fbWF4RmxvYXRBdHRyaWJ1dGVCdWZmZXIpO1xuICAgICAgICB0aGlzLm1fY29vcmRJbmRleCA9IHt9O1xuICAgICAgICB0aGlzLm1fY29vcmQgPSB7fTtcbiAgICAgICAgdGhpcy5tX25vcm1hbCA9IHt9O1xuICAgICAgICB0aGlzLm1fZmxvYXRBdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgdGhpcy5tX2ludEF0dHJpYnV0ZSA9IFtdO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXROQ29vcmRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9uQ29vcmRJbmRleDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0TkNvb3JkSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbkNvb3JkSW5kZXg7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldE5Db29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9uQ29vcmQ7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldE5Ob3JtYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbk5vcm1hbDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0TkZsb2F0QXR0cmlidXRlID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9uRmxvYXRBdHRyaWJ1dGVbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldE5JbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX25JbnRBdHRyaWJ1dGVbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldE51bUZsb2F0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9udW1GbG9hdEF0dHJpYnV0ZXM7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldE51bUludEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbnVtSW50QXR0cmlidXRlcztcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0Q29vcmRNaW5BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jb29yZE1pbjtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0Q29vcmRNYXhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jb29yZE1heDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0Tm9ybWFsTWluQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbm9ybWFsTWluO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXROb3JtYWxNYXhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9ub3JtYWxNYXg7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldEZsb2F0QXR0cmlidXRlTWluQXJyYXkgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tX21pbkZsb2F0QXR0cmlidXRlQnVmZmVyLCBhICogbG9jYWwuTzNER0NfU0MzRE1DX01BWF9ESU1fQVRUUklCVVRFUyAqIDQsIHRoaXMuR2V0RmxvYXRBdHRyaWJ1dGVEaW0oYSkpKTtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0RmxvYXRBdHRyaWJ1dGVNYXhBcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiAobmV3IEZsb2F0MzJBcnJheSh0aGlzLm1fbWF4RmxvYXRBdHRyaWJ1dGVCdWZmZXIsIGEgKiBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX0RJTV9BVFRSSUJVVEVTICogNCwgdGhpcy5HZXRGbG9hdEF0dHJpYnV0ZURpbShhKSkpO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXRGbG9hdEF0dHJpYnV0ZURpbSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZGltRmxvYXRBdHRyaWJ1dGVbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldEludEF0dHJpYnV0ZURpbSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZGltSW50QXR0cmlidXRlW2FdO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXRGbG9hdEF0dHJpYnV0ZVR5cGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3R5cGVGbG9hdEF0dHJpYnV0ZVthXTtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0SW50QXR0cmlidXRlVHlwZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fdHlwZUludEF0dHJpYnV0ZVthXTtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0RmxvYXRBdHRyaWJ1dGVNYXggPSBmdW5jdGlvbiAoYSwgZGltKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbWF4RmxvYXRBdHRyaWJ1dGVbYSAqIGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfRElNX0FUVFJJQlVURVMgKyBkaW1dO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXRDcmVhc2VBbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jcmVhc2VBbmdsZTtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0Q3JlYXNlQW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fY3JlYXNlQW5nbGU7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldENDVyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jY3c7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldFNvbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3NvbGlkO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXRDb252ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fY29udmV4O1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXRJc1RyaWFuZ3VsYXJNZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2lzVHJpYW5ndWxhck1lc2g7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLkdldENvb3JkSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fY29vcmRJbmRleDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0Q29vcmRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jb29yZEluZGV4O1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXRDb29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jb29yZDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0Tm9ybWFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX25vcm1hbDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuR2V0RmxvYXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2Zsb2F0QXR0cmlidXRlW2FdO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5HZXRJbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2ludEF0dHJpYnV0ZVthXTtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0TkNvb3JkSW5kZXggPSBmdW5jdGlvbiAobkNvb3JkSW5kZXgpIHtcbiAgICAgICAgdGhpcy5tX25Db29yZEluZGV4ID0gbkNvb3JkSW5kZXg7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLlNldE5Ob3JtYWxJbmRleCA9IGZ1bmN0aW9uIChuTm9ybWFsSW5kZXgpIHtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0Tm9ybWFsUGVyVmVydGV4ID0gZnVuY3Rpb24gKHBlclZlcnRleCkge1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRORmxvYXRBdHRyaWJ1dGVJbmRleCA9IGZ1bmN0aW9uIChuRmxvYXRBdHRyaWJ1dGVJbmRleCkge1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXROSW50QXR0cmlidXRlSW5kZXggPSBmdW5jdGlvbiAobkludEF0dHJpYnV0ZUluZGV4KSB7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLlNldEZsb2F0QXR0cmlidXRlUGVyVmVydGV4ID0gZnVuY3Rpb24gKHBlclZlcnRleCkge1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRJbnRBdHRyaWJ1dGVQZXJWZXJ0ZXggPSBmdW5jdGlvbiAocGVyVmVydGV4KSB7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLlNldE5Db29yZCA9IGZ1bmN0aW9uIChuQ29vcmQpIHtcbiAgICAgICAgdGhpcy5tX25Db29yZCA9IG5Db29yZDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0Tk5vcm1hbCA9IGZ1bmN0aW9uIChuTm9ybWFsKSB7XG4gICAgICAgIHRoaXMubV9uTm9ybWFsID0gbk5vcm1hbDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0TnVtRmxvYXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG51bUZsb2F0QXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLm1fbnVtRmxvYXRBdHRyaWJ1dGVzID0gbnVtRmxvYXRBdHRyaWJ1dGVzO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXROdW1JbnRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG51bUludEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5tX251bUludEF0dHJpYnV0ZXMgPSBudW1JbnRBdHRyaWJ1dGVzO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRDcmVhc2VBbmdsZSA9IGZ1bmN0aW9uIChjcmVhc2VBbmdsZSkge1xuICAgICAgICB0aGlzLm1fY3JlYXNlQW5nbGUgPSBjcmVhc2VBbmdsZTtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0Q0NXID0gZnVuY3Rpb24gKGNjdykge1xuICAgICAgICB0aGlzLm1fY2N3ID0gY2N3O1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRTb2xpZCA9IGZ1bmN0aW9uIChzb2xpZCkge1xuICAgICAgICB0aGlzLm1fc29saWQgPSBzb2xpZDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0Q29udmV4ID0gZnVuY3Rpb24gKGNvbnZleCkge1xuICAgICAgICB0aGlzLm1fY29udmV4ID0gY29udmV4O1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRJc1RyaWFuZ3VsYXJNZXNoID0gZnVuY3Rpb24gKGlzVHJpYW5ndWxhck1lc2gpIHtcbiAgICAgICAgdGhpcy5tX2lzVHJpYW5ndWxhck1lc2ggPSBpc1RyaWFuZ3VsYXJNZXNoO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRDb29yZE1pbiA9IGZ1bmN0aW9uIChqLCBtaW4pIHtcbiAgICAgICAgdGhpcy5tX2Nvb3JkTWluW2pdID0gbWluO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRDb29yZE1heCA9IGZ1bmN0aW9uIChqLCBtYXgpIHtcbiAgICAgICAgdGhpcy5tX2Nvb3JkTWF4W2pdID0gbWF4O1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXROb3JtYWxNaW4gPSBmdW5jdGlvbiAoaiwgbWluKSB7XG4gICAgICAgIHRoaXMubV9ub3JtYWxNaW5bal0gPSBtaW47XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLlNldE5vcm1hbE1heCA9IGZ1bmN0aW9uIChqLCBtYXgpIHtcbiAgICAgICAgdGhpcy5tX25vcm1hbE1heFtqXSA9IG1heDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0TkZsb2F0QXR0cmlidXRlID0gZnVuY3Rpb24gKGEsIG5GbG9hdEF0dHJpYnV0ZSkge1xuICAgICAgICB0aGlzLm1fbkZsb2F0QXR0cmlidXRlW2FdID0gbkZsb2F0QXR0cmlidXRlO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXROSW50QXR0cmlidXRlID0gZnVuY3Rpb24gKGEsIG5JbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy5tX25JbnRBdHRyaWJ1dGVbYV0gPSBuSW50QXR0cmlidXRlO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRGbG9hdEF0dHJpYnV0ZURpbSA9IGZ1bmN0aW9uIChhLCBkKSB7XG4gICAgICAgIHRoaXMubV9kaW1GbG9hdEF0dHJpYnV0ZVthXSA9IGQ7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLlNldEludEF0dHJpYnV0ZURpbSA9IGZ1bmN0aW9uIChhLCBkKSB7XG4gICAgICAgIHRoaXMubV9kaW1JbnRBdHRyaWJ1dGVbYV0gPSBkO1xuICAgIH07XG4gICAgbW9kdWxlLkluZGV4ZWRGYWNlU2V0LnByb3RvdHlwZS5TZXRGbG9hdEF0dHJpYnV0ZVR5cGUgPSBmdW5jdGlvbiAoYSwgZCkge1xuICAgICAgICB0aGlzLm1fdHlwZUZsb2F0QXR0cmlidXRlW2FdID0gZDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0SW50QXR0cmlidXRlVHlwZSA9IGZ1bmN0aW9uIChhLCBkKSB7XG4gICAgICAgIHRoaXMubV90eXBlSW50QXR0cmlidXRlW2FdID0gZDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0RmxvYXRBdHRyaWJ1dGVNaW4gPSBmdW5jdGlvbiAoYSwgZGltLCBtaW4pIHtcbiAgICAgICAgdGhpcy5tX21pbkZsb2F0QXR0cmlidXRlW2EgKiBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX0RJTV9BVFRSSUJVVEVTICsgZGltXSA9IG1pbjtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0RmxvYXRBdHRyaWJ1dGVNYXggPSBmdW5jdGlvbiAoYSwgZGltLCBtYXgpIHtcbiAgICAgICAgdGhpcy5tX21heEZsb2F0QXR0cmlidXRlW2EgKiBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX0RJTV9BVFRSSUJVVEVTICsgZGltXSA9IG1heDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0Q29vcmRJbmRleCA9IGZ1bmN0aW9uIChjb29yZEluZGV4KSB7XG4gICAgICAgIHRoaXMubV9jb29yZEluZGV4ID0gY29vcmRJbmRleDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0Q29vcmQgPSBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgdGhpcy5tX2Nvb3JkID0gY29vcmQ7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLlNldE5vcm1hbCA9IGZ1bmN0aW9uIChub3JtYWwpIHtcbiAgICAgICAgdGhpcy5tX25vcm1hbCA9IG5vcm1hbDtcbiAgICB9O1xuICAgIG1vZHVsZS5JbmRleGVkRmFjZVNldC5wcm90b3R5cGUuU2V0RmxvYXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYSwgZmxvYXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy5tX2Zsb2F0QXR0cmlidXRlW2FdID0gZmxvYXRBdHRyaWJ1dGU7XG4gICAgfTtcbiAgICBtb2R1bGUuSW5kZXhlZEZhY2VTZXQucHJvdG90eXBlLlNldEludEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhLCBpbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy5tX2ludEF0dHJpYnV0ZVthXSA9IGludEF0dHJpYnV0ZTtcbiAgICB9O1xuXG4gICAgLy8gU0MzRE1DRW5jb2RlUGFyYW1zIGNsYXNzXG4gICAgbW9kdWxlLlNDM0RNQ0VuY29kZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIHRoaXMubV9udW1GbG9hdEF0dHJpYnV0ZXMgPSAwO1xuICAgICAgICB0aGlzLm1fbnVtSW50QXR0cmlidXRlcyA9IDA7XG4gICAgICAgIHRoaXMubV9mbG9hdEF0dHJpYnV0ZVF1YW50Qml0cyA9IG5ldyBVaW50MzJBcnJheShsb2NhbC5PM0RHQ19TQzNETUNfTUFYX05VTV9GTE9BVF9BVFRSSUJVVEVTKTtcbiAgICAgICAgdGhpcy5tX2Zsb2F0QXR0cmlidXRlUHJlZE1vZGUgPSBuZXcgVWludDMyQXJyYXkobG9jYWwuTzNER0NfU0MzRE1DX01BWF9OVU1fRkxPQVRfQVRUUklCVVRFUyk7XG4gICAgICAgIHRoaXMubV9pbnRBdHRyaWJ1dGVQcmVkTW9kZSA9IG5ldyBVaW50MzJBcnJheShsb2NhbC5PM0RHQ19TQzNETUNfTUFYX05VTV9JTlRfQVRUUklCVVRFUyk7XG4gICAgICAgIHRoaXMubV9lbmNvZGVNb2RlID0gbG9jYWwuTzNER0NfU0MzRE1DX0VOQ09ERV9NT0RFX1RGQU47XG4gICAgICAgIHRoaXMubV9zdHJlYW1UeXBlTW9kZSA9IGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0FTQ0lJO1xuICAgICAgICB0aGlzLm1fY29vcmRRdWFudEJpdHMgPSAxNDtcbiAgICAgICAgdGhpcy5tX25vcm1hbFF1YW50Qml0cyA9IDg7XG4gICAgICAgIHRoaXMubV9jb29yZFByZWRNb2RlID0gbG9jYWwuTzNER0NfU0MzRE1DX1BBUkFMTEVMT0dSQU1fUFJFRElDVElPTjtcbiAgICAgICAgdGhpcy5tX25vcm1hbFByZWRNb2RlID0gbG9jYWwuTzNER0NfU0MzRE1DX1NVUkZfTk9STUFMU19QUkVESUNUSU9OO1xuICAgICAgICBmb3IgKGEgPSAwOyBhIDwgbG9jYWwuTzNER0NfU0MzRE1DX01BWF9OVU1fRkxPQVRfQVRUUklCVVRFUzsgKythKSB7XG4gICAgICAgICAgICB0aGlzLm1fZmxvYXRBdHRyaWJ1dGVQcmVkTW9kZVthXSA9IGxvY2FsLk8zREdDX1NDM0RNQ19QQVJBTExFTE9HUkFNX1BSRURJQ1RJT047XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChhID0gMDsgYSA8IGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfTlVNX0lOVF9BVFRSSUJVVEVTOyArK2EpIHtcbiAgICAgICAgICAgIHRoaXMubV9pbnRBdHRyaWJ1dGVQcmVkTW9kZVthXSA9IGxvY2FsLk8zREdDX1NDM0RNQ19ESUZGRVJFTlRJQUxfUFJFRElDVElPTjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbW9kdWxlLlNDM0RNQ0VuY29kZVBhcmFtcy5wcm90b3R5cGUuR2V0U3RyZWFtVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9zdHJlYW1UeXBlTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLkdldEVuY29kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZW5jb2RlTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLkdldE51bUZsb2F0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9udW1GbG9hdEF0dHJpYnV0ZXM7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXROdW1JbnRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX251bUludEF0dHJpYnV0ZXM7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXRDb29yZFF1YW50Qml0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jb29yZFF1YW50Qml0cztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLkdldE5vcm1hbFF1YW50Qml0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9ub3JtYWxRdWFudEJpdHM7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXRGbG9hdEF0dHJpYnV0ZVF1YW50Qml0cyA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZmxvYXRBdHRyaWJ1dGVRdWFudEJpdHNbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXRDb29yZFByZWRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2Nvb3JkUHJlZE1vZGU7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXROb3JtYWxQcmVkTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9ub3JtYWxQcmVkTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLkdldEZsb2F0QXR0cmlidXRlUHJlZE1vZGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2Zsb2F0QXR0cmlidXRlUHJlZE1vZGVbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXRJbnRBdHRyaWJ1dGVQcmVkTW9kZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1faW50QXR0cmlidXRlUHJlZE1vZGVbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXRDb29yZFByZWRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2Nvb3JkUHJlZE1vZGU7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXROb3JtYWxQcmVkTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9ub3JtYWxQcmVkTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLkdldEZsb2F0QXR0cmlidXRlUHJlZE1vZGUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX2Zsb2F0QXR0cmlidXRlUHJlZE1vZGVbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5HZXRJbnRBdHRyaWJ1dGVQcmVkTW9kZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1faW50QXR0cmlidXRlUHJlZE1vZGVbYV07XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5TZXRTdHJlYW1UeXBlID0gZnVuY3Rpb24gKHN0cmVhbVR5cGVNb2RlKSB7XG4gICAgICAgIHRoaXMubV9zdHJlYW1UeXBlTW9kZSA9IHN0cmVhbVR5cGVNb2RlO1xuICAgIH07XG4gICAgbW9kdWxlLlNDM0RNQ0VuY29kZVBhcmFtcy5wcm90b3R5cGUuU2V0RW5jb2RlTW9kZSA9IGZ1bmN0aW9uIChlbmNvZGVNb2RlKSB7XG4gICAgICAgIHRoaXMubV9lbmNvZGVNb2RlID0gZW5jb2RlTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLlNldE51bUZsb2F0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIChudW1GbG9hdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5tX251bUZsb2F0QXR0cmlidXRlcyA9IG51bUZsb2F0QXR0cmlidXRlcztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLlNldE51bUludEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobnVtSW50QXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLm1fbnVtSW50QXR0cmlidXRlcyA9IG51bUludEF0dHJpYnV0ZXM7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5TZXRDb29yZFF1YW50Qml0cyA9IGZ1bmN0aW9uIChjb29yZFF1YW50Qml0cykge1xuICAgICAgICB0aGlzLm1fY29vcmRRdWFudEJpdHMgPSBjb29yZFF1YW50Qml0cztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLlNldE5vcm1hbFF1YW50Qml0cyA9IGZ1bmN0aW9uIChub3JtYWxRdWFudEJpdHMpIHtcbiAgICAgICAgdGhpcy5tX25vcm1hbFF1YW50Qml0cyA9IG5vcm1hbFF1YW50Qml0cztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLlNldEZsb2F0QXR0cmlidXRlUXVhbnRCaXRzID0gZnVuY3Rpb24gKGEsIHEpIHtcbiAgICAgICAgdGhpcy5tX2Zsb2F0QXR0cmlidXRlUXVhbnRCaXRzW2FdID0gcTtcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLlNldENvb3JkUHJlZE1vZGUgPSBmdW5jdGlvbiAoY29vcmRQcmVkTW9kZSkge1xuICAgICAgICB0aGlzLm1fY29vcmRQcmVkTW9kZSA9IGNvb3JkUHJlZE1vZGU7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5TZXROb3JtYWxQcmVkTW9kZSA9IGZ1bmN0aW9uIChub3JtYWxQcmVkTW9kZSkge1xuICAgICAgICB0aGlzLm1fbm9ybWFsUHJlZE1vZGUgPSBub3JtYWxQcmVkTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNFbmNvZGVQYXJhbXMucHJvdG90eXBlLlNldEZsb2F0QXR0cmlidXRlUHJlZE1vZGUgPSBmdW5jdGlvbiAoYSwgcCkge1xuICAgICAgICB0aGlzLm1fZmxvYXRBdHRyaWJ1dGVQcmVkTW9kZVthXSA9IHA7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRW5jb2RlUGFyYW1zLnByb3RvdHlwZS5TZXRJbnRBdHRyaWJ1dGVQcmVkTW9kZSA9IGZ1bmN0aW9uIChhLCBwKSB7XG4gICAgICAgIHRoaXMubV9pbnRBdHRyaWJ1dGVQcmVkTW9kZVthXSA9IHA7XG4gICAgfTtcbiAgICAvLyBBZGphY2VuY3lJbmZvIGNsYXNzXG4gICAgbW9kdWxlLkFkamFjZW5jeUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9uZWlnaGJvcnNTaXplID0gMDsgICAgLy8gYWN0dWFsIGFsbG9jYXRlZCBzaXplIGZvciBtX25laWdoYm9yc1xuICAgICAgICB0aGlzLm1fbnVtTmVpZ2hib3JzU2l6ZSA9IDA7IC8vIGFjdHVhbCBhbGxvY2F0ZWQgc2l6ZSBmb3IgbV9udW1OZWlnaGJvcnNcbiAgICAgICAgdGhpcy5tX251bUVsZW1lbnRzID0gMDsgICAgICAvLyBudW1iZXIgb2YgZWxlbWVudHMgXG4gICAgICAgIHRoaXMubV9uZWlnaGJvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5tX251bU5laWdoYm9ycyA9IHt9O1xuICAgIH07XG4gICAgbW9kdWxlLkFkamFjZW5jeUluZm8ucHJvdG90eXBlLkFsbG9jYXRlID0gZnVuY3Rpb24gKG51bU5laWdoYm9yc1NpemUsIG5laWdoYm9yc1NpemUpIHtcbiAgICAgICAgdGhpcy5tX251bUVsZW1lbnRzID0gbnVtTmVpZ2hib3JzU2l6ZTtcbiAgICAgICAgaWYgKG5laWdoYm9yc1NpemUgPiB0aGlzLm1fbmVpZ2hib3JzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tX25laWdoYm9yc1NpemUgPSBuZWlnaGJvcnNTaXplO1xuICAgICAgICAgICAgdGhpcy5tX25laWdoYm9ycyA9IG5ldyBJbnQzMkFycmF5KHRoaXMubV9uZWlnaGJvcnNTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtTmVpZ2hib3JzU2l6ZSA+IHRoaXMubV9udW1OZWlnaGJvcnNTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm1fbnVtTmVpZ2hib3JzU2l6ZSA9IG51bU5laWdoYm9yc1NpemU7XG4gICAgICAgICAgICB0aGlzLm1fbnVtTmVpZ2hib3JzID0gbmV3IEludDMyQXJyYXkodGhpcy5tX251bU5laWdoYm9yc1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRqYWNlbmN5SW5mby5wcm90b3R5cGUuQWxsb2NhdGVOdW1OZWlnaGJvcnNBcnJheSA9IGZ1bmN0aW9uIChudW1FbGVtZW50cykge1xuICAgICAgICBpZiAobnVtRWxlbWVudHMgPiB0aGlzLm1fbnVtTmVpZ2hib3JzU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tX251bU5laWdoYm9yc1NpemUgPSBudW1FbGVtZW50cztcbiAgICAgICAgICAgIHRoaXMubV9udW1OZWlnaGJvcnMgPSBuZXcgSW50MzJBcnJheSh0aGlzLm1fbnVtTmVpZ2hib3JzU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX251bUVsZW1lbnRzID0gbnVtRWxlbWVudHM7XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRqYWNlbmN5SW5mby5wcm90b3R5cGUuQWxsb2NhdGVOZWlnaGJvcnNBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCB0aGlzLm1fbnVtRWxlbWVudHM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5tX251bU5laWdoYm9yc1tpXSArPSB0aGlzLm1fbnVtTmVpZ2hib3JzW2kgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tX251bU5laWdoYm9yc1t0aGlzLm1fbnVtRWxlbWVudHMgLSAxXSA+IHRoaXMubV9uZWlnaGJvcnNTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm1fbmVpZ2hib3JzU2l6ZSA9IHRoaXMubV9udW1OZWlnaGJvcnNbdGhpcy5tX251bUVsZW1lbnRzIC0gMV07XG4gICAgICAgICAgICB0aGlzLm1fbmVpZ2hib3JzID0gbmV3IEludDMyQXJyYXkodGhpcy5tX25laWdoYm9yc1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRqYWNlbmN5SW5mby5wcm90b3R5cGUuQ2xlYXJOdW1OZWlnaGJvcnNBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm1fbnVtRWxlbWVudHM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5tX251bU5laWdoYm9yc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5BZGphY2VuY3lJbmZvLnByb3RvdHlwZS5DbGVhck5laWdoYm9yc0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubV9uZWlnaGJvcnNTaXplOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubV9uZWlnaGJvcnNbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLkFkamFjZW5jeUluZm8ucHJvdG90eXBlLkJlZ2luID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIChlbGVtZW50ID4gMCkgPyB0aGlzLm1fbnVtTmVpZ2hib3JzW2VsZW1lbnQgLSAxXSA6IDA7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRqYWNlbmN5SW5mby5wcm90b3R5cGUuRW5kID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9udW1OZWlnaGJvcnNbZWxlbWVudF07XG4gICAgfTtcbiAgICBtb2R1bGUuQWRqYWNlbmN5SW5mby5wcm90b3R5cGUuQWRkTmVpZ2hib3IgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmVpZ2hib3IpIHtcbiAgICAgICAgdmFyIHAsIHAwLCBwMTtcbiAgICAgICAgcDAgPSB0aGlzLkJlZ2luKGVsZW1lbnQpO1xuICAgICAgICBwMSA9IHRoaXMuRW5kKGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHAgPSBwMDsgcCA8IHAxOyArK3ApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1fbmVpZ2hib3JzW3BdID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubV9uZWlnaGJvcnNbcF0gPSBuZWlnaGJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfRVJST1JfQlVGRkVSX0ZVTEw7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRqYWNlbmN5SW5mby5wcm90b3R5cGUuR2V0TmVpZ2hib3IgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX25laWdoYm9yc1tlbGVtZW50XTtcbiAgICB9O1xuICAgIG1vZHVsZS5BZGphY2VuY3lJbmZvLnByb3RvdHlwZS5HZXROdW1OZWlnaGJvcnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FbmQoZWxlbWVudCkgLSB0aGlzLkJlZ2luKGVsZW1lbnQpO1xuICAgIH07XG4gICAgbW9kdWxlLkFkamFjZW5jeUluZm8ucHJvdG90eXBlLkdldE51bU5laWdoYm9yc0J1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9udW1OZWlnaGJvcnM7XG4gICAgfTtcbiAgICBtb2R1bGUuQWRqYWNlbmN5SW5mby5wcm90b3R5cGUuR2V0TmVpZ2hib3JzQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX25laWdoYm9ycztcbiAgICB9O1xuICAgIC8vIFZlY3RvciBjbGFzc1xuICAgIG1vZHVsZS5WZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9kYXRhID0ge307XG4gICAgICAgIHRoaXMubV9hbGxvY2F0ZWQgPSAwO1xuICAgICAgICB0aGlzLm1fc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjdG9yLnByb3RvdHlwZS5DbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tX3NpemUgPSAwO1xuICAgIH07XG4gICAgbW9kdWxlLlZlY3Rvci5wcm90b3R5cGUuR2V0ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9kYXRhW2ldO1xuICAgIH07XG4gICAgbW9kdWxlLlZlY3Rvci5wcm90b3R5cGUuR2V0QWxsb2NhdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9hbGxvY2F0ZWQ7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjdG9yLnByb3RvdHlwZS5HZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3NpemU7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjdG9yLnByb3RvdHlwZS5HZXRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZGF0YTtcbiAgICB9O1xuICAgIG1vZHVsZS5WZWN0b3IucHJvdG90eXBlLlNldFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB0aGlzLm1fc2l6ZSA9IHNpemU7XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjdG9yLnByb3RvdHlwZS5BbGxvY2F0ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHZhciBpLCB0bXBfZGF0YTtcbiAgICAgICAgaWYgKHNpemUgPiB0aGlzLm1fYWxsb2NhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1fYWxsb2NhdGVkID0gc2l6ZTtcbiAgICAgICAgICAgIHRtcF9kYXRhID0gbmV3IEludDMyQXJyYXkodGhpcy5tX2FsbG9jYXRlZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tX3NpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubV9zaXplOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wX2RhdGFbaV0gPSB0aGlzLm1fZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fZGF0YSA9IHRtcF9kYXRhO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBtb2R1bGUuVmVjdG9yLnByb3RvdHlwZS5QdXNoQmFjayA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSwgdG1wX2RhdGE7XG4gICAgICAgIGlmICh0aGlzLm1fc2l6ZSA9PT0gdGhpcy5tX2FsbG9jYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5tX2FsbG9jYXRlZCAqPSAyO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9hbGxvY2F0ZWQgPCBsb2NhbC5PM0RHQ19ERUZBVUxUX1ZFQ1RPUl9TSVpFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX2FsbG9jYXRlZCA9IGxvY2FsLk8zREdDX0RFRkFVTFRfVkVDVE9SX1NJWkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0bXBfZGF0YSA9IG5ldyBJbnQzMkFycmF5KHRoaXMubV9hbGxvY2F0ZWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMubV9zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm1fc2l6ZTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcF9kYXRhW2ldID0gdGhpcy5tX2RhdGFbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tX2RhdGEgPSB0bXBfZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1fZGF0YVt0aGlzLm1fc2l6ZSsrXSA9IHZhbHVlO1xuICAgIH07XG4gICAgLy8gQ29tcHJlc3NlZFRyaWFuZ2xlRmFucyBjbGFzc1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fbnVtVEZBTnMgPSBuZXcgbW9kdWxlLlZlY3RvcigpO1xuICAgICAgICB0aGlzLm1fZGVncmVlcyA9IG5ldyBtb2R1bGUuVmVjdG9yKCk7XG4gICAgICAgIHRoaXMubV9jb25maWdzID0gbmV3IG1vZHVsZS5WZWN0b3IoKTtcbiAgICAgICAgdGhpcy5tX29wZXJhdGlvbnMgPSBuZXcgbW9kdWxlLlZlY3RvcigpO1xuICAgICAgICB0aGlzLm1faW5kaWNlcyA9IG5ldyBtb2R1bGUuVmVjdG9yKCk7XG4gICAgICAgIHRoaXMubV90cmlhbmdsZXNPcmRlciA9IG5ldyBtb2R1bGUuVmVjdG9yKCk7XG4gICAgICAgIHRoaXMubV9zdHJlYW1UeXBlID0gbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfVU5LT1dOO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLkdldFN0cmVhbVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fc3RyZWFtVHlwZTtcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5TZXRTdHJlYW1UeXBlID0gZnVuY3Rpb24gKHN0cmVhbVR5cGUpIHtcbiAgICAgICAgdGhpcy5tX3N0cmVhbVR5cGUgPSBzdHJlYW1UeXBlO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLkNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fbnVtVEZBTnMuQ2xlYXIoKTtcbiAgICAgICAgdGhpcy5tX2RlZ3JlZXMuQ2xlYXIoKTtcbiAgICAgICAgdGhpcy5tX2NvbmZpZ3MuQ2xlYXIoKTtcbiAgICAgICAgdGhpcy5tX29wZXJhdGlvbnMuQ2xlYXIoKTtcbiAgICAgICAgdGhpcy5tX2luZGljZXMuQ2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5BbGxvY2F0ZSA9IGZ1bmN0aW9uIChudW1WZXJ0aWNlcywgbnVtVHJpYW5nbGVzKSB7XG4gICAgICAgIHRoaXMubV9udW1URkFOcy5BbGxvY2F0ZShudW1WZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMubV9kZWdyZWVzLkFsbG9jYXRlKDIgKiBudW1WZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMubV9jb25maWdzLkFsbG9jYXRlKDIgKiBudW1WZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMubV9vcGVyYXRpb25zLkFsbG9jYXRlKDIgKiBudW1WZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMubV9pbmRpY2VzLkFsbG9jYXRlKDIgKiBudW1WZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMubV90cmlhbmdsZXNPcmRlci5BbGxvY2F0ZShudW1UcmlhbmdsZXMpO1xuICAgICAgICB0aGlzLkNsZWFyKCk7XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuQ29tcHJlc3NlZFRyaWFuZ2xlRmFucy5wcm90b3R5cGUuUHVzaE51bVRGYW5zID0gZnVuY3Rpb24gKG51bVRGYW5zKSB7XG4gICAgICAgIHRoaXMubV9udW1URkFOcy5QdXNoQmFjayhudW1URmFucyk7XG4gICAgfTtcbiAgICBtb2R1bGUuQ29tcHJlc3NlZFRyaWFuZ2xlRmFucy5wcm90b3R5cGUuUmVhZE51bVRGYW5zID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbnVtVEZBTnMuR2V0KGl0Lm1fY291bnQrKyk7XG4gICAgfTtcbiAgICBtb2R1bGUuQ29tcHJlc3NlZFRyaWFuZ2xlRmFucy5wcm90b3R5cGUuUHVzaERlZ3JlZSA9IGZ1bmN0aW9uIChkZWdyZWUpIHtcbiAgICAgICAgdGhpcy5tX2RlZ3JlZXMuUHVzaEJhY2soZGVncmVlKTtcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5SZWFkRGVncmVlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZGVncmVlcy5HZXQoaXQubV9jb3VudCsrKTtcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5QdXNoQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICB0aGlzLm1fY29uZmlncy5QdXNoQmFjayhjb25maWcpO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLlJlYWRDb25maWcgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9jb25maWdzLkdldChpdC5tX2NvdW50KyspO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLlB1c2hPcGVyYXRpb24gPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgdGhpcy5tX29wZXJhdGlvbnMuUHVzaEJhY2sob3ApO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLlJlYWRPcGVyYXRpb24gPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9vcGVyYXRpb25zLkdldChpdC5tX2NvdW50KyspO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLlB1c2hJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLm1faW5kaWNlcy5QdXNoQmFjayhpbmRleCk7XG4gICAgfTtcbiAgICBtb2R1bGUuQ29tcHJlc3NlZFRyaWFuZ2xlRmFucy5wcm90b3R5cGUuUmVhZEluZGV4ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1faW5kaWNlcy5HZXQoaXQubV9jb3VudCsrKTtcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5QdXNoVHJpYW5nbGVJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVzT3JkZXIuUHVzaEJhY2soSW50VG9VSW50KGluZGV4KSk7XG4gICAgfTtcbiAgICBtb2R1bGUuQ29tcHJlc3NlZFRyaWFuZ2xlRmFucy5wcm90b3R5cGUuUmVhZFRyaWFuZ2xlSW5kZXggPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgICAgcmV0dXJuIFVJbnRUb0ludCh0aGlzLm1fdHJpYW5nbGVzT3JkZXIuR2V0KGl0Lm1fY291bnQrKykpO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLkxvYWRVSW50RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBic3RyZWFtLCBpdCkge1xuICAgICAgICB2YXIgc2l6ZSwgaTtcbiAgICAgICAgYnN0cmVhbS5SZWFkVUludDMyQVNDSUkoaXQpO1xuICAgICAgICBzaXplID0gYnN0cmVhbS5SZWFkVUludDMyQVNDSUkoaXQpO1xuICAgICAgICBkYXRhLkFsbG9jYXRlKHNpemUpO1xuICAgICAgICBkYXRhLkNsZWFyKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgICAgIGRhdGEuUHVzaEJhY2soYnN0cmVhbS5SZWFkVUludEFTQ0lJKGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5Mb2FkSW50RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCBic3RyZWFtLCBpdCkge1xuICAgICAgICB2YXIgc2l6ZSwgaTtcbiAgICAgICAgYnN0cmVhbS5SZWFkVUludDMyQVNDSUkoaXQpO1xuICAgICAgICBzaXplID0gYnN0cmVhbS5SZWFkVUludDMyQVNDSUkoaXQpO1xuICAgICAgICBkYXRhLkFsbG9jYXRlKHNpemUpO1xuICAgICAgICBkYXRhLkNsZWFyKCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgICAgIGRhdGEuUHVzaEJhY2soYnN0cmVhbS5SZWFkSW50QVNDSUkoaXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLkxvYWRCaW5EYXRhID0gZnVuY3Rpb24gKGRhdGEsIGJzdHJlYW0sIGl0KSB7XG4gICAgICAgIHZhciBzaXplLCBzeW1ib2wsIGksIGg7XG4gICAgICAgIGJzdHJlYW0uUmVhZFVJbnQzMkFTQ0lJKGl0KTtcbiAgICAgICAgc2l6ZSA9IGJzdHJlYW0uUmVhZFVJbnQzMkFTQ0lJKGl0KTtcbiAgICAgICAgZGF0YS5BbGxvY2F0ZShzaXplICogbG9jYWwuTzNER0NfQklOQVJZX1NUUkVBTV9CSVRTX1BFUl9TWU1CT0wwKTtcbiAgICAgICAgZGF0YS5DbGVhcigpO1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzaXplKSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBic3RyZWFtLlJlYWRVQ2hhckFTQ0lJKGl0KTtcbiAgICAgICAgICAgIGZvciAoaCA9IDA7IGggPCBsb2NhbC5PM0RHQ19CSU5BUllfU1RSRUFNX0JJVFNfUEVSX1NZTUJPTDA7ICsraCkge1xuICAgICAgICAgICAgICAgIGRhdGEuUHVzaEJhY2soc3ltYm9sICYgMSk7XG4gICAgICAgICAgICAgICAgc3ltYm9sID4+Pj0gMTtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5Mb2FkVUludEFDID0gZnVuY3Rpb24gKGRhdGEsIE0sIGJzdHJlYW0sIGl0KSB7XG5cbiAgICAgICAgdmFyIHNpemVTaXplLCBzaXplLCBtaW5WYWx1ZSwgYnVmZmVyLCBhY2QsIG1Nb2RlbFZhbHVlcywgaTtcbiAgICAgICAgc2l6ZVNpemUgPSBic3RyZWFtLlJlYWRVSW50MzJCaW4oaXQpIC0gMTI7XG4gICAgICAgIHNpemUgPSBic3RyZWFtLlJlYWRVSW50MzJCaW4oaXQpO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICAgICAgfVxuICAgICAgICBtaW5WYWx1ZSA9IGJzdHJlYW0uUmVhZFVJbnQzMkJpbihpdCk7XG4gICAgICAgIGJ1ZmZlciA9IGJzdHJlYW0uR2V0QnVmZmVyKGl0LCBzaXplU2l6ZSk7XG4gICAgICAgIGl0Lm1fY291bnQgKz0gc2l6ZVNpemU7XG4gICAgICAgIGRhdGEuQWxsb2NhdGUoc2l6ZSk7XG4gICAgICAgIGFjZCA9IG5ldyBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIoKTtcbiAgICAgICAgYWNkLlNldEJ1ZmZlcihzaXplU2l6ZSwgYnVmZmVyKTtcbiAgICAgICAgYWNkLlN0YXJ0RGVjb2RlcigpO1xuICAgICAgICBtTW9kZWxWYWx1ZXMgPSBuZXcgbW9kdWxlLkFkYXB0aXZlRGF0YU1vZGVsKCk7XG4gICAgICAgIG1Nb2RlbFZhbHVlcy5TZXRBbHBoYWJldChNICsgMSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgICAgIGRhdGEuUHVzaEJhY2soYWNkLkRlY29kZUFkYXB0aXZlRGF0YU1vZGVsKG1Nb2RlbFZhbHVlcykgKyBtaW5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5Db21wcmVzc2VkVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5Mb2FkSW50QUNFR0MgPSBmdW5jdGlvbiAoZGF0YSwgTSwgYnN0cmVhbSwgaXQpIHtcbiAgICAgICAgdmFyIHNpemVTaXplLCBzaXplLCBtaW5WYWx1ZSwgYnVmZmVyLCBhY2QsIG1Nb2RlbFZhbHVlcywgYk1vZGVsMCwgYk1vZGVsMSwgdmFsdWUsIGk7XG4gICAgICAgIHNpemVTaXplID0gYnN0cmVhbS5SZWFkVUludDMyQmluKGl0KSAtIDEyO1xuICAgICAgICBzaXplID0gYnN0cmVhbS5SZWFkVUludDMyQmluKGl0KTtcbiAgICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgICAgIH1cbiAgICAgICAgbWluVmFsdWUgPSBic3RyZWFtLlJlYWRVSW50MzJCaW4oaXQpIC0gbG9jYWwuTzNER0NfTUFYX0xPTkc7XG4gICAgICAgIGJ1ZmZlciA9IGJzdHJlYW0uR2V0QnVmZmVyKGl0LCBzaXplU2l6ZSk7XG4gICAgICAgIGl0Lm1fY291bnQgKz0gc2l6ZVNpemU7XG4gICAgICAgIGRhdGEuQWxsb2NhdGUoc2l6ZSk7XG4gICAgICAgIGFjZCA9IG5ldyBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIoKTtcbiAgICAgICAgYWNkLlNldEJ1ZmZlcihzaXplU2l6ZSwgYnVmZmVyKTtcbiAgICAgICAgYWNkLlN0YXJ0RGVjb2RlcigpO1xuICAgICAgICBtTW9kZWxWYWx1ZXMgPSBuZXcgbW9kdWxlLkFkYXB0aXZlRGF0YU1vZGVsKCk7XG4gICAgICAgIG1Nb2RlbFZhbHVlcy5TZXRBbHBoYWJldChNICsgMik7XG4gICAgICAgIGJNb2RlbDAgPSBuZXcgbW9kdWxlLlN0YXRpY0JpdE1vZGVsKCk7XG4gICAgICAgIGJNb2RlbDEgPSBuZXcgbW9kdWxlLkFkYXB0aXZlQml0TW9kZWwoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhY2QuRGVjb2RlQWRhcHRpdmVEYXRhTW9kZWwobU1vZGVsVmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gTSkge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGFjZC5FeHBHb2xvbWJEZWNvZGUoMCwgYk1vZGVsMCwgYk1vZGVsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLlB1c2hCYWNrKHZhbHVlICsgbWluVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuQ29tcHJlc3NlZFRyaWFuZ2xlRmFucy5wcm90b3R5cGUuTG9hZEJpbkFDID0gZnVuY3Rpb24gKGRhdGEsIGJzdHJlYW0sIGl0KSB7XG4gICAgICAgIHZhciBzaXplU2l6ZSwgc2l6ZSwgYnVmZmVyLCBhY2QsIGJNb2RlbCwgaTtcbiAgICAgICAgc2l6ZVNpemUgPSBic3RyZWFtLlJlYWRVSW50MzJCaW4oaXQpIC0gODtcbiAgICAgICAgc2l6ZSA9IGJzdHJlYW0uUmVhZFVJbnQzMkJpbihpdCk7XG4gICAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciA9IGJzdHJlYW0uR2V0QnVmZmVyKGl0LCBzaXplU2l6ZSk7XG4gICAgICAgIGl0Lm1fY291bnQgKz0gc2l6ZVNpemU7XG4gICAgICAgIGRhdGEuQWxsb2NhdGUoc2l6ZSk7XG4gICAgICAgIGFjZCA9IG5ldyBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIoKTtcbiAgICAgICAgYWNkLlNldEJ1ZmZlcihzaXplU2l6ZSwgYnVmZmVyKTtcbiAgICAgICAgYWNkLlN0YXJ0RGVjb2RlcigpO1xuICAgICAgICBiTW9kZWwgPSBuZXcgbW9kdWxlLkFkYXB0aXZlQml0TW9kZWwoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICAgICAgZGF0YS5QdXNoQmFjayhhY2QuRGVjb2RlQWRhcHRpdmVCaXRNb2RlbChiTW9kZWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMucHJvdG90eXBlLkxvYWQgPSBmdW5jdGlvbiAoYnN0cmVhbSwgaXRlcmF0b3IsIGRlY29kZVRyaWFuZ2xlc09yZGVyLCBzdHJlYW1UeXBlKSB7XG4gICAgICAgIGlmIChzdHJlYW1UeXBlID09PSBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9BU0NJSSkge1xuICAgICAgICAgICAgdGhpcy5Mb2FkVUludERhdGEodGhpcy5tX251bVRGQU5zLCBic3RyZWFtLCBpdGVyYXRvcik7XG4gICAgICAgICAgICB0aGlzLkxvYWRVSW50RGF0YSh0aGlzLm1fZGVncmVlcywgYnN0cmVhbSwgaXRlcmF0b3IpO1xuICAgICAgICAgICAgdGhpcy5Mb2FkVUludERhdGEodGhpcy5tX2NvbmZpZ3MsIGJzdHJlYW0sIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuTG9hZEJpbkRhdGEodGhpcy5tX29wZXJhdGlvbnMsIGJzdHJlYW0sIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuTG9hZEludERhdGEodGhpcy5tX2luZGljZXMsIGJzdHJlYW0sIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVUcmlhbmdsZXNPcmRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuTG9hZFVJbnREYXRhKHRoaXMubV90cmlhbmdsZXNPcmRlciwgYnN0cmVhbSwgaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5Mb2FkSW50QUNFR0ModGhpcy5tX251bVRGQU5zLCA0LCBic3RyZWFtLCBpdGVyYXRvcik7XG4gICAgICAgICAgICB0aGlzLkxvYWRJbnRBQ0VHQyh0aGlzLm1fZGVncmVlcywgMTYsIGJzdHJlYW0sIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuTG9hZFVJbnRBQyh0aGlzLm1fY29uZmlncywgMTAsIGJzdHJlYW0sIGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuTG9hZEJpbkFDKHRoaXMubV9vcGVyYXRpb25zLCBic3RyZWFtLCBpdGVyYXRvcik7XG4gICAgICAgICAgICB0aGlzLkxvYWRJbnRBQ0VHQyh0aGlzLm1faW5kaWNlcywgOCwgYnN0cmVhbSwgaXRlcmF0b3IpO1xuICAgICAgICAgICAgaWYgKGRlY29kZVRyaWFuZ2xlc09yZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Mb2FkSW50QUNFR0ModGhpcy5tX3RyaWFuZ2xlc09yZGVyLCAxNiwgYnN0cmVhbSwgaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICAvLyBUcmlhbmdsZUZhbnMgY2xhc3NcbiAgICBtb2R1bGUuVHJpYW5nbGVGYW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fdmVydGljZXNBbGxvY2F0ZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy5tX3NpemVURkFOQWxsb2NhdGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubV9udW1URkFOcyA9IDA7XG4gICAgICAgIHRoaXMubV9udW1WZXJ0aWNlcyA9IDA7XG4gICAgICAgIHRoaXMubV9zaXplVEZBTiA9IHt9O1xuICAgICAgICB0aGlzLm1fdmVydGljZXMgPSB7fTtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUZhbnMucHJvdG90eXBlLkFsbG9jYXRlID0gZnVuY3Rpb24gKHNpemVURkFOLCB2ZXJ0aWNlc1NpemUpIHtcbiAgICAgICAgdGhpcy5tX251bVRGQU5zID0gMDtcbiAgICAgICAgdGhpcy5tX251bVZlcnRpY2VzID0gMDtcbiAgICAgICAgaWYgKHRoaXMubV92ZXJ0aWNlc0FsbG9jYXRlZFNpemUgPCB2ZXJ0aWNlc1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMubV92ZXJ0aWNlc0FsbG9jYXRlZFNpemUgPSB2ZXJ0aWNlc1NpemU7XG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXMgPSBuZXcgSW50MzJBcnJheSh0aGlzLm1fdmVydGljZXNBbGxvY2F0ZWRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tX3NpemVURkFOQWxsb2NhdGVkU2l6ZSA8IHNpemVURkFOKSB7XG4gICAgICAgICAgICB0aGlzLm1fc2l6ZVRGQU5BbGxvY2F0ZWRTaXplID0gc2l6ZVRGQU47XG4gICAgICAgICAgICB0aGlzLm1fc2l6ZVRGQU4gPSBuZXcgSW50MzJBcnJheSh0aGlzLm1fc2l6ZVRGQU5BbGxvY2F0ZWRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLlRyaWFuZ2xlRmFucy5wcm90b3R5cGUuQ2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9udW1URkFOcyA9IDA7XG4gICAgICAgIHRoaXMubV9udW1WZXJ0aWNlcyA9IDA7XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5BZGRWZXJ0ZXggPSBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICAgIHZhciBpLCB0bXBfdmVydGljZXM7XG4gICAgICAgICsrdGhpcy5tX251bVZlcnRpY2VzO1xuICAgICAgICBpZiAodGhpcy5tX251bVZlcnRpY2VzID4gdGhpcy5tX3ZlcnRpY2VzQWxsb2NhdGVkU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tX3ZlcnRpY2VzQWxsb2NhdGVkU2l6ZSAqPSAyO1xuICAgICAgICAgICAgdG1wX3ZlcnRpY2VzID0gbmV3IEludDMyQXJyYXkodGhpcy5tX3ZlcnRpY2VzQWxsb2NhdGVkU2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5tX251bVZlcnRpY2VzOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0bXBfdmVydGljZXNbaV0gPSB0aGlzLm1fdmVydGljZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fdmVydGljZXMgPSB0bXBfdmVydGljZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX3ZlcnRpY2VzW3RoaXMubV9udW1WZXJ0aWNlcyAtIDFdID0gdmVydGV4O1xuICAgICAgICArK3RoaXMubV9zaXplVEZBTlt0aGlzLm1fbnVtVEZBTnMgLSAxXTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUZhbnMucHJvdG90eXBlLkFkZFRGQU4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpLCB0bXBfc2l6ZVRGQU47XG4gICAgICAgICsrdGhpcy5tX251bVRGQU5zO1xuICAgICAgICBpZiAodGhpcy5tX251bVRGQU5zID4gdGhpcy5tX3NpemVURkFOQWxsb2NhdGVkU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tX3NpemVURkFOQWxsb2NhdGVkU2l6ZSAqPSAyO1xuICAgICAgICAgICAgdG1wX3NpemVURkFOID0gbmV3IEludDMyQXJyYXkodGhpcy5tX3NpemVURkFOQWxsb2NhdGVkU2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5tX251bVRGQU5zOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0bXBfc2l6ZVRGQU5baV0gPSB0aGlzLm1fc2l6ZVRGQU5baV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fc2l6ZVRGQU4gPSB0bXBfc2l6ZVRGQU47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX3NpemVURkFOW3RoaXMubV9udW1URkFOcyAtIDFdID0gKHRoaXMubV9udW1URkFOcyA+IDEpID8gdGhpcy5tX3NpemVURkFOW3RoaXMubV9udW1URkFOcyAtIDJdIDogMDtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUZhbnMucHJvdG90eXBlLkJlZ2luID0gZnVuY3Rpb24gKHRmYW4pIHtcbiAgICAgICAgcmV0dXJuICh0ZmFuID4gMCkgPyB0aGlzLm1fc2l6ZVRGQU5bdGZhbiAtIDFdIDogMDtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUZhbnMucHJvdG90eXBlLkVuZCA9IGZ1bmN0aW9uICh0ZmFuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fc2l6ZVRGQU5bdGZhbl07XG4gICAgfTtcbiAgICBtb2R1bGUuVHJpYW5nbGVGYW5zLnByb3RvdHlwZS5HZXRWZXJ0ZXggPSBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fdmVydGljZXNbdmVydGV4XTtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUZhbnMucHJvdG90eXBlLkdldFRGQU5TaXplID0gZnVuY3Rpb24gKHRmYW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRW5kKHRmYW4pIC0gdGhpcy5CZWdpbih0ZmFuKTtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUZhbnMucHJvdG90eXBlLkdldE51bVRGQU5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX251bVRGQU5zO1xuICAgIH07XG4gICAgbW9kdWxlLlRyaWFuZ2xlRmFucy5wcm90b3R5cGUuR2V0TnVtVmVydGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbnVtVmVydGljZXM7XG4gICAgfTtcbiAgICAvLyBUcmlhbmdsZUxpc3REZWNvZGVyIGNsYXNzXG4gICAgbW9kdWxlLlRyaWFuZ2xlTGlzdERlY29kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubV9pdE51bVRGYW5zID0gbmV3IG1vZHVsZS5JdGVyYXRvcigpO1xuICAgICAgICB0aGlzLm1faXREZWdyZWUgPSBuZXcgbW9kdWxlLkl0ZXJhdG9yKCk7XG4gICAgICAgIHRoaXMubV9pdENvbmZpZyA9IG5ldyBtb2R1bGUuSXRlcmF0b3IoKTtcbiAgICAgICAgdGhpcy5tX2l0T3BlcmF0aW9uID0gbmV3IG1vZHVsZS5JdGVyYXRvcigpO1xuICAgICAgICB0aGlzLm1faXRJbmRleCA9IG5ldyBtb2R1bGUuSXRlcmF0b3IoKTtcbiAgICAgICAgdGhpcy5tX21heE51bVZlcnRpY2VzID0gMDtcbiAgICAgICAgdGhpcy5tX21heE51bVRyaWFuZ2xlcyA9IDA7XG4gICAgICAgIHRoaXMubV9udW1UcmlhbmdsZXMgPSAwO1xuICAgICAgICB0aGlzLm1fbnVtVmVydGljZXMgPSAwO1xuICAgICAgICB0aGlzLm1fdGVtcFRyaWFuZ2xlc1NpemUgPSAwO1xuICAgICAgICB0aGlzLm1fdmVydGV4Q291bnQgPSAwO1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9udW1Db25xdWVyZWRUcmlhbmdsZXMgPSAwO1xuICAgICAgICB0aGlzLm1fbnVtVmlzaXRlZFZlcnRpY2VzID0gMDtcbiAgICAgICAgdGhpcy5tX3RyaWFuZ2xlcyA9IHt9O1xuICAgICAgICB0aGlzLm1fdGVtcFRyaWFuZ2xlcyA9IHt9O1xuICAgICAgICB0aGlzLm1fdmlzaXRlZFZlcnRpY2VzID0ge307XG4gICAgICAgIHRoaXMubV92aXNpdGVkVmVydGljZXNWYWxlbmNlID0ge307XG4gICAgICAgIHRoaXMubV92ZXJ0ZXhUb1RyaWFuZ2xlID0gbmV3IG1vZHVsZS5BZGphY2VuY3lJbmZvKCk7XG4gICAgICAgIHRoaXMubV9jdGZhbnMgPSBuZXcgbW9kdWxlLkNvbXByZXNzZWRUcmlhbmdsZUZhbnMoKTtcbiAgICAgICAgdGhpcy5tX3RmYW5zID0gbmV3IG1vZHVsZS5UcmlhbmdsZUZhbnMoKTtcbiAgICAgICAgdGhpcy5tX3N0cmVhbVR5cGUgPSBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9BU0NJSTtcbiAgICAgICAgdGhpcy5tX2RlY29kZVRyaWFuZ2xlc09yZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMubV9kZWNvZGVWZXJ0aWNlc09yZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMubV9wcm9jZXNzQ29uZmlnID0ge1xuICAgICAgICAgICAgMDogZnVuY3Rpb24gKGRlY29kZXIsIGRlZ3JlZSkgeyAvLyBvcHM6IDEwMDAwMDEgdmVydGljZXM6IC0xIC0yXG4gICAgICAgICAgICAgICAgdmFyIHU7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmlzaXRlZFZlcnRpY2VzWzBdKTtcbiAgICAgICAgICAgICAgICBmb3IgKHUgPSAxOyB1IDwgZGVncmVlIC0gMTsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbZGVjb2Rlci5tX251bVZpc2l0ZWRWZXJ0aWNlcysrXSA9IGRlY29kZXIubV92ZXJ0ZXhDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmVydGV4Q291bnQrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZXIubV90ZmFucy5BZGRWZXJ0ZXgoZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1sxXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMTogZnVuY3Rpb24gKGRlY29kZXIsIGRlZ3JlZSwgZm9jdXNWZXJ0ZXgpIHsgLy8gb3BzOiAxeHh4eHh4MSB2ZXJ0aWNlczogLTEgeCB4IHggeCB4IC0yXG4gICAgICAgICAgICAgICAgdmFyIHUsIG9wLCBpbmRleDtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbMF0pO1xuICAgICAgICAgICAgICAgIGZvciAodSA9IDE7IHUgPCBkZWdyZWUgLSAxOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBkZWNvZGVyLm1fY3RmYW5zLlJlYWRPcGVyYXRpb24oZGVjb2Rlci5tX2l0T3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGRlY29kZXIubV9jdGZhbnMuUmVhZEluZGV4KGRlY29kZXIubV9pdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbLWluZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGluZGV4ICsgZm9jdXNWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1tkZWNvZGVyLm1fbnVtVmlzaXRlZFZlcnRpY2VzKytdID0gZGVjb2Rlci5tX3ZlcnRleENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmVydGV4Q291bnQrKyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmlzaXRlZFZlcnRpY2VzWzFdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAyOiBmdW5jdGlvbiAoZGVjb2RlciwgZGVncmVlKSB7IC8vIG9wczogMDAwMDAwMDEgdmVydGljZXM6IC0xXG4gICAgICAgICAgICAgICAgdmFyIHU7XG4gICAgICAgICAgICAgICAgZm9yICh1ID0gMDsgdSA8IGRlZ3JlZSAtIDE7ICsrdSkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdmlzaXRlZFZlcnRpY2VzW2RlY29kZXIubV9udW1WaXNpdGVkVmVydGljZXMrK10gPSBkZWNvZGVyLm1fdmVydGV4Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIubV90ZmFucy5BZGRWZXJ0ZXgoZGVjb2Rlci5tX3ZlcnRleENvdW50KyspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbMF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDM6IGZ1bmN0aW9uIChkZWNvZGVyLCBkZWdyZWUpIHsgLy8gb3BzOiAwMDAwMDAwMSB2ZXJ0aWNlczogLTJcbiAgICAgICAgICAgICAgICB2YXIgdTtcbiAgICAgICAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgZGVncmVlIC0gMTsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbZGVjb2Rlci5tX251bVZpc2l0ZWRWZXJ0aWNlcysrXSA9IGRlY29kZXIubV92ZXJ0ZXhDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmVydGV4Q291bnQrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZXIubV90ZmFucy5BZGRWZXJ0ZXgoZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1sxXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNDogZnVuY3Rpb24gKGRlY29kZXIsIGRlZ3JlZSkgey8vIG9wczogMTAwMDAwMDAgdmVydGljZXM6IC0xXG4gICAgICAgICAgICAgICAgdmFyIHU7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmlzaXRlZFZlcnRpY2VzWzBdKTtcbiAgICAgICAgICAgICAgICBmb3IgKHUgPSAxOyB1IDwgZGVncmVlOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1tkZWNvZGVyLm1fbnVtVmlzaXRlZFZlcnRpY2VzKytdID0gZGVjb2Rlci5tX3ZlcnRleENvdW50O1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92ZXJ0ZXhDb3VudCsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNTogZnVuY3Rpb24gKGRlY29kZXIsIGRlZ3JlZSkgeyAvLyBvcHM6IDEwMDAwMDAwIHZlcnRpY2VzOiAtMlxuICAgICAgICAgICAgICAgIHZhciB1O1xuICAgICAgICAgICAgICAgIGRlY29kZXIubV90ZmFucy5BZGRWZXJ0ZXgoZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1sxXSk7XG4gICAgICAgICAgICAgICAgZm9yICh1ID0gMTsgdSA8IGRlZ3JlZTsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbZGVjb2Rlci5tX251bVZpc2l0ZWRWZXJ0aWNlcysrXSA9IGRlY29kZXIubV92ZXJ0ZXhDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmVydGV4Q291bnQrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIDY6IGZ1bmN0aW9uIChkZWNvZGVyLCBkZWdyZWUpIHsgLy8gb3BzOiAwMDAwMDAwMCB2ZXJ0aWNlczpcbiAgICAgICAgICAgICAgICB2YXIgdTtcbiAgICAgICAgICAgICAgICBmb3IgKHUgPSAwOyB1IDwgZGVncmVlOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1tkZWNvZGVyLm1fbnVtVmlzaXRlZFZlcnRpY2VzKytdID0gZGVjb2Rlci5tX3ZlcnRleENvdW50O1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92ZXJ0ZXhDb3VudCsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgNzogZnVuY3Rpb24gKGRlY29kZXIsIGRlZ3JlZSkgeyAvLyBvcHM6IDEwMDAwMDEgdmVydGljZXM6IC0yIC0xXG4gICAgICAgICAgICAgICAgdmFyIHU7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmlzaXRlZFZlcnRpY2VzWzFdKTtcbiAgICAgICAgICAgICAgICBmb3IgKHUgPSAxOyB1IDwgZGVncmVlIC0gMTsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbZGVjb2Rlci5tX251bVZpc2l0ZWRWZXJ0aWNlcysrXSA9IGRlY29kZXIubV92ZXJ0ZXhDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmVydGV4Q291bnQrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZXIubV90ZmFucy5BZGRWZXJ0ZXgoZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1swXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgODogZnVuY3Rpb24gKGRlY29kZXIsIGRlZ3JlZSwgZm9jdXNWZXJ0ZXgpIHsgLy8gb3BzOiAxeHh4eHh4MSB2ZXJ0aWNlczogLTIgeCB4IHggeCB4IC0xXG4gICAgICAgICAgICAgICAgdmFyIHUsIG9wLCBpbmRleDtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbMV0pO1xuICAgICAgICAgICAgICAgIGZvciAodSA9IDE7IHUgPCBkZWdyZWUgLSAxOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBkZWNvZGVyLm1fY3RmYW5zLlJlYWRPcGVyYXRpb24oZGVjb2Rlci5tX2l0T3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGRlY29kZXIubV9jdGZhbnMuUmVhZEluZGV4KGRlY29kZXIubV9pdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92aXNpdGVkVmVydGljZXNbLWluZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGluZGV4ICsgZm9jdXNWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1tkZWNvZGVyLm1fbnVtVmlzaXRlZFZlcnRpY2VzKytdID0gZGVjb2Rlci5tX3ZlcnRleENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmVydGV4Q291bnQrKyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2Rlci5tX3RmYW5zLkFkZFZlcnRleChkZWNvZGVyLm1fdmlzaXRlZFZlcnRpY2VzWzBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICA5OiBmdW5jdGlvbiAoZGVjb2RlciwgZGVncmVlLCBmb2N1c1ZlcnRleCkgeyAvLyBnZW5lcmFsIGNhc2VcbiAgICAgICAgICAgICAgICB2YXIgdSwgb3AsIGluZGV4O1xuICAgICAgICAgICAgICAgIGZvciAodSA9IDA7IHUgPCBkZWdyZWU7ICsrdSkge1xuICAgICAgICAgICAgICAgICAgICBvcCA9IGRlY29kZXIubV9jdGZhbnMuUmVhZE9wZXJhdGlvbihkZWNvZGVyLm1faXRPcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZGVjb2Rlci5tX2N0ZmFucy5SZWFkSW5kZXgoZGVjb2Rlci5tX2l0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZXIubV90ZmFucy5BZGRWZXJ0ZXgoZGVjb2Rlci5tX3Zpc2l0ZWRWZXJ0aWNlc1staW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZXIubV90ZmFucy5BZGRWZXJ0ZXgoaW5kZXggKyBmb2N1c1ZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdmlzaXRlZFZlcnRpY2VzW2RlY29kZXIubV9udW1WaXNpdGVkVmVydGljZXMrK10gPSBkZWNvZGVyLm1fdmVydGV4Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVyLm1fdGZhbnMuQWRkVmVydGV4KGRlY29kZXIubV92ZXJ0ZXhDb3VudCsrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUxpc3REZWNvZGVyLnByb3RvdHlwZS5HZXRTdHJlYW1UeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3N0cmVhbVR5cGU7XG4gICAgfTtcbiAgICBtb2R1bGUuVHJpYW5nbGVMaXN0RGVjb2Rlci5wcm90b3R5cGUuR2V0UmVvcmRlclRyaWFuZ2xlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9kZWNvZGVUcmlhbmdsZXNPcmRlcjtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUxpc3REZWNvZGVyLnByb3RvdHlwZS5HZXRSZW9yZGVyVmVydGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZGVjb2RlVmVydGljZXNPcmRlcjtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUxpc3REZWNvZGVyLnByb3RvdHlwZS5TZXRTdHJlYW1UeXBlID0gZnVuY3Rpb24gKHN0cmVhbVR5cGUpIHtcbiAgICAgICAgdGhpcy5tX3N0cmVhbVR5cGUgPSBzdHJlYW1UeXBlO1xuICAgIH07XG4gICAgbW9kdWxlLlRyaWFuZ2xlTGlzdERlY29kZXIucHJvdG90eXBlLkdldFZlcnRleFRvVHJpYW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fdmVydGV4VG9UcmlhbmdsZTtcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUxpc3REZWNvZGVyLnByb3RvdHlwZS5SZW9yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJpYW5nbGVzLCBudW1UcmlhbmdsZXMsIG9yZGVyLCBpdCwgcHJldlRyaWFuZ2xlSW5kZXgsIHRlbXBUcmlhbmdsZXMsIHQsIGk7XG4gICAgICAgIGlmICh0aGlzLm1fZGVjb2RlVHJpYW5nbGVzT3JkZXIpIHtcbiAgICAgICAgICAgIHRyaWFuZ2xlcyA9IHRoaXMubV90cmlhbmdsZXM7XG4gICAgICAgICAgICBudW1UcmlhbmdsZXMgPSB0aGlzLm1fbnVtVHJpYW5nbGVzO1xuICAgICAgICAgICAgb3JkZXIgPSB0aGlzLm1fY3RmYW5zLm1fdHJpYW5nbGVzT3JkZXIubV9kYXRhO1xuICAgICAgICAgICAgdGVtcFRyaWFuZ2xlcyA9IHRoaXMubV90ZW1wVHJpYW5nbGVzO1xuICAgICAgICAgICAgdGVtcFRyaWFuZ2xlcy5zZXQodHJpYW5nbGVzKTtcbiAgICAgICAgICAgIGl0ID0gMDtcbiAgICAgICAgICAgIHByZXZUcmlhbmdsZUluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1UcmlhbmdsZXM7ICsraSkge1xuICAgICAgICAgICAgICAgIHQgPSBVSW50VG9JbnQob3JkZXJbaXQrK10pICsgcHJldlRyaWFuZ2xlSW5kZXg7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzWzMgKiB0XSA9IHRlbXBUcmlhbmdsZXNbMyAqIGldO1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlc1szICogdCArIDFdID0gdGVtcFRyaWFuZ2xlc1szICogaSArIDFdO1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlc1szICogdCArIDJdID0gdGVtcFRyaWFuZ2xlc1szICogaSArIDJdO1xuICAgICAgICAgICAgICAgIHByZXZUcmlhbmdsZUluZGV4ID0gdCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUxpc3REZWNvZGVyLnByb3RvdHlwZS5Db21wdWVMb2NhbENvbm5lY3Rpdml0eUluZm8gPSBmdW5jdGlvbiAoZm9jdXNWZXJ0ZXgpIHtcbiAgICAgICAgdmFyIHZpc2l0ZWRWZXJ0aWNlcywgdmlzaXRlZFZlcnRpY2VzVmFsZW5jZSwgdHJpYW5nbGVzLCB2ZXJ0ZXhUb1RyaWFuZ2xlLCBiZWdpblYyVCwgZW5kVjJULCBudW1Db25xdWVyZWRUcmlhbmdsZXMsIGZvdW5kT3JJbnNlcnRlZCwgbnVtVmlzaXRlZFZlcnRpY2VzLCB0bXAsIGksIGosIGssIGgsIHgsIHksIHQsIHAsIHY7XG4gICAgICAgIHZpc2l0ZWRWZXJ0aWNlcyA9IHRoaXMubV92aXNpdGVkVmVydGljZXM7XG4gICAgICAgIHZpc2l0ZWRWZXJ0aWNlc1ZhbGVuY2UgPSB0aGlzLm1fdmlzaXRlZFZlcnRpY2VzVmFsZW5jZTtcbiAgICAgICAgdHJpYW5nbGVzID0gdGhpcy5tX3RyaWFuZ2xlcztcbiAgICAgICAgdmVydGV4VG9UcmlhbmdsZSA9IHRoaXMubV92ZXJ0ZXhUb1RyaWFuZ2xlO1xuICAgICAgICBiZWdpblYyVCA9IHZlcnRleFRvVHJpYW5nbGUuQmVnaW4oZm9jdXNWZXJ0ZXgpO1xuICAgICAgICBlbmRWMlQgPSB2ZXJ0ZXhUb1RyaWFuZ2xlLkVuZChmb2N1c1ZlcnRleCk7XG4gICAgICAgIG51bUNvbnF1ZXJlZFRyaWFuZ2xlcyA9IDA7XG4gICAgICAgIG51bVZpc2l0ZWRWZXJ0aWNlcyA9IDA7XG4gICAgICAgIHQgPSAwO1xuICAgICAgICBmb3IgKGkgPSBiZWdpblYyVDsgKHQgPj0gMCkgJiYgKGkgPCBlbmRWMlQpOyArK2kpIHtcbiAgICAgICAgICAgIHQgPSB2ZXJ0ZXhUb1RyaWFuZ2xlLkdldE5laWdoYm9yKGkpO1xuICAgICAgICAgICAgaWYgKHQgPj0gMCkge1xuICAgICAgICAgICAgICAgICsrbnVtQ29ucXVlcmVkVHJpYW5nbGVzO1xuICAgICAgICAgICAgICAgIHAgPSAzICogdDtcbiAgICAgICAgICAgICAgICAvLyBleHRyYWN0IHZpc2l0ZWQgdmVydGljZXNcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgMzsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB0cmlhbmdsZXNbcCArIGtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiA+IGZvY3VzVmVydGV4KSB7IC8vIHZlcnRpY2VzIGFyZSBpbnNlcnRpY2VzIGJ5IGluY3JlYXNpbmcgdHJhdmVyc2FsIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE9ySW5zZXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBudW1WaXNpdGVkVmVydGljZXM7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSB2aXNpdGVkVmVydGljZXNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFZlcnRpY2VzVmFsZW5jZVtqXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE9ySW5zZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCB2aXNpdGVkVmVydGljZXNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytudW1WaXNpdGVkVmVydGljZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaCA9IG51bVZpc2l0ZWRWZXJ0aWNlcyAtIDE7IGggPiBqOyAtLWgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRWZXJ0aWNlc1toXSA9IHZpc2l0ZWRWZXJ0aWNlc1toIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkVmVydGljZXNWYWxlbmNlW2hdID0gdmlzaXRlZFZlcnRpY2VzVmFsZW5jZVtoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFZlcnRpY2VzW2pdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFZlcnRpY2VzVmFsZW5jZVtqXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kT3JJbnNlcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRPckluc2VydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZFZlcnRpY2VzW251bVZpc2l0ZWRWZXJ0aWNlc10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRWZXJ0aWNlc1ZhbGVuY2VbbnVtVmlzaXRlZFZlcnRpY2VzXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtVmlzaXRlZFZlcnRpY2VzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtb3JkZXIgdmlzaXRlZCB2ZXJ0aWNlcyBieSB0YWtpbmcgaW50byBhY2NvdW50IHRoZWlyIHZhbGVuY2UgKGkuZS4sICMgb2YgY29ucXVlcmVkIHRyaWFuZ2xlcyBpbmNpZGVudCB0byBlYWNoIHZlcnRleClcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgY29uZmlnLiA5XG4gICAgICAgIGlmIChudW1WaXNpdGVkVmVydGljZXMgPiAyKSB7XG4gICAgICAgICAgICBmb3IgKHggPSAxOyB4IDwgbnVtVmlzaXRlZFZlcnRpY2VzOyArK3gpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFZlcnRpY2VzVmFsZW5jZVt4XSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh5ID4gMCkgJiYgKHZpc2l0ZWRWZXJ0aWNlc1ZhbGVuY2VbeV0gPCB2aXNpdGVkVmVydGljZXNWYWxlbmNlW3kgLSAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHZpc2l0ZWRWZXJ0aWNlc1ZhbGVuY2VbeV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkVmVydGljZXNWYWxlbmNlW3ldID0gdmlzaXRlZFZlcnRpY2VzVmFsZW5jZVt5IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkVmVydGljZXNWYWxlbmNlW3kgLSAxXSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHZpc2l0ZWRWZXJ0aWNlc1t5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0ZWRWZXJ0aWNlc1t5XSA9IHZpc2l0ZWRWZXJ0aWNlc1t5IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkVmVydGljZXNbeSAtIDFdID0gdG1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgLS15O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubV9udW1Db25xdWVyZWRUcmlhbmdsZXMgPSBudW1Db25xdWVyZWRUcmlhbmdsZXM7XG4gICAgICAgIHRoaXMubV9udW1WaXNpdGVkVmVydGljZXMgPSBudW1WaXNpdGVkVmVydGljZXM7XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuVHJpYW5nbGVMaXN0RGVjb2Rlci5wcm90b3R5cGUuRGVjb21wcmVzc1RGQU4gPSBmdW5jdGlvbiAoZm9jdXNWZXJ0ZXgpIHtcbiAgICAgICAgdmFyIHZlcnRleFRvVHJpYW5nbGUsIHRyaWFuZ2xlcywgaXREZWdyZWUsIGl0Q29uZmlnLCB0ZmFucywgbnRmYW5zLCBwcm9jZXNzQ29uZmlnLCBjdGZhbnMsIHRyaWFuZ2xlQ291bnQsIG51bUNvbnF1ZXJlZFRyaWFuZ2xlcywgZGVncmVlLCBjb25maWcsIGswLCBrMSwgYiwgYywgdCwgZiwgaztcbiAgICAgICAgdmVydGV4VG9UcmlhbmdsZSA9IHRoaXMubV92ZXJ0ZXhUb1RyaWFuZ2xlO1xuICAgICAgICB0cmlhbmdsZXMgPSB0aGlzLm1fdHJpYW5nbGVzO1xuICAgICAgICBpdERlZ3JlZSA9IHRoaXMubV9pdERlZ3JlZTtcbiAgICAgICAgaXRDb25maWcgPSB0aGlzLm1faXRDb25maWc7XG4gICAgICAgIHRmYW5zID0gdGhpcy5tX3RmYW5zO1xuICAgICAgICBwcm9jZXNzQ29uZmlnID0gdGhpcy5tX3Byb2Nlc3NDb25maWc7XG4gICAgICAgIGN0ZmFucyA9IHRoaXMubV9jdGZhbnM7XG4gICAgICAgIHRyaWFuZ2xlQ291bnQgPSB0aGlzLm1fdHJpYW5nbGVDb3VudDtcbiAgICAgICAgbnVtQ29ucXVlcmVkVHJpYW5nbGVzID0gdGhpcy5tX251bUNvbnF1ZXJlZFRyaWFuZ2xlcztcbiAgICAgICAgbnRmYW5zID0gY3RmYW5zLlJlYWROdW1URmFucyh0aGlzLm1faXROdW1URmFucyk7XG4gICAgICAgIGlmIChudGZhbnMgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGYgPSAwOyBmIDwgbnRmYW5zOyArK2YpIHtcbiAgICAgICAgICAgICAgICB0ZmFucy5BZGRURkFOKCk7XG4gICAgICAgICAgICAgICAgZGVncmVlID0gY3RmYW5zLlJlYWREZWdyZWUoaXREZWdyZWUpICsgMiAtIG51bUNvbnF1ZXJlZFRyaWFuZ2xlcztcbiAgICAgICAgICAgICAgICBjb25maWcgPSBjdGZhbnMuUmVhZENvbmZpZyhpdENvbmZpZyk7XG4gICAgICAgICAgICAgICAgazAgPSB0ZmFucy5HZXROdW1WZXJ0aWNlcygpO1xuICAgICAgICAgICAgICAgIHRmYW5zLkFkZFZlcnRleChmb2N1c1ZlcnRleCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0NvbmZpZ1tjb25maWddKHRoaXMsIGRlZ3JlZSwgZm9jdXNWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIGsxID0gdGZhbnMuR2V0TnVtVmVydGljZXMoKTtcbiAgICAgICAgICAgICAgICBiID0gdGZhbnMuR2V0VmVydGV4KGswICsgMSk7XG4gICAgICAgICAgICAgICAgZm9yIChrID0gazAgKyAyOyBrIDwgazE7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBjID0gdGZhbnMuR2V0VmVydGV4KGspO1xuICAgICAgICAgICAgICAgICAgICB0ID0gdHJpYW5nbGVDb3VudCAqIDM7XG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlc1t0KytdID0gZm9jdXNWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlc1t0KytdID0gYjtcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVzW3RdID0gYztcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4VG9UcmlhbmdsZS5BZGROZWlnaGJvcihmb2N1c1ZlcnRleCwgdHJpYW5nbGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFRvVHJpYW5nbGUuQWRkTmVpZ2hib3IoYiwgdHJpYW5nbGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRleFRvVHJpYW5nbGUuQWRkTmVpZ2hib3IoYywgdHJpYW5nbGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBjO1xuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubV90cmlhbmdsZUNvdW50ID0gdHJpYW5nbGVDb3VudDtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5UcmlhbmdsZUxpc3REZWNvZGVyLnByb3RvdHlwZS5EZWNvbXByZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm9jdXNWZXJ0ZXg7XG4gICAgICAgIGZvciAoZm9jdXNWZXJ0ZXggPSAwOyBmb2N1c1ZlcnRleCA8IHRoaXMubV9udW1WZXJ0aWNlczsgKytmb2N1c1ZlcnRleCkge1xuICAgICAgICAgICAgaWYgKGZvY3VzVmVydGV4ID09PSB0aGlzLm1fdmVydGV4Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fdmVydGV4Q291bnQrKzsgLy8gaW5zZXJ0IGZvY3VzVmVydGV4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLkNvbXB1ZUxvY2FsQ29ubmVjdGl2aXR5SW5mbyhmb2N1c1ZlcnRleCk7XG4gICAgICAgICAgICB0aGlzLkRlY29tcHJlc3NURkFOKGZvY3VzVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLlRyaWFuZ2xlTGlzdERlY29kZXIucHJvdG90eXBlLkluaXQgPSBmdW5jdGlvbiAodHJpYW5nbGVzLCBudW1UcmlhbmdsZXMsIG51bVZlcnRpY2VzLCBtYXhTaXplVjJUKSB7XG4gICAgICAgIHZhciBpLCBudW1OZWlnaGJvcnM7XG4gICAgICAgIHRoaXMubV9udW1UcmlhbmdsZXMgPSBudW1UcmlhbmdsZXM7XG4gICAgICAgIHRoaXMubV9udW1WZXJ0aWNlcyA9IG51bVZlcnRpY2VzO1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVzID0gdHJpYW5nbGVzO1xuICAgICAgICB0aGlzLm1fdmVydGV4Q291bnQgPSAwO1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9pdE51bVRGYW5zLm1fY291bnQgPSAwO1xuICAgICAgICB0aGlzLm1faXREZWdyZWUubV9jb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9pdENvbmZpZy5tX2NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX2l0T3BlcmF0aW9uLm1fY291bnQgPSAwO1xuICAgICAgICB0aGlzLm1faXRJbmRleC5tX2NvdW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMubV9udW1WZXJ0aWNlcyA+IHRoaXMubV9tYXhOdW1WZXJ0aWNlcykge1xuICAgICAgICAgICAgdGhpcy5tX21heE51bVZlcnRpY2VzID0gdGhpcy5tX251bVZlcnRpY2VzO1xuICAgICAgICAgICAgdGhpcy5tX3Zpc2l0ZWRWZXJ0aWNlc1ZhbGVuY2UgPSBuZXcgSW50MzJBcnJheSh0aGlzLm1fbnVtVmVydGljZXMpO1xuICAgICAgICAgICAgdGhpcy5tX3Zpc2l0ZWRWZXJ0aWNlcyA9IG5ldyBJbnQzMkFycmF5KHRoaXMubV9udW1WZXJ0aWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubV9kZWNvZGVUcmlhbmdsZXNPcmRlciAmJiB0aGlzLm1fdGVtcFRyaWFuZ2xlc1NpemUgPCB0aGlzLm1fbnVtVHJpYW5nbGVzKSB7XG4gICAgICAgICAgICB0aGlzLm1fdGVtcFRyaWFuZ2xlc1NpemUgPSB0aGlzLm1fbnVtVHJpYW5nbGVzO1xuICAgICAgICAgICAgdGhpcy5tX3RlbXBUcmlhbmdsZXMgPSBuZXcgSW50MzJBcnJheSgzICogdGhpcy5tX3RlbXBUcmlhbmdsZXNTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1fY3RmYW5zLlNldFN0cmVhbVR5cGUodGhpcy5tX3N0cmVhbVR5cGUpO1xuICAgICAgICB0aGlzLm1fY3RmYW5zLkFsbG9jYXRlKHRoaXMubV9udW1WZXJ0aWNlcywgdGhpcy5tX251bVRyaWFuZ2xlcyk7XG4gICAgICAgIHRoaXMubV90ZmFucy5BbGxvY2F0ZSgyICogdGhpcy5tX251bVZlcnRpY2VzLCA4ICogdGhpcy5tX251bVZlcnRpY2VzKTtcbiAgICAgICAgLy8gY29tcHV0ZSB2ZXJ0ZXgtdG8tdHJpYW5nbGUgYWRqYWNlbmN5IGluZm9ybWF0aW9uXG4gICAgICAgIHRoaXMubV92ZXJ0ZXhUb1RyaWFuZ2xlLkFsbG9jYXRlTnVtTmVpZ2hib3JzQXJyYXkobnVtVmVydGljZXMpO1xuICAgICAgICBudW1OZWlnaGJvcnMgPSB0aGlzLm1fdmVydGV4VG9UcmlhbmdsZS5HZXROdW1OZWlnaGJvcnNCdWZmZXIoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVZlcnRpY2VzOyArK2kpIHtcbiAgICAgICAgICAgIG51bU5laWdoYm9yc1tpXSA9IG1heFNpemVWMlQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX3ZlcnRleFRvVHJpYW5nbGUuQWxsb2NhdGVOZWlnaGJvcnNBcnJheSgpO1xuICAgICAgICB0aGlzLm1fdmVydGV4VG9UcmlhbmdsZS5DbGVhck5laWdoYm9yc0FycmF5KCk7XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuVHJpYW5nbGVMaXN0RGVjb2Rlci5wcm90b3R5cGUuRGVjb2RlID0gZnVuY3Rpb24gKHRyaWFuZ2xlcywgbnVtVHJpYW5nbGVzLCBudW1WZXJ0aWNlcywgYnN0cmVhbSwgaXQpIHtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uTWFzaywgbWF4U2l6ZVYyVDtcbiAgICAgICAgY29tcHJlc3Npb25NYXNrID0gYnN0cmVhbS5SZWFkVUNoYXIoaXQsIHRoaXMubV9zdHJlYW1UeXBlKTtcbiAgICAgICAgdGhpcy5tX2RlY29kZVRyaWFuZ2xlc09yZGVyID0gKChjb21wcmVzc2lvbk1hc2sgJiAyKSAhPT0gMCk7XG4gICAgICAgIHRoaXMubV9kZWNvZGVWZXJ0aWNlc09yZGVyID0gKChjb21wcmVzc2lvbk1hc2sgJiAxKSAhPT0gMCk7XG4gICAgICAgIGlmICh0aGlzLm1fZGVjb2RlVmVydGljZXNPcmRlcikgeyAvLyB2ZXJ0aWNlcyByZW9yZGVyaW5nIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfRVJST1JfTk9OX1NVUFBPUlRFRF9GRUFUVVJFO1xuICAgICAgICB9XG4gICAgICAgIG1heFNpemVWMlQgPSBic3RyZWFtLlJlYWRVSW50MzIoaXQsIHRoaXMubV9zdHJlYW1UeXBlKTtcbiAgICAgICAgdGhpcy5Jbml0KHRyaWFuZ2xlcywgbnVtVHJpYW5nbGVzLCBudW1WZXJ0aWNlcywgbWF4U2l6ZVYyVCk7XG4gICAgICAgIHRoaXMubV9jdGZhbnMuTG9hZChic3RyZWFtLCBpdCwgdGhpcy5tX2RlY29kZVRyaWFuZ2xlc09yZGVyLCB0aGlzLm1fc3RyZWFtVHlwZSk7XG4gICAgICAgIHRoaXMuRGVjb21wcmVzcygpO1xuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgLy8gU0MzRE1DRGVjb2RlciBjbGFzc1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdGhpcy5tX2l0ZXJhdG9yID0gbmV3IG1vZHVsZS5JdGVyYXRvcigpO1xuICAgICAgICB0aGlzLm1fc3RyZWFtU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubV9wYXJhbXMgPSBuZXcgbW9kdWxlLlNDM0RNQ0VuY29kZVBhcmFtcygpO1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVMaXN0RGVjb2RlciA9IG5ldyBtb2R1bGUuVHJpYW5nbGVMaXN0RGVjb2RlcigpO1xuICAgICAgICB0aGlzLm1fcXVhbnRGbG9hdEFycmF5ID0ge307XG4gICAgICAgIHRoaXMubV9vcmllbnRhdGlvbiA9IHt9O1xuICAgICAgICB0aGlzLm1fbm9ybWFscyA9IHt9O1xuICAgICAgICB0aGlzLm1fcXVhbnRGbG9hdEFycmF5U2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubV9ub3JtYWxzU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubV9vcmllbnRhdGlvblNpemUgPSAwO1xuICAgICAgICB0aGlzLm1fc3RhdHMgPSBuZXcgbW9kdWxlLlNDM0RNQ1N0YXRzKCk7XG4gICAgICAgIHRoaXMubV9zdHJlYW1UeXBlID0gbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfVU5LT1dOO1xuICAgICAgICB0aGlzLm1fbmVpZ2hib3JzID0gW107XG4gICAgICAgIHRoaXMubV9pZGVsdGEgPSBuZXcgRmxvYXQzMkFycmF5KGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfRElNX0FUVFJJQlVURVMpO1xuICAgICAgICB0aGlzLm1fbWluTm9ybWFsID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgdGhpcy5tX21heE5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgICAgIHRoaXMubV9taW5Ob3JtYWxbMF0gPSB0aGlzLm1fbWluTm9ybWFsWzFdID0gLTI7XG4gICAgICAgIHRoaXMubV9tYXhOb3JtYWxbMF0gPSB0aGlzLm1fbWF4Tm9ybWFsWzFdID0gMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfRElNX0FUVFJJQlVURVM7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5tX25laWdoYm9yc1tpXSA9IG5ldyBtb2R1bGUuU0MzRE1DUHJlZGljdG9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5HZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9zdGF0cztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVIZWFkZXIgPSBmdW5jdGlvbiAoaWZzLCBic3RyZWFtKSB7XG4gICAgICAgIHZhciBjMCwgc3RhcnRfY29kZSwgbWFzaywgaiwgYSwgZDtcbiAgICAgICAgYzAgPSB0aGlzLm1faXRlcmF0b3IubV9jb3VudDtcbiAgICAgICAgc3RhcnRfY29kZSA9IGJzdHJlYW0uUmVhZFVJbnQzMih0aGlzLm1faXRlcmF0b3IsIGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0JJTkFSWSk7XG4gICAgICAgIGlmIChzdGFydF9jb2RlICE9PSBsb2NhbC5PM0RHQ19TQzNETUNfU1RBUlRfQ09ERSkge1xuICAgICAgICAgICAgdGhpcy5tX2l0ZXJhdG9yLm1fY291bnQgPSBjMDtcbiAgICAgICAgICAgIHN0YXJ0X2NvZGUgPSBic3RyZWFtLlJlYWRVSW50MzIodGhpcy5tX2l0ZXJhdG9yLCBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9BU0NJSSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRfY29kZSAhPT0gbG9jYWwuTzNER0NfU0MzRE1DX1NUQVJUX0NPREUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX0VSUk9SX0NPUlJVUFRFRF9TVFJFQU07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fc3RyZWFtVHlwZSA9IGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0FTQ0lJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tX3N0cmVhbVR5cGUgPSBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9CSU5BUlk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX3N0cmVhbVNpemUgPSBic3RyZWFtLlJlYWRVSW50MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSk7XG4gICAgICAgIHRoaXMubV9wYXJhbXMuU2V0RW5jb2RlTW9kZShic3RyZWFtLlJlYWRVQ2hhcih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKSk7XG5cbiAgICAgICAgaWZzLlNldENyZWFzZUFuZ2xlKGJzdHJlYW0uUmVhZEZsb2F0MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSkpO1xuICAgICAgICBtYXNrID0gYnN0cmVhbS5SZWFkVUNoYXIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSk7XG4gICAgICAgIGlmcy5TZXRDQ1coKG1hc2sgJiAxKSA9PT0gMSk7XG4gICAgICAgIGlmcy5TZXRTb2xpZCgobWFzayAmIDIpID09PSAxKTtcbiAgICAgICAgaWZzLlNldENvbnZleCgobWFzayAmIDQpID09PSAxKTtcbiAgICAgICAgaWZzLlNldElzVHJpYW5ndWxhck1lc2goKG1hc2sgJiA4KSA9PT0gMSk7XG5cbiAgICAgICAgaWZzLlNldE5Db29yZChic3RyZWFtLlJlYWRVSW50MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSkpO1xuICAgICAgICBpZnMuU2V0Tk5vcm1hbChic3RyZWFtLlJlYWRVSW50MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSkpO1xuICAgICAgICBpZnMuU2V0TnVtRmxvYXRBdHRyaWJ1dGVzKGJzdHJlYW0uUmVhZFVJbnQzMih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKSk7XG4gICAgICAgIGlmcy5TZXROdW1JbnRBdHRyaWJ1dGVzKGJzdHJlYW0uUmVhZFVJbnQzMih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKSk7XG5cbiAgICAgICAgaWYgKGlmcy5HZXROQ29vcmQoKSA+IDApIHtcbiAgICAgICAgICAgIGlmcy5TZXROQ29vcmRJbmRleChic3RyZWFtLlJlYWRVSW50MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSkpO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7ICsraikge1xuICAgICAgICAgICAgICAgIGlmcy5TZXRDb29yZE1pbihqLCBic3RyZWFtLlJlYWRGbG9hdDMyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgICAgICBpZnMuU2V0Q29vcmRNYXgoaiwgYnN0cmVhbS5SZWFkRmxvYXQzMih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1fcGFyYW1zLlNldENvb3JkUXVhbnRCaXRzKGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWZzLkdldE5Ob3JtYWwoKSA+IDApIHtcbiAgICAgICAgICAgIGlmcy5TZXROTm9ybWFsSW5kZXgoYnN0cmVhbS5SZWFkVUludDMyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCAzOyArK2opIHtcbiAgICAgICAgICAgICAgICBpZnMuU2V0Tm9ybWFsTWluKGosIGJzdHJlYW0uUmVhZEZsb2F0MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSkpO1xuICAgICAgICAgICAgICAgIGlmcy5TZXROb3JtYWxNYXgoaiwgYnN0cmVhbS5SZWFkRmxvYXQzMih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZnMuU2V0Tm9ybWFsUGVyVmVydGV4KGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpID09PSAxKTtcbiAgICAgICAgICAgIHRoaXMubV9wYXJhbXMuU2V0Tm9ybWFsUXVhbnRCaXRzKGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGEgPSAwOyBhIDwgaWZzLkdldE51bUZsb2F0QXR0cmlidXRlcygpOyArK2EpIHtcbiAgICAgICAgICAgIGlmcy5TZXRORmxvYXRBdHRyaWJ1dGUoYSwgYnN0cmVhbS5SZWFkVUludDMyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgIGlmIChpZnMuR2V0TkZsb2F0QXR0cmlidXRlKGEpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmcy5TZXRORmxvYXRBdHRyaWJ1dGVJbmRleChhLCBic3RyZWFtLlJlYWRVSW50MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSkpO1xuICAgICAgICAgICAgICAgIGQgPSBic3RyZWFtLlJlYWRVQ2hhcih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKTtcbiAgICAgICAgICAgICAgICBpZnMuU2V0RmxvYXRBdHRyaWJ1dGVEaW0oYSwgZCk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGQ7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZnMuU2V0RmxvYXRBdHRyaWJ1dGVNaW4oYSwgaiwgYnN0cmVhbS5SZWFkRmxvYXQzMih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmcy5TZXRGbG9hdEF0dHJpYnV0ZU1heChhLCBqLCBic3RyZWFtLlJlYWRGbG9hdDMyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWZzLlNldEZsb2F0QXR0cmlidXRlUGVyVmVydGV4KGEsIGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpID09PSAxKTtcbiAgICAgICAgICAgICAgICBpZnMuU2V0RmxvYXRBdHRyaWJ1dGVUeXBlKGEsIGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fcGFyYW1zLlNldEZsb2F0QXR0cmlidXRlUXVhbnRCaXRzKGEsIGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGEgPSAwOyBhIDwgaWZzLkdldE51bUludEF0dHJpYnV0ZXMoKTsgKythKSB7XG4gICAgICAgICAgICBpZnMuU2V0TkludEF0dHJpYnV0ZShhLCBic3RyZWFtLlJlYWRVSW50MzIodGhpcy5tX2l0ZXJhdG9yLCB0aGlzLm1fc3RyZWFtVHlwZSkpO1xuICAgICAgICAgICAgaWYgKGlmcy5HZXROSW50QXR0cmlidXRlKGEpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmcy5TZXROSW50QXR0cmlidXRlSW5kZXgoYSwgYnN0cmVhbS5SZWFkVUludDMyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgICAgICBpZnMuU2V0SW50QXR0cmlidXRlRGltKGEsIGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpKTtcbiAgICAgICAgICAgICAgICBpZnMuU2V0SW50QXR0cmlidXRlUGVyVmVydGV4KGEsIGJzdHJlYW0uUmVhZFVDaGFyKHRoaXMubV9pdGVyYXRvciwgdGhpcy5tX3N0cmVhbVR5cGUpID09PSAxKTtcbiAgICAgICAgICAgICAgICBpZnMuU2V0SW50QXR0cmlidXRlVHlwZShhLCBic3RyZWFtLlJlYWRVQ2hhcih0aGlzLm1faXRlcmF0b3IsIHRoaXMubV9zdHJlYW1UeXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIERlbHRhUHJlZGljdG9ycyh0cmlhbmdsZXMsIHRhLCB2LCBuUHJlZCwgbmVpZ2hib3JzLCBkaW1GbG9hdEFycmF5LCBxdWFudEZsb2F0QXJyYXksIHN0cmlkZSkge1xuICAgICAgICB2YXIgd3MsIGssIHAsIHcsIGksIGlkO1xuICAgICAgICBpZCA9IG5ldyBtb2R1bGUuU0MzRE1DVHJpcGxldCgtMSwgLTEsIC0xKTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IDM7ICsraykge1xuICAgICAgICAgICAgdyA9IHRyaWFuZ2xlc1t0YSAqIDMgKyBrXTtcbiAgICAgICAgICAgIGlmICh3IDwgdikge1xuICAgICAgICAgICAgICAgIGlkLm1fYSA9IC0xO1xuICAgICAgICAgICAgICAgIGlkLm1fYiA9IC0xO1xuICAgICAgICAgICAgICAgIGlkLm1fYyA9IHc7XG4gICAgICAgICAgICAgICAgcCA9IEluc2VydFByZWRpY3RvcihpZCwgblByZWQsIG5laWdoYm9ycywgZGltRmxvYXRBcnJheSk7XG4gICAgICAgICAgICAgICAgaWYgKHAgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdzID0gdyAqIHN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpbUZsb2F0QXJyYXk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzW3BdLm1fcHJlZFtpXSA9IHF1YW50RmxvYXRBcnJheVt3cyArIGldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBhcmFsbGVsb2dyYW1QcmVkaWN0b3JzKHRyaWFuZ2xlcywgdGEsIHYsIG5QcmVkLCBuZWlnaGJvcnMsIGRpbUZsb2F0QXJyYXksIHF1YW50RmxvYXRBcnJheSwgc3RyaWRlLCB2MlQsIHYyVE5laWdoYm9ycykge1xuICAgICAgICB2YXIgdGEzLCB0YjMsIGFzLCBicywgY3MsIGEsIGIsIGMsIHgsIGksIGssIHUxX2JlZ2luLCB1MV9lbmQsIHUxLCB0YiwgZm91bmRCLCBwLCBpZDtcbiAgICAgICAgdGEzID0gdGEgKiAzO1xuICAgICAgICBpZCA9IG5ldyBtb2R1bGUuU0MzRE1DVHJpcGxldCgtMSwgLTEsIC0xKTtcbiAgICAgICAgaWYgKHRyaWFuZ2xlc1t0YTNdID09PSB2KSB7XG4gICAgICAgICAgICBhID0gdHJpYW5nbGVzW3RhMyArIDFdO1xuICAgICAgICAgICAgYiA9IHRyaWFuZ2xlc1t0YTMgKyAyXTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlhbmdsZXNbdGEzICsgMV0gPT09IHYpIHtcbiAgICAgICAgICAgIGEgPSB0cmlhbmdsZXNbdGEzXTtcbiAgICAgICAgICAgIGIgPSB0cmlhbmdsZXNbdGEzICsgMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhID0gdHJpYW5nbGVzW3RhM107XG4gICAgICAgICAgICBiID0gdHJpYW5nbGVzW3RhMyArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhIDwgdiAmJiBiIDwgdikge1xuICAgICAgICAgICAgdTFfYmVnaW4gPSB2MlQuQmVnaW4oYSk7XG4gICAgICAgICAgICB1MV9lbmQgPSB2MlQuRW5kKGEpO1xuICAgICAgICAgICAgZm9yICh1MSA9IHUxX2JlZ2luOyB1MSA8IHUxX2VuZDsgKyt1MSkge1xuICAgICAgICAgICAgICAgIHRiID0gdjJUTmVpZ2hib3JzW3UxXTtcbiAgICAgICAgICAgICAgICBpZiAodGIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YjMgPSB0YiAqIDM7XG4gICAgICAgICAgICAgICAgYyA9IC0xO1xuICAgICAgICAgICAgICAgIGZvdW5kQiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCAzOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRyaWFuZ2xlc1t0YjMgKyBrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPT09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kQiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeCA8IHYgJiYgeCAhPT0gYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMgIT09IC0xICYmIGZvdW5kQikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLm1fYSA9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZC5tX2IgPSBiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQubV9hID0gYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLm1fYiA9IGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWQubV9jID0gKC1jIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBJbnNlcnRQcmVkaWN0b3IoaWQsIG5QcmVkLCBuZWlnaGJvcnMsIGRpbUZsb2F0QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzID0gYSAqIHN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJzID0gYiAqIHN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzID0gYyAqIHN0cmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkaW1GbG9hdEFycmF5OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnNbcF0ubV9wcmVkW2ldID0gcXVhbnRGbG9hdEFycmF5W2FzICsgaV0gKyBxdWFudEZsb2F0QXJyYXlbYnMgKyBpXSAtIHF1YW50RmxvYXRBcnJheVtjcyArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVJbnRBcnJheUJpbmFyeSA9IGZ1bmN0aW9uIChpbnRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtSW50QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbUludEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJzdHJlYW0pIHtcbiAgICAgICAgdmFyIHRlc3RQcmVkRW5hYmxlZCwgYmVzdFByZWQsIGksIHUsIHRhLCB1X2JlZ2luLCB1X2VuZCwgYnVmZmVyLCBpdGVyYXRvciwgc3RyZWFtVHlwZSwgcHJlZFJlc2lkdWFsLCBhY2QsIGJNb2RlbDAsIGJNb2RlbDEsIG1Nb2RlbFByZWRzLCB2MlQsIHYyVE5laWdoYm9ycywgdHJpYW5nbGVzLCBzaXplLCBzdGFydCwgc3RyZWFtU2l6ZSwgbWFzaywgYmluYXJpemF0aW9uLCBpdGVyYXRvclByZWQsIGV4cF9rLCBNLCBpZCwgbU1vZGVsVmFsdWVzLCBuZWlnaGJvcnMsIG5vcm1hbHMsIG5QcmVkLCB2O1xuICAgICAgICBpdGVyYXRvciA9IHRoaXMubV9pdGVyYXRvcjtcbiAgICAgICAgc3RyZWFtVHlwZSA9IHRoaXMubV9zdHJlYW1UeXBlO1xuICAgICAgICBhY2QgPSBuZXcgbW9kdWxlLkFyaXRobWV0aWNEZWNvZGVyKCk7XG4gICAgICAgIGJNb2RlbDAgPSBuZXcgbW9kdWxlLlN0YXRpY0JpdE1vZGVsKCk7XG4gICAgICAgIGJNb2RlbDEgPSBuZXcgbW9kdWxlLkFkYXB0aXZlQml0TW9kZWwoKTtcbiAgICAgICAgbU1vZGVsUHJlZHMgPSBuZXcgbW9kdWxlLkFkYXB0aXZlRGF0YU1vZGVsKCk7XG4gICAgICAgIG1Nb2RlbFByZWRzLlNldEFscGhhYmV0KGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfUFJFRElDVElPTl9ORUlHSEJPUlMgKyAxKTtcbiAgICAgICAgdjJUID0gdGhpcy5tX3RyaWFuZ2xlTGlzdERlY29kZXIuR2V0VmVydGV4VG9UcmlhbmdsZSgpO1xuICAgICAgICB2MlROZWlnaGJvcnMgPSB2MlQubV9uZWlnaGJvcnM7XG4gICAgICAgIHRyaWFuZ2xlcyA9IGlmcy5HZXRDb29yZEluZGV4KCk7XG4gICAgICAgIHNpemUgPSBudW1JbnRBcnJheSAqIGRpbUludEFycmF5O1xuICAgICAgICBzdGFydCA9IGl0ZXJhdG9yLm1fY291bnQ7XG4gICAgICAgIHN0cmVhbVNpemUgPSBic3RyZWFtLlJlYWRVSW50MzIoaXRlcmF0b3IsIHN0cmVhbVR5cGUpOyAgICAgICAgLy8gYml0c3JlYW0gc2l6ZVxuICAgICAgICBtYXNrID0gYnN0cmVhbS5SZWFkVUNoYXIoaXRlcmF0b3IsIHN0cmVhbVR5cGUpO1xuICAgICAgICBiaW5hcml6YXRpb24gPSAobWFzayA+Pj4gNCkgJiA3O1xuICAgICAgICBwcmVkTW9kZS5tX3ZhbHVlID0gbWFzayAmIDc7XG4gICAgICAgIHN0cmVhbVNpemUgLT0gKGl0ZXJhdG9yLm1fY291bnQgLSBzdGFydCk7XG4gICAgICAgIGl0ZXJhdG9yUHJlZCA9IG5ldyBtb2R1bGUuSXRlcmF0b3IoKTtcbiAgICAgICAgaXRlcmF0b3JQcmVkLm1fY291bnQgPSBpdGVyYXRvci5tX2NvdW50ICsgc3RyZWFtU2l6ZTtcbiAgICAgICAgZXhwX2sgPSAwO1xuICAgICAgICBNID0gMDtcbiAgICAgICAgaWQgPSBuZXcgbW9kdWxlLlNDM0RNQ1RyaXBsZXQoLTEsIC0xLCAtMSk7XG4gICAgICAgIGlmIChiaW5hcml6YXRpb24gIT09IGxvY2FsLk8zREdDX1NDM0RNQ19CSU5BUklaQVRJT05fQUNfRUdDKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX0VSUk9SX0NPUlJVUFRFRF9TVFJFQU07XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyID0gYnN0cmVhbS5HZXRCdWZmZXIoaXRlcmF0b3IsIHN0cmVhbVNpemUpO1xuICAgICAgICBpdGVyYXRvci5tX2NvdW50ICs9IHN0cmVhbVNpemU7XG4gICAgICAgIGFjZC5TZXRCdWZmZXIoc3RyZWFtU2l6ZSwgYnVmZmVyKTtcbiAgICAgICAgYWNkLlN0YXJ0RGVjb2RlcigpO1xuICAgICAgICBleHBfayA9IGFjZC5FeHBHb2xvbWJEZWNvZGUoMCwgYk1vZGVsMCwgYk1vZGVsMSk7XG4gICAgICAgIE0gPSBhY2QuRXhwR29sb21iRGVjb2RlKDAsIGJNb2RlbDAsIGJNb2RlbDEpO1xuICAgICAgICBtTW9kZWxWYWx1ZXMgPSBuZXcgbW9kdWxlLkFkYXB0aXZlRGF0YU1vZGVsKCk7XG4gICAgICAgIG1Nb2RlbFZhbHVlcy5TZXRBbHBoYWJldChNICsgMik7XG4gICAgICAgIG5laWdoYm9ycyA9IHRoaXMubV9uZWlnaGJvcnM7XG4gICAgICAgIG5vcm1hbHMgPSB0aGlzLm1fbm9ybWFscztcbiAgICAgICAgblByZWQgPSBuZXcgbW9kdWxlLk51bWJlclJlZigpO1xuICAgICAgICB0ZXN0UHJlZEVuYWJsZWQgPSBwcmVkTW9kZS5tX3ZhbHVlICE9PSBsb2NhbC5PM0RHQ19TQzNETUNfTk9fUFJFRElDVElPTjtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IG51bUludEFycmF5OyArK3YpIHtcbiAgICAgICAgICAgIG5QcmVkLm1fdmFsdWUgPSAwO1xuICAgICAgICAgICAgaWYgKHYyVC5HZXROdW1OZWlnaGJvcnModikgPiAwICYmIHRlc3RQcmVkRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHVfYmVnaW4gPSB2MlQuQmVnaW4odik7XG4gICAgICAgICAgICAgICAgdV9lbmQgPSB2MlQuRW5kKHYpO1xuICAgICAgICAgICAgICAgIGZvciAodSA9IHVfYmVnaW47IHUgPCB1X2VuZDsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhID0gdjJUTmVpZ2hib3JzW3VdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBEZWx0YVByZWRpY3RvcnModHJpYW5nbGVzLCB0YSwgdiwgblByZWQsIG5laWdoYm9ycywgZGltSW50QXJyYXksIGludEFycmF5LCBzdHJpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuUHJlZC5tX3ZhbHVlID4gMSkge1xuICAgICAgICAgICAgICAgIGJlc3RQcmVkID0gYWNkLkRlY29kZUFkYXB0aXZlRGF0YU1vZGVsKG1Nb2RlbFByZWRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltSW50QXJyYXk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVkUmVzaWR1YWwgPSBhY2QuRGVjb2RlSW50QUNFR0MobU1vZGVsVmFsdWVzLCBiTW9kZWwwLCBiTW9kZWwxLCBleHBfaywgTSk7XG4gICAgICAgICAgICAgICAgICAgIGludEFycmF5W3YgKiBzdHJpZGUgKyBpXSA9IHByZWRSZXNpZHVhbCArIG5laWdoYm9yc1tiZXN0UHJlZF0ubV9wcmVkW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiA+IDAgJiYgcHJlZE1vZGUubV92YWx1ZSAhPT0gbG9jYWwuTzNER0NfU0MzRE1DX05PX1BSRURJQ1RJT04pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltSW50QXJyYXk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVkUmVzaWR1YWwgPSBhY2QuRGVjb2RlSW50QUNFR0MobU1vZGVsVmFsdWVzLCBiTW9kZWwwLCBiTW9kZWwxLCBleHBfaywgTSk7XG4gICAgICAgICAgICAgICAgICAgIGludEFycmF5W3YgKiBzdHJpZGUgKyBpXSA9IHByZWRSZXNpZHVhbCArIGludEFycmF5Wyh2IC0gMSkgKiBzdHJpZGUgKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkaW1JbnRBcnJheTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWRSZXNpZHVhbCA9IGFjZC5EZWNvZGVVSW50QUNFR0MobU1vZGVsVmFsdWVzLCBiTW9kZWwwLCBiTW9kZWwxLCBleHBfaywgTSk7XG4gICAgICAgICAgICAgICAgICAgIGludEFycmF5W3YgKiBzdHJpZGUgKyBpXSA9IHByZWRSZXNpZHVhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0b3IubV9jb3VudCA9IGl0ZXJhdG9yUHJlZC5tX2NvdW50O1xuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLlNDM0RNQ0RlY29kZXIucHJvdG90eXBlLkRlY29kZUludEFycmF5QVNDSUkgPSBmdW5jdGlvbiAoaW50QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtSW50QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltSW50QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBic3RyZWFtKSB7XG4gICAgICAgIHZhciB0ZXN0UHJlZEVuYWJsZWQsIGl0ZXJhdG9yLCBzdHJlYW1UeXBlLCBwcmVkUmVzaWR1YWwsIHYyVCwgdjJUTmVpZ2hib3JzLCB0cmlhbmdsZXMsIHNpemUsIHN0YXJ0LCBzdHJlYW1TaXplLCBtYXNrLCBiaW5hcml6YXRpb24sIGl0ZXJhdG9yUHJlZCwgaWQsIG5laWdoYm9ycywgbm9ybWFscywgblByZWQsIHYsIHVfYmVnaW4sIHVfZW5kLCB1LCB0YSwgaSwgYmVzdFByZWQ7XG4gICAgICAgIGl0ZXJhdG9yID0gdGhpcy5tX2l0ZXJhdG9yO1xuICAgICAgICBzdHJlYW1UeXBlID0gdGhpcy5tX3N0cmVhbVR5cGU7XG4gICAgICAgIHYyVCA9IHRoaXMubV90cmlhbmdsZUxpc3REZWNvZGVyLkdldFZlcnRleFRvVHJpYW5nbGUoKTtcbiAgICAgICAgdjJUTmVpZ2hib3JzID0gdjJULm1fbmVpZ2hib3JzO1xuICAgICAgICB0cmlhbmdsZXMgPSBpZnMuR2V0Q29vcmRJbmRleCgpO1xuICAgICAgICBzaXplID0gbnVtSW50QXJyYXkgKiBkaW1JbnRBcnJheTtcbiAgICAgICAgc3RhcnQgPSBpdGVyYXRvci5tX2NvdW50O1xuICAgICAgICBzdHJlYW1TaXplID0gYnN0cmVhbS5SZWFkVUludDMyKGl0ZXJhdG9yLCBzdHJlYW1UeXBlKTsgICAgICAgIC8vIGJpdHNyZWFtIHNpemVcbiAgICAgICAgbWFzayA9IGJzdHJlYW0uUmVhZFVDaGFyKGl0ZXJhdG9yLCBzdHJlYW1UeXBlKTtcbiAgICAgICAgYmluYXJpemF0aW9uID0gKG1hc2sgPj4+IDQpICYgNztcbiAgICAgICAgcHJlZE1vZGUubV92YWx1ZSA9IG1hc2sgJiA3O1xuICAgICAgICBzdHJlYW1TaXplIC09IChpdGVyYXRvci5tX2NvdW50IC0gc3RhcnQpO1xuICAgICAgICBpdGVyYXRvclByZWQgPSBuZXcgbW9kdWxlLkl0ZXJhdG9yKCk7XG4gICAgICAgIGl0ZXJhdG9yUHJlZC5tX2NvdW50ID0gaXRlcmF0b3IubV9jb3VudCArIHN0cmVhbVNpemU7XG4gICAgICAgIGlkID0gbmV3IG1vZHVsZS5TQzNETUNUcmlwbGV0KC0xLCAtMSwgLTEpO1xuICAgICAgICBpZiAoYmluYXJpemF0aW9uICE9PSBsb2NhbC5PM0RHQ19TQzNETUNfQklOQVJJWkFUSU9OX0FTQ0lJKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX0VSUk9SX0NPUlJVUFRFRF9TVFJFQU07XG4gICAgICAgIH1cbiAgICAgICAgYnN0cmVhbS5SZWFkVUludDMyKGl0ZXJhdG9yUHJlZCwgc3RyZWFtVHlwZSk7ICAgICAgICAvLyBwcmVkaWN0b3JzIGJpdHNyZWFtIHNpemVcbiAgICAgICAgbmVpZ2hib3JzID0gdGhpcy5tX25laWdoYm9ycztcbiAgICAgICAgbm9ybWFscyA9IHRoaXMubV9ub3JtYWxzO1xuICAgICAgICBuUHJlZCA9IG5ldyBtb2R1bGUuTnVtYmVyUmVmKCk7XG4gICAgICAgIHRlc3RQcmVkRW5hYmxlZCA9IHByZWRNb2RlLm1fdmFsdWUgIT09IGxvY2FsLk8zREdDX1NDM0RNQ19OT19QUkVESUNUSU9OO1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgbnVtSW50QXJyYXk7ICsrdikge1xuICAgICAgICAgICAgblByZWQubV92YWx1ZSA9IDA7XG4gICAgICAgICAgICBpZiAodjJULkdldE51bU5laWdoYm9ycyh2KSA+IDAgJiYgdGVzdFByZWRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdV9iZWdpbiA9IHYyVC5CZWdpbih2KTtcbiAgICAgICAgICAgICAgICB1X2VuZCA9IHYyVC5FbmQodik7XG4gICAgICAgICAgICAgICAgZm9yICh1ID0gdV9iZWdpbjsgdSA8IHVfZW5kOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGEgPSB2MlROZWlnaGJvcnNbdV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIERlbHRhUHJlZGljdG9ycyh0cmlhbmdsZXMsIHRhLCB2LCBuUHJlZCwgbmVpZ2hib3JzLCBkaW1JbnRBcnJheSwgaW50QXJyYXksIHN0cmlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5QcmVkLm1fdmFsdWUgPiAxKSB7XG4gICAgICAgICAgICAgICAgYmVzdFByZWQgPSBic3RyZWFtLlJlYWRVQ2hhckFTQ0lJKGl0ZXJhdG9yUHJlZCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpbUludEFycmF5OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZFJlc2lkdWFsID0gYnN0cmVhbS5SZWFkSW50QVNDSUkoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpbnRBcnJheVt2ICogc3RyaWRlICsgaV0gPSBwcmVkUmVzaWR1YWwgKyBuZWlnaGJvcnNbYmVzdFByZWRdLm1fcHJlZFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgPiAwICYmIHByZWRNb2RlLm1fdmFsdWUgIT09IGxvY2FsLk8zREdDX1NDM0RNQ19OT19QUkVESUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpbUludEFycmF5OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZFJlc2lkdWFsID0gYnN0cmVhbS5SZWFkSW50QVNDSUkoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpbnRBcnJheVt2ICogc3RyaWRlICsgaV0gPSBwcmVkUmVzaWR1YWwgKyBpbnRBcnJheVsodiAtIDEpICogc3RyaWRlICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltSW50QXJyYXk7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVkUmVzaWR1YWwgPSBic3RyZWFtLlJlYWRVSW50QVNDSUkoaXRlcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpbnRBcnJheVt2ICogc3RyaWRlICsgaV0gPSBwcmVkUmVzaWR1YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yLm1fY291bnQgPSBpdGVyYXRvclByZWQubV9jb3VudDtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVJbnRBcnJheSA9IGZ1bmN0aW9uIChpbnRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtSW50QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbUludEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZE1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJzdHJlYW0pIHtcbiAgICAgICAgaWYgKHRoaXMubV9zdHJlYW1UeXBlID09PSBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9BU0NJSSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGVjb2RlSW50QXJyYXlBU0NJSShpbnRBcnJheSwgbnVtSW50QXJyYXksIGRpbUludEFycmF5LCBzdHJpZGUsIGlmcywgcHJlZE1vZGUsIGJzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLkRlY29kZUludEFycmF5QmluYXJ5KGludEFycmF5LCBudW1JbnRBcnJheSwgZGltSW50QXJyYXksIHN0cmlkZSwgaWZzLCBwcmVkTW9kZSwgYnN0cmVhbSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBDb21wdXRlTm9ybWFscyh0cmlhbmdsZXMsIG50cmlzLCBjb29yZHMsIG52ZXJ0LCBub3JtYWxzKSB7XG4gICAgICAgIHZhciB0MywgdiwgbiwgdCwgYSwgYiwgYywgZDEsIGQyLCBuMDtcbiAgICAgICAgbjAgPSBuZXcgbW9kdWxlLlZlYzMoKTtcbiAgICAgICAgZDEgPSBuZXcgbW9kdWxlLlZlYzMoKTtcbiAgICAgICAgZDIgPSBuZXcgbW9kdWxlLlZlYzMoKTtcbiAgICAgICAgbiA9IG52ZXJ0ICogMztcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IG47ICsrdikge1xuICAgICAgICAgICAgbm9ybWFsc1t2XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh0ID0gMDsgdCA8IG50cmlzOyArK3QpIHtcbiAgICAgICAgICAgIHQzID0gdCAqIDM7XG4gICAgICAgICAgICBhID0gdHJpYW5nbGVzW3QzXSAqIDM7XG4gICAgICAgICAgICBiID0gdHJpYW5nbGVzW3QzICsgMV0gKiAzO1xuICAgICAgICAgICAgYyA9IHRyaWFuZ2xlc1t0MyArIDJdICogMztcbiAgICAgICAgICAgIGQxLm1feCA9IGNvb3Jkc1tiXSAtIGNvb3Jkc1thXTtcbiAgICAgICAgICAgIGQxLm1feSA9IGNvb3Jkc1tiICsgMV0gLSBjb29yZHNbYSArIDFdO1xuICAgICAgICAgICAgZDEubV96ID0gY29vcmRzW2IgKyAyXSAtIGNvb3Jkc1thICsgMl07XG4gICAgICAgICAgICBkMi5tX3ggPSBjb29yZHNbY10gLSBjb29yZHNbYV07XG4gICAgICAgICAgICBkMi5tX3kgPSBjb29yZHNbYyArIDFdIC0gY29vcmRzW2EgKyAxXTtcbiAgICAgICAgICAgIGQyLm1feiA9IGNvb3Jkc1tjICsgMl0gLSBjb29yZHNbYSArIDJdO1xuICAgICAgICAgICAgbjAubV94ID0gZDEubV95ICogZDIubV96IC0gZDEubV96ICogZDIubV95O1xuICAgICAgICAgICAgbjAubV95ID0gZDEubV96ICogZDIubV94IC0gZDEubV94ICogZDIubV96O1xuICAgICAgICAgICAgbjAubV96ID0gZDEubV94ICogZDIubV95IC0gZDEubV95ICogZDIubV94O1xuICAgICAgICAgICAgbm9ybWFsc1thXSArPSBuMC5tX3g7XG4gICAgICAgICAgICBub3JtYWxzW2EgKyAxXSArPSBuMC5tX3k7XG4gICAgICAgICAgICBub3JtYWxzW2EgKyAyXSArPSBuMC5tX3o7XG4gICAgICAgICAgICBub3JtYWxzW2JdICs9IG4wLm1feDtcbiAgICAgICAgICAgIG5vcm1hbHNbYiArIDFdICs9IG4wLm1feTtcbiAgICAgICAgICAgIG5vcm1hbHNbYiArIDJdICs9IG4wLm1fejtcbiAgICAgICAgICAgIG5vcm1hbHNbY10gKz0gbjAubV94O1xuICAgICAgICAgICAgbm9ybWFsc1tjICsgMV0gKz0gbjAubV95O1xuICAgICAgICAgICAgbm9ybWFsc1tjICsgMl0gKz0gbjAubV96O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5Qcm9jZXNzTm9ybWFscyA9IGZ1bmN0aW9uIChpZnMpIHtcbiAgICAgICAgdmFyIHYzLCB2MiwgbnZlcnQsIG5vcm1hbFNpemUsIG5vcm1hbHMsIHF1YW50RmxvYXRBcnJheSwgb3JpZW50YXRpb24sIHRyaWFuZ2xlcywgbjAsIG4xLCB2LCBybmEwLCBybmIwLCBuaTEsIG5vcm0wO1xuICAgICAgICBudmVydCA9IGlmcy5HZXROTm9ybWFsKCk7XG5cbiAgICAgICAgbm9ybWFsU2l6ZSA9IGlmcy5HZXROTm9ybWFsKCkgKiAzO1xuICAgICAgICBpZiAodGhpcy5tX25vcm1hbHNTaXplIDwgbm9ybWFsU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5tX25vcm1hbHNTaXplID0gbm9ybWFsU2l6ZTtcbiAgICAgICAgICAgIHRoaXMubV9ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm1fbm9ybWFsc1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbHMgPSB0aGlzLm1fbm9ybWFscztcbiAgICAgICAgcXVhbnRGbG9hdEFycmF5ID0gdGhpcy5tX3F1YW50RmxvYXRBcnJheTtcbiAgICAgICAgb3JpZW50YXRpb24gPSB0aGlzLm1fb3JpZW50YXRpb247XG4gICAgICAgIHRyaWFuZ2xlcyA9IGlmcy5HZXRDb29yZEluZGV4KCk7XG4gICAgICAgIENvbXB1dGVOb3JtYWxzKHRyaWFuZ2xlcywgaWZzLkdldE5Db29yZEluZGV4KCksIHF1YW50RmxvYXRBcnJheSwgbnZlcnQsIG5vcm1hbHMpO1xuICAgICAgICBuMCA9IG5ldyBtb2R1bGUuVmVjMygpO1xuICAgICAgICBuMSA9IG5ldyBtb2R1bGUuVmVjMygpO1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgbnZlcnQ7ICsrdikge1xuICAgICAgICAgICAgdjMgPSAzICogdjtcbiAgICAgICAgICAgIG4wLm1feCA9IG5vcm1hbHNbdjNdO1xuICAgICAgICAgICAgbjAubV95ID0gbm9ybWFsc1t2MyArIDFdO1xuICAgICAgICAgICAgbjAubV96ID0gbm9ybWFsc1t2MyArIDJdO1xuICAgICAgICAgICAgbm9ybTAgPSBNYXRoLnNxcnQobjAubV94ICogbjAubV94ICsgbjAubV95ICogbjAubV95ICsgbjAubV96ICogbjAubV96KTtcbiAgICAgICAgICAgIGlmIChub3JtMCA9PT0gMC4wKSB7XG4gICAgICAgICAgICAgICAgbm9ybTAgPSAxLjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTcGhlcmVUb0N1YmUobjAsIG4xKTtcbiAgICAgICAgICAgIHJuYTAgPSBuMS5tX3ggLyBub3JtMDtcbiAgICAgICAgICAgIHJuYjAgPSBuMS5tX3kgLyBub3JtMDtcbiAgICAgICAgICAgIG5pMSA9IG4xLm1feiArIG9yaWVudGF0aW9uW3ZdO1xuICAgICAgICAgICAgb3JpZW50YXRpb25bdl0gPSBuaTE7XG4gICAgICAgICAgICBpZiAoKG5pMSA+Pj4gMSkgIT09IChuMS5tX3ogPj4+IDEpKSB7XG4gICAgICAgICAgICAgICAgcm5hMCA9IDAuMDtcbiAgICAgICAgICAgICAgICBybmIwID0gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdjIgPSB2ICogMjtcbiAgICAgICAgICAgIG5vcm1hbHNbdjJdID0gcm5hMDtcbiAgICAgICAgICAgIG5vcm1hbHNbdjIgKyAxXSA9IHJuYjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5JUXVhbnRpemUgPSBmdW5jdGlvbiAoZmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1GbG9hdEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluRmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuUUJpdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkTW9kZSkge1xuICAgICAgICB2YXIgdiwgbmluLCBub3V0LCBvcmllbnRhdGlvbiwgbm9ybWFscywgQ3ViZVRvU3BoZXJlO1xuICAgICAgICBpZiAocHJlZE1vZGUubV92YWx1ZSA9PT0gbG9jYWwuTzNER0NfU0MzRE1DX1NVUkZfTk9STUFMU19QUkVESUNUSU9OKSB7XG4gICAgICAgICAgICBDdWJlVG9TcGhlcmUgPSBsb2NhbC5DdWJlVG9TcGhlcmU7XG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9IHRoaXMubV9vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIG5vcm1hbHMgPSB0aGlzLm1fbm9ybWFscztcbiAgICAgICAgICAgIG5pbiA9IG5ldyBtb2R1bGUuVmVjMygwLCAwLCAwKTtcbiAgICAgICAgICAgIG5vdXQgPSBuZXcgbW9kdWxlLlZlYzMoMCwgMCwgMCk7XG4gICAgICAgICAgICB0aGlzLklRdWFudGl6ZUZsb2F0QXJyYXkoZmxvYXRBcnJheSwgbnVtRmxvYXRBcnJheSwgZGltRmxvYXRBcnJheSwgc3RyaWRlLCB0aGlzLm1fbWluTm9ybWFsLCB0aGlzLm1fbWF4Tm9ybWFsLCBuUUJpdHMgKyAxKTtcbiAgICAgICAgICAgIGZvciAodiA9IDA7IHYgPCBudW1GbG9hdEFycmF5OyArK3YpIHtcbiAgICAgICAgICAgICAgICBuaW4ubV94ID0gZmxvYXRBcnJheVtzdHJpZGUgKiB2XSArIG5vcm1hbHNbMiAqIHZdO1xuICAgICAgICAgICAgICAgIG5pbi5tX3kgPSBmbG9hdEFycmF5W3N0cmlkZSAqIHYgKyAxXSArIG5vcm1hbHNbMiAqIHYgKyAxXTtcbiAgICAgICAgICAgICAgICBuaW4ubV96ID0gb3JpZW50YXRpb25bdl07XG4gICAgICAgICAgICAgICAgQ3ViZVRvU3BoZXJlW25pbi5tX3pdKG5pbiwgbm91dCk7XG4gICAgICAgICAgICAgICAgZmxvYXRBcnJheVtzdHJpZGUgKiB2XSA9IG5vdXQubV94O1xuICAgICAgICAgICAgICAgIGZsb2F0QXJyYXlbc3RyaWRlICogdiArIDFdID0gbm91dC5tX3k7XG4gICAgICAgICAgICAgICAgZmxvYXRBcnJheVtzdHJpZGUgKiB2ICsgMl0gPSBub3V0Lm1fejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuSVF1YW50aXplRmxvYXRBcnJheShmbG9hdEFycmF5LCBudW1GbG9hdEFycmF5LCBkaW1GbG9hdEFycmF5LCBzdHJpZGUsIG1pbkZsb2F0QXJyYXksIG1heEZsb2F0QXJyYXksIG5RQml0cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVGbG9hdEFycmF5QmluYXJ5ID0gZnVuY3Rpb24gKGZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtRmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1GbG9hdEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5GbG9hdEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgblFCaXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBic3RyZWFtKSB7XG4gICAgICAgIHZhciBtYXhOUHJlZCwgdGVzdFByZWRFbmFibGVkLCB0ZXN0UGFyYVByZWRFbmFibGVkLCBiZXN0UHJlZCwgZE1vZGVsLCBidWZmZXIsIHF1YW50RmxvYXRBcnJheSwgbmVpZ2hib3JzLCBub3JtYWxzLCBuUHJlZCwgdGEsIGksIHYsIHUsIHVfYmVnaW4sIHVfZW5kLCBpdGVyYXRvciwgb3JpZW50YXRpb24sIHN0cmVhbVR5cGUsIHByZWRSZXNpZHVhbCwgYWNkLCBiTW9kZWwwLCBiTW9kZWwxLCBtTW9kZWxQcmVkcywgdjJULCB2MlROZWlnaGJvcnMsIHRyaWFuZ2xlcywgc2l6ZSwgc3RhcnQsIHN0cmVhbVNpemUsIG1hc2ssIGJpbmFyaXphdGlvbiwgaXRlcmF0b3JQcmVkLCBleHBfaywgTSwgbU1vZGVsVmFsdWVzO1xuICAgICAgICBpdGVyYXRvciA9IHRoaXMubV9pdGVyYXRvcjtcbiAgICAgICAgb3JpZW50YXRpb24gPSB0aGlzLm1fb3JpZW50YXRpb247XG4gICAgICAgIHN0cmVhbVR5cGUgPSB0aGlzLm1fc3RyZWFtVHlwZTtcbiAgICAgICAgYWNkID0gbmV3IG1vZHVsZS5Bcml0aG1ldGljRGVjb2RlcigpO1xuICAgICAgICBiTW9kZWwwID0gbmV3IG1vZHVsZS5TdGF0aWNCaXRNb2RlbCgpO1xuICAgICAgICBiTW9kZWwxID0gbmV3IG1vZHVsZS5BZGFwdGl2ZUJpdE1vZGVsKCk7XG4gICAgICAgIG1Nb2RlbFByZWRzID0gbmV3IG1vZHVsZS5BZGFwdGl2ZURhdGFNb2RlbCgpO1xuICAgICAgICBtYXhOUHJlZCA9IGxvY2FsLk8zREdDX1NDM0RNQ19NQVhfUFJFRElDVElPTl9ORUlHSEJPUlM7XG4gICAgICAgIG1Nb2RlbFByZWRzLlNldEFscGhhYmV0KG1heE5QcmVkICsgMSk7XG4gICAgICAgIHYyVCA9IHRoaXMubV90cmlhbmdsZUxpc3REZWNvZGVyLkdldFZlcnRleFRvVHJpYW5nbGUoKTtcbiAgICAgICAgdjJUTmVpZ2hib3JzID0gdjJULm1fbmVpZ2hib3JzO1xuICAgICAgICB0cmlhbmdsZXMgPSBpZnMuR2V0Q29vcmRJbmRleCgpO1xuICAgICAgICBzaXplID0gbnVtRmxvYXRBcnJheSAqIGRpbUZsb2F0QXJyYXk7XG4gICAgICAgIHN0YXJ0ID0gaXRlcmF0b3IubV9jb3VudDtcbiAgICAgICAgc3RyZWFtU2l6ZSA9IGJzdHJlYW0uUmVhZFVJbnQzMihpdGVyYXRvciwgc3RyZWFtVHlwZSk7XG4gICAgICAgIG1hc2sgPSBic3RyZWFtLlJlYWRVQ2hhcihpdGVyYXRvciwgc3RyZWFtVHlwZSk7XG4gICAgICAgIGJpbmFyaXphdGlvbiA9IChtYXNrID4+PiA0KSAmIDc7XG4gICAgICAgIHByZWRNb2RlLm1fdmFsdWUgPSBtYXNrICYgNztcbiAgICAgICAgc3RyZWFtU2l6ZSAtPSAoaXRlcmF0b3IubV9jb3VudCAtIHN0YXJ0KTtcbiAgICAgICAgaXRlcmF0b3JQcmVkID0gbmV3IG1vZHVsZS5JdGVyYXRvcigpO1xuICAgICAgICBpdGVyYXRvclByZWQubV9jb3VudCA9IGl0ZXJhdG9yLm1fY291bnQgKyBzdHJlYW1TaXplO1xuICAgICAgICBleHBfayA9IDA7XG4gICAgICAgIE0gPSAwO1xuICAgICAgICBpZiAoYmluYXJpemF0aW9uICE9PSBsb2NhbC5PM0RHQ19TQzNETUNfQklOQVJJWkFUSU9OX0FDX0VHQykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19FUlJPUl9DT1JSVVBURURfU1RSRUFNO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciA9IGJzdHJlYW0uR2V0QnVmZmVyKGl0ZXJhdG9yLCBzdHJlYW1TaXplKTtcbiAgICAgICAgaXRlcmF0b3IubV9jb3VudCArPSBzdHJlYW1TaXplO1xuICAgICAgICBhY2QuU2V0QnVmZmVyKHN0cmVhbVNpemUsIGJ1ZmZlcik7XG4gICAgICAgIGFjZC5TdGFydERlY29kZXIoKTtcbiAgICAgICAgZXhwX2sgPSBhY2QuRXhwR29sb21iRGVjb2RlKDAsIGJNb2RlbDAsIGJNb2RlbDEpO1xuICAgICAgICBNID0gYWNkLkV4cEdvbG9tYkRlY29kZSgwLCBiTW9kZWwwLCBiTW9kZWwxKTtcbiAgICAgICAgbU1vZGVsVmFsdWVzID0gbmV3IG1vZHVsZS5BZGFwdGl2ZURhdGFNb2RlbCgpO1xuICAgICAgICBtTW9kZWxWYWx1ZXMuU2V0QWxwaGFiZXQoTSArIDIpO1xuICAgICAgICBpZiAocHJlZE1vZGUubV92YWx1ZSA9PT0gbG9jYWwuTzNER0NfU0MzRE1DX1NVUkZfTk9STUFMU19QUkVESUNUSU9OKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tX29yaWVudGF0aW9uU2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1fb3JpZW50YXRpb25TaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1fb3JpZW50YXRpb24gPSBuZXcgSW50OEFycmF5KHRoaXMubV9vcmllbnRhdGlvblNpemUpO1xuICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uID0gdGhpcy5tX29yaWVudGF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZE1vZGVsID0gbmV3IG1vZHVsZS5BZGFwdGl2ZURhdGFNb2RlbCgpO1xuICAgICAgICAgICAgZE1vZGVsLlNldEFscGhhYmV0KDEyKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1GbG9hdEFycmF5OyArK2kpIHtcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbltpXSA9IFVJbnRUb0ludChhY2QuRGVjb2RlQWRhcHRpdmVEYXRhTW9kZWwoZE1vZGVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlByb2Nlc3NOb3JtYWxzKGlmcyk7XG4gICAgICAgICAgICBkaW1GbG9hdEFycmF5ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tX3F1YW50RmxvYXRBcnJheVNpemUgPCBzaXplKSB7XG4gICAgICAgICAgICB0aGlzLm1fcXVhbnRGbG9hdEFycmF5U2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB0aGlzLm1fcXVhbnRGbG9hdEFycmF5ID0gbmV3IEludDMyQXJyYXkodGhpcy5tX3F1YW50RmxvYXRBcnJheVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHF1YW50RmxvYXRBcnJheSA9IHRoaXMubV9xdWFudEZsb2F0QXJyYXk7XG4gICAgICAgIG5laWdoYm9ycyA9IHRoaXMubV9uZWlnaGJvcnM7XG4gICAgICAgIG5vcm1hbHMgPSB0aGlzLm1fbm9ybWFscztcbiAgICAgICAgblByZWQgPSBuZXcgbW9kdWxlLk51bWJlclJlZigpO1xuICAgICAgICB0ZXN0UHJlZEVuYWJsZWQgPSBwcmVkTW9kZS5tX3ZhbHVlICE9PSBsb2NhbC5PM0RHQ19TQzNETUNfTk9fUFJFRElDVElPTjtcbiAgICAgICAgdGVzdFBhcmFQcmVkRW5hYmxlZCA9IHByZWRNb2RlLm1fdmFsdWUgPT09IGxvY2FsLk8zREdDX1NDM0RNQ19QQVJBTExFTE9HUkFNX1BSRURJQ1RJT047XG4gICAgICAgIGZvciAodiA9IDA7IHYgPCBudW1GbG9hdEFycmF5OyArK3YpIHtcbiAgICAgICAgICAgIG5QcmVkLm1fdmFsdWUgPSAwO1xuICAgICAgICAgICAgaWYgKHYyVC5HZXROdW1OZWlnaGJvcnModikgPiAwICYmIHRlc3RQcmVkRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHVfYmVnaW4gPSB2MlQuQmVnaW4odik7XG4gICAgICAgICAgICAgICAgdV9lbmQgPSB2MlQuRW5kKHYpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0UGFyYVByZWRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodSA9IHVfYmVnaW47IHUgPCB1X2VuZDsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YSA9IHYyVE5laWdoYm9yc1t1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFBhcmFsbGVsb2dyYW1QcmVkaWN0b3JzKHRyaWFuZ2xlcywgdGEsIHYsIG5QcmVkLCBuZWlnaGJvcnMsIGRpbUZsb2F0QXJyYXksIHF1YW50RmxvYXRBcnJheSwgc3RyaWRlLCB2MlQsIHYyVE5laWdoYm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5QcmVkLm1fdmFsdWUgPCBtYXhOUHJlZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHUgPSB1X2JlZ2luOyB1IDwgdV9lbmQ7ICsrdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGEgPSB2MlROZWlnaGJvcnNbdV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBEZWx0YVByZWRpY3RvcnModHJpYW5nbGVzLCB0YSwgdiwgblByZWQsIG5laWdoYm9ycywgZGltRmxvYXRBcnJheSwgcXVhbnRGbG9hdEFycmF5LCBzdHJpZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5QcmVkLm1fdmFsdWUgPiAxKSB7XG4gICAgICAgICAgICAgICAgYmVzdFByZWQgPSBhY2QuRGVjb2RlQWRhcHRpdmVEYXRhTW9kZWwobU1vZGVsUHJlZHMpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkaW1GbG9hdEFycmF5OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZFJlc2lkdWFsID0gYWNkLkRlY29kZUludEFDRUdDKG1Nb2RlbFZhbHVlcywgYk1vZGVsMCwgYk1vZGVsMSwgZXhwX2ssIE0pO1xuICAgICAgICAgICAgICAgICAgICBxdWFudEZsb2F0QXJyYXlbdiAqIHN0cmlkZSArIGldID0gcHJlZFJlc2lkdWFsICsgbmVpZ2hib3JzW2Jlc3RQcmVkXS5tX3ByZWRbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2ID4gMCAmJiB0ZXN0UHJlZEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltRmxvYXRBcnJheTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWRSZXNpZHVhbCA9IGFjZC5EZWNvZGVJbnRBQ0VHQyhtTW9kZWxWYWx1ZXMsIGJNb2RlbDAsIGJNb2RlbDEsIGV4cF9rLCBNKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRGbG9hdEFycmF5W3YgKiBzdHJpZGUgKyBpXSA9IHByZWRSZXNpZHVhbCArIHF1YW50RmxvYXRBcnJheVsodiAtIDEpICogc3RyaWRlICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltRmxvYXRBcnJheTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWRSZXNpZHVhbCA9IGFjZC5EZWNvZGVVSW50QUNFR0MobU1vZGVsVmFsdWVzLCBiTW9kZWwwLCBiTW9kZWwxLCBleHBfaywgTSk7XG4gICAgICAgICAgICAgICAgICAgIHF1YW50RmxvYXRBcnJheVt2ICogc3RyaWRlICsgaV0gPSBwcmVkUmVzaWR1YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yLm1fY291bnQgPSBpdGVyYXRvclByZWQubV9jb3VudDtcbiAgICAgICAgdGhpcy5JUXVhbnRpemUoZmxvYXRBcnJheSwgbnVtRmxvYXRBcnJheSwgZGltRmxvYXRBcnJheSwgc3RyaWRlLCBtaW5GbG9hdEFycmF5LCBtYXhGbG9hdEFycmF5LCBuUUJpdHMsIHByZWRNb2RlKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVGbG9hdEFycmF5QVNDSUkgPSBmdW5jdGlvbiAoZmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1GbG9hdEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluRmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuUUJpdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJzdHJlYW0pIHtcbiAgICAgICAgdmFyIG1heE5QcmVkLCB0ZXN0UHJlZEVuYWJsZWQsIHRlc3RQYXJhUHJlZEVuYWJsZWQsIGl0ZXJhdG9yLCBvcmllbnRhdGlvbiwgc3RyZWFtVHlwZSwgcHJlZFJlc2lkdWFsLCB2MlQsIHYyVE5laWdoYm9ycywgdHJpYW5nbGVzLCBzaXplLCBzdGFydCwgc3RyZWFtU2l6ZSwgbWFzaywgYmluYXJpemF0aW9uLCBpdGVyYXRvclByZWQsIHF1YW50RmxvYXRBcnJheSwgbmVpZ2hib3JzLCBub3JtYWxzLCBuUHJlZCwgdiwgdSwgdV9iZWdpbiwgdV9lbmQsIHRhLCBpLCBiZXN0UHJlZDtcbiAgICAgICAgbWF4TlByZWQgPSBsb2NhbC5PM0RHQ19TQzNETUNfTUFYX1BSRURJQ1RJT05fTkVJR0hCT1JTO1xuICAgICAgICBpdGVyYXRvciA9IHRoaXMubV9pdGVyYXRvcjtcbiAgICAgICAgb3JpZW50YXRpb24gPSB0aGlzLm1fb3JpZW50YXRpb247XG4gICAgICAgIHN0cmVhbVR5cGUgPSB0aGlzLm1fc3RyZWFtVHlwZTtcbiAgICAgICAgdjJUID0gdGhpcy5tX3RyaWFuZ2xlTGlzdERlY29kZXIuR2V0VmVydGV4VG9UcmlhbmdsZSgpO1xuICAgICAgICB2MlROZWlnaGJvcnMgPSB2MlQubV9uZWlnaGJvcnM7XG4gICAgICAgIHRyaWFuZ2xlcyA9IGlmcy5HZXRDb29yZEluZGV4KCk7XG4gICAgICAgIHNpemUgPSBudW1GbG9hdEFycmF5ICogZGltRmxvYXRBcnJheTtcbiAgICAgICAgc3RhcnQgPSBpdGVyYXRvci5tX2NvdW50O1xuICAgICAgICBzdHJlYW1TaXplID0gYnN0cmVhbS5SZWFkVUludDMyKGl0ZXJhdG9yLCBzdHJlYW1UeXBlKTtcbiAgICAgICAgbWFzayA9IGJzdHJlYW0uUmVhZFVDaGFyKGl0ZXJhdG9yLCBzdHJlYW1UeXBlKTtcbiAgICAgICAgYmluYXJpemF0aW9uID0gKG1hc2sgPj4+IDQpICYgNztcbiAgICAgICAgcHJlZE1vZGUubV92YWx1ZSA9IG1hc2sgJiA3O1xuICAgICAgICBzdHJlYW1TaXplIC09IChpdGVyYXRvci5tX2NvdW50IC0gc3RhcnQpO1xuICAgICAgICBpdGVyYXRvclByZWQgPSBuZXcgbW9kdWxlLkl0ZXJhdG9yKCk7XG4gICAgICAgIGl0ZXJhdG9yUHJlZC5tX2NvdW50ID0gaXRlcmF0b3IubV9jb3VudCArIHN0cmVhbVNpemU7XG4gICAgICAgIGlmIChiaW5hcml6YXRpb24gIT09IGxvY2FsLk8zREdDX1NDM0RNQ19CSU5BUklaQVRJT05fQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfRVJST1JfQ09SUlVQVEVEX1NUUkVBTTtcbiAgICAgICAgfVxuICAgICAgICBic3RyZWFtLlJlYWRVSW50MzIoaXRlcmF0b3JQcmVkLCBzdHJlYW1UeXBlKTtcbiAgICAgICAgaWYgKHByZWRNb2RlLm1fdmFsdWUgPT09IGxvY2FsLk8zREdDX1NDM0RNQ19TVVJGX05PUk1BTFNfUFJFRElDVElPTikge1xuICAgICAgICAgICAgaWYgKHRoaXMubV9vcmllbnRhdGlvblNpemUgPCBudW1GbG9hdEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tX29yaWVudGF0aW9uU2l6ZSA9IG51bUZsb2F0QXJyYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX29yaWVudGF0aW9uID0gbmV3IEludDhBcnJheSh0aGlzLm1fb3JpZW50YXRpb25TaXplKTtcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IHRoaXMubV9vcmllbnRhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1GbG9hdEFycmF5OyArK2kpIHtcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbltpXSA9IGJzdHJlYW0uUmVhZEludEFTQ0lJKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuUHJvY2Vzc05vcm1hbHMoaWZzKTtcbiAgICAgICAgICAgIGRpbUZsb2F0QXJyYXkgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1fcXVhbnRGbG9hdEFycmF5U2l6ZSA8IHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubV9xdWFudEZsb2F0QXJyYXlTaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMubV9xdWFudEZsb2F0QXJyYXkgPSBuZXcgSW50MzJBcnJheSh0aGlzLm1fcXVhbnRGbG9hdEFycmF5U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcXVhbnRGbG9hdEFycmF5ID0gdGhpcy5tX3F1YW50RmxvYXRBcnJheTtcbiAgICAgICAgbmVpZ2hib3JzID0gdGhpcy5tX25laWdoYm9ycztcbiAgICAgICAgbm9ybWFscyA9IHRoaXMubV9ub3JtYWxzO1xuICAgICAgICBuUHJlZCA9IG5ldyBtb2R1bGUuTnVtYmVyUmVmKCk7XG4gICAgICAgIHRlc3RQcmVkRW5hYmxlZCA9IHByZWRNb2RlLm1fdmFsdWUgIT09IGxvY2FsLk8zREdDX1NDM0RNQ19OT19QUkVESUNUSU9OO1xuICAgICAgICB0ZXN0UGFyYVByZWRFbmFibGVkID0gcHJlZE1vZGUubV92YWx1ZSA9PT0gbG9jYWwuTzNER0NfU0MzRE1DX1BBUkFMTEVMT0dSQU1fUFJFRElDVElPTjtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IG51bUZsb2F0QXJyYXk7ICsrdikge1xuICAgICAgICAgICAgblByZWQubV92YWx1ZSA9IDA7XG4gICAgICAgICAgICBpZiAodjJULkdldE51bU5laWdoYm9ycyh2KSA+IDAgJiYgdGVzdFByZWRFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdV9iZWdpbiA9IHYyVC5CZWdpbih2KTtcbiAgICAgICAgICAgICAgICB1X2VuZCA9IHYyVC5FbmQodik7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RQYXJhUHJlZEVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh1ID0gdV9iZWdpbjsgdSA8IHVfZW5kOyArK3UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhID0gdjJUTmVpZ2hib3JzW3VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgUGFyYWxsZWxvZ3JhbVByZWRpY3RvcnModHJpYW5nbGVzLCB0YSwgdiwgblByZWQsIG5laWdoYm9ycywgZGltRmxvYXRBcnJheSwgcXVhbnRGbG9hdEFycmF5LCBzdHJpZGUsIHYyVCwgdjJUTmVpZ2hib3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoblByZWQubV92YWx1ZSA8IG1heE5QcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodSA9IHVfYmVnaW47IHUgPCB1X2VuZDsgKyt1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YSA9IHYyVE5laWdoYm9yc1t1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIERlbHRhUHJlZGljdG9ycyh0cmlhbmdsZXMsIHRhLCB2LCBuUHJlZCwgbmVpZ2hib3JzLCBkaW1GbG9hdEFycmF5LCBxdWFudEZsb2F0QXJyYXksIHN0cmlkZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoblByZWQubV92YWx1ZSA+IDEpIHtcbiAgICAgICAgICAgICAgICBiZXN0UHJlZCA9IGJzdHJlYW0uUmVhZFVDaGFyQVNDSUkoaXRlcmF0b3JQcmVkKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltRmxvYXRBcnJheTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWRSZXNpZHVhbCA9IGJzdHJlYW0uUmVhZEludEFTQ0lJKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRGbG9hdEFycmF5W3YgKiBzdHJpZGUgKyBpXSA9IHByZWRSZXNpZHVhbCArIG5laWdoYm9yc1tiZXN0UHJlZF0ubV9wcmVkW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiA+IDAgJiYgcHJlZE1vZGUubV92YWx1ZSAhPT0gbG9jYWwuTzNER0NfU0MzRE1DX05PX1BSRURJQ1RJT04pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltRmxvYXRBcnJheTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWRSZXNpZHVhbCA9IGJzdHJlYW0uUmVhZEludEFTQ0lJKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRGbG9hdEFycmF5W3YgKiBzdHJpZGUgKyBpXSA9IHByZWRSZXNpZHVhbCArIHF1YW50RmxvYXRBcnJheVsodiAtIDEpICogc3RyaWRlICsgaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGltRmxvYXRBcnJheTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWRSZXNpZHVhbCA9IGJzdHJlYW0uUmVhZFVJbnRBU0NJSShpdGVyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHF1YW50RmxvYXRBcnJheVt2ICogc3RyaWRlICsgaV0gPSBwcmVkUmVzaWR1YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdG9yLm1fY291bnQgPSBpdGVyYXRvclByZWQubV9jb3VudDtcbiAgICAgICAgdGhpcy5JUXVhbnRpemUoZmxvYXRBcnJheSwgbnVtRmxvYXRBcnJheSwgZGltRmxvYXRBcnJheSwgc3RyaWRlLCBtaW5GbG9hdEFycmF5LCBtYXhGbG9hdEFycmF5LCBuUUJpdHMsIHByZWRNb2RlKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5TQzNETUNEZWNvZGVyLnByb3RvdHlwZS5EZWNvZGVGbG9hdEFycmF5ID0gZnVuY3Rpb24gKGZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtRmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1GbG9hdEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5GbG9hdEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgblFCaXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBic3RyZWFtKSB7XG4gICAgICAgIGlmICh0aGlzLm1fc3RyZWFtVHlwZSA9PT0gbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY29kZUZsb2F0QXJyYXlBU0NJSShmbG9hdEFycmF5LCBudW1GbG9hdEFycmF5LCBkaW1GbG9hdEFycmF5LCBzdHJpZGUsIG1pbkZsb2F0QXJyYXksIG1heEZsb2F0QXJyYXksIG5RQml0cywgaWZzLCBwcmVkTW9kZSwgYnN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuRGVjb2RlRmxvYXRBcnJheUJpbmFyeShmbG9hdEFycmF5LCBudW1GbG9hdEFycmF5LCBkaW1GbG9hdEFycmF5LCBzdHJpZGUsIG1pbkZsb2F0QXJyYXksIG1heEZsb2F0QXJyYXksIG5RQml0cywgaWZzLCBwcmVkTW9kZSwgYnN0cmVhbSk7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRGVjb2Rlci5wcm90b3R5cGUuSVF1YW50aXplRmxvYXRBcnJheSA9IGZ1bmN0aW9uIChmbG9hdEFycmF5LCBudW1GbG9hdEFycmF5LCBkaW1GbG9hdEFycmF5LCBzdHJpZGUsIG1pbkZsb2F0QXJyYXksIG1heEZsb2F0QXJyYXksIG5RQml0cykge1xuICAgICAgICB2YXIgaWRlbHRhLCBxdWFudEZsb2F0QXJyYXksIGQsIHIsIHY7XG4gICAgICAgIGlkZWx0YSA9IHRoaXMubV9pZGVsdGE7XG4gICAgICAgIHF1YW50RmxvYXRBcnJheSA9IHRoaXMubV9xdWFudEZsb2F0QXJyYXk7XG4gICAgICAgIGZvciAoZCA9IDA7IGQgPCBkaW1GbG9hdEFycmF5OyArK2QpIHtcbiAgICAgICAgICAgIHIgPSBtYXhGbG9hdEFycmF5W2RdIC0gbWluRmxvYXRBcnJheVtkXTtcbiAgICAgICAgICAgIGlmIChyID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgaWRlbHRhW2RdID0gciAvICgoKDEgPDwgblFCaXRzKSA+Pj4gMCkgLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWRlbHRhW2RdID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodiA9IDA7IHYgPCBudW1GbG9hdEFycmF5OyArK3YpIHtcbiAgICAgICAgICAgIGZvciAoZCA9IDA7IGQgPCBkaW1GbG9hdEFycmF5OyArK2QpIHtcbiAgICAgICAgICAgICAgICBmbG9hdEFycmF5W3YgKiBzdHJpZGUgKyBkXSA9IHF1YW50RmxvYXRBcnJheVt2ICogc3RyaWRlICsgZF0gKiBpZGVsdGFbZF0gKyBtaW5GbG9hdEFycmF5W2RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuU0MzRE1DRGVjb2Rlci5wcm90b3R5cGUuRGVjb2RlUGxheWxvYWQgPSBmdW5jdGlvbiAoaWZzLCBic3RyZWFtKSB7XG4gICAgICAgIHZhciBwYXJhbXMsIGl0ZXJhdG9yLCBzdGF0cywgcHJlZE1vZGUsIHRpbWVyLCByZXQsIGE7XG4gICAgICAgIHBhcmFtcyA9IHRoaXMubV9wYXJhbXM7XG4gICAgICAgIGl0ZXJhdG9yID0gdGhpcy5tX2l0ZXJhdG9yO1xuICAgICAgICBzdGF0cyA9IHRoaXMubV9zdGF0cztcbiAgICAgICAgcHJlZE1vZGUgPSBuZXcgbW9kdWxlLk51bWJlclJlZigpO1xuICAgICAgICB0aW1lciA9IG5ldyBtb2R1bGUuVGltZXIoKTtcbiAgICAgICAgcmV0ID0gbW9kdWxlLk8zREdDX09LO1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVMaXN0RGVjb2Rlci5TZXRTdHJlYW1UeXBlKHRoaXMubV9zdHJlYW1UeXBlKTtcbiAgICAgICAgc3RhdHMubV9zdHJlYW1TaXplQ29vcmRJbmRleCA9IGl0ZXJhdG9yLm1fY291bnQ7XG4gICAgICAgIHRpbWVyLlRpYygpO1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVMaXN0RGVjb2Rlci5EZWNvZGUoaWZzLkdldENvb3JkSW5kZXgoKSwgaWZzLkdldE5Db29yZEluZGV4KCksIGlmcy5HZXROQ29vcmQoKSwgYnN0cmVhbSwgaXRlcmF0b3IpO1xuICAgICAgICB0aW1lci5Ub2MoKTtcbiAgICAgICAgc3RhdHMubV90aW1lQ29vcmRJbmRleCA9IHRpbWVyLkdldEVsYXBzZWRUaW1lKCk7XG4gICAgICAgIHN0YXRzLm1fc3RyZWFtU2l6ZUNvb3JkSW5kZXggPSBpdGVyYXRvci5tX2NvdW50IC0gc3RhdHMubV9zdHJlYW1TaXplQ29vcmRJbmRleDtcbiAgICAgICAgLy8gZGVjb2RlIGNvb3JkXG4gICAgICAgIHN0YXRzLm1fc3RyZWFtU2l6ZUNvb3JkID0gaXRlcmF0b3IubV9jb3VudDtcbiAgICAgICAgdGltZXIuVGljKCk7XG4gICAgICAgIGlmIChpZnMuR2V0TkNvb3JkKCkgPiAwKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLkRlY29kZUZsb2F0QXJyYXkoaWZzLkdldENvb3JkKCksIGlmcy5HZXROQ29vcmQoKSwgMywgMywgaWZzLkdldENvb3JkTWluQXJyYXkoKSwgaWZzLkdldENvb3JkTWF4QXJyYXkoKSwgcGFyYW1zLkdldENvb3JkUXVhbnRCaXRzKCksIGlmcywgcHJlZE1vZGUsIGJzdHJlYW0pO1xuICAgICAgICAgICAgcGFyYW1zLlNldENvb3JkUHJlZE1vZGUocHJlZE1vZGUubV92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldCAhPT0gbW9kdWxlLk8zREdDX09LKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyLlRvYygpO1xuICAgICAgICBzdGF0cy5tX3RpbWVDb29yZCA9IHRpbWVyLkdldEVsYXBzZWRUaW1lKCk7XG4gICAgICAgIHN0YXRzLm1fc3RyZWFtU2l6ZUNvb3JkID0gaXRlcmF0b3IubV9jb3VudCAtIHN0YXRzLm1fc3RyZWFtU2l6ZUNvb3JkO1xuXG4gICAgICAgIC8vIGRlY29kZSBOb3JtYWxcbiAgICAgICAgc3RhdHMubV9zdHJlYW1TaXplTm9ybWFsID0gaXRlcmF0b3IubV9jb3VudDtcbiAgICAgICAgdGltZXIuVGljKCk7XG4gICAgICAgIGlmIChpZnMuR2V0Tk5vcm1hbCgpID4gMCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5EZWNvZGVGbG9hdEFycmF5KGlmcy5HZXROb3JtYWwoKSwgaWZzLkdldE5Ob3JtYWwoKSwgMywgMywgaWZzLkdldE5vcm1hbE1pbkFycmF5KCksIGlmcy5HZXROb3JtYWxNYXhBcnJheSgpLCBwYXJhbXMuR2V0Tm9ybWFsUXVhbnRCaXRzKCksIGlmcywgcHJlZE1vZGUsIGJzdHJlYW0pO1xuICAgICAgICAgICAgcGFyYW1zLlNldE5vcm1hbFByZWRNb2RlKHByZWRNb2RlLm1fdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQgIT09IG1vZHVsZS5PM0RHQ19PSykge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICB0aW1lci5Ub2MoKTtcbiAgICAgICAgc3RhdHMubV90aW1lTm9ybWFsID0gdGltZXIuR2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgc3RhdHMubV9zdHJlYW1TaXplTm9ybWFsID0gaXRlcmF0b3IubV9jb3VudCAtIHN0YXRzLm1fc3RyZWFtU2l6ZU5vcm1hbDtcblxuICAgICAgICAvLyBkZWNvZGUgRmxvYXRBdHRyaWJ1dGVzXG4gICAgICAgIGZvciAoYSA9IDA7IGEgPCBpZnMuR2V0TnVtRmxvYXRBdHRyaWJ1dGVzKCk7ICsrYSkge1xuICAgICAgICAgICAgc3RhdHMubV9zdHJlYW1TaXplRmxvYXRBdHRyaWJ1dGVbYV0gPSBpdGVyYXRvci5tX2NvdW50O1xuICAgICAgICAgICAgdGltZXIuVGljKCk7XG4gICAgICAgICAgICByZXQgPSB0aGlzLkRlY29kZUZsb2F0QXJyYXkoaWZzLkdldEZsb2F0QXR0cmlidXRlKGEpLCBpZnMuR2V0TkZsb2F0QXR0cmlidXRlKGEpLCBpZnMuR2V0RmxvYXRBdHRyaWJ1dGVEaW0oYSksIGlmcy5HZXRGbG9hdEF0dHJpYnV0ZURpbShhKSwgaWZzLkdldEZsb2F0QXR0cmlidXRlTWluQXJyYXkoYSksIGlmcy5HZXRGbG9hdEF0dHJpYnV0ZU1heEFycmF5KGEpLCBwYXJhbXMuR2V0RmxvYXRBdHRyaWJ1dGVRdWFudEJpdHMoYSksIGlmcywgcHJlZE1vZGUsIGJzdHJlYW0pO1xuICAgICAgICAgICAgcGFyYW1zLlNldEZsb2F0QXR0cmlidXRlUHJlZE1vZGUoYSwgcHJlZE1vZGUubV92YWx1ZSk7XG4gICAgICAgICAgICB0aW1lci5Ub2MoKTtcbiAgICAgICAgICAgIHN0YXRzLm1fdGltZUZsb2F0QXR0cmlidXRlW2FdID0gdGltZXIuR2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgICAgIHN0YXRzLm1fc3RyZWFtU2l6ZUZsb2F0QXR0cmlidXRlW2FdID0gaXRlcmF0b3IubV9jb3VudCAtIHN0YXRzLm1fc3RyZWFtU2l6ZUZsb2F0QXR0cmlidXRlW2FdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQgIT09IG1vZHVsZS5PM0RHQ19PSykge1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWNvZGUgSW50QXR0cmlidXRlc1xuICAgICAgICBmb3IgKGEgPSAwOyBhIDwgaWZzLkdldE51bUludEF0dHJpYnV0ZXMoKTsgKythKSB7XG4gICAgICAgICAgICBzdGF0cy5tX3N0cmVhbVNpemVJbnRBdHRyaWJ1dGVbYV0gPSBpdGVyYXRvci5tX2NvdW50O1xuICAgICAgICAgICAgdGltZXIuVGljKCk7XG4gICAgICAgICAgICByZXQgPSB0aGlzLkRlY29kZUludEFycmF5KGlmcy5HZXRJbnRBdHRyaWJ1dGUoYSksIGlmcy5HZXROSW50QXR0cmlidXRlKGEpLCBpZnMuR2V0SW50QXR0cmlidXRlRGltKGEpLCBpZnMuR2V0SW50QXR0cmlidXRlRGltKGEpLCBpZnMsIHByZWRNb2RlLCBic3RyZWFtKTtcbiAgICAgICAgICAgIHBhcmFtcy5TZXRJbnRBdHRyaWJ1dGVQcmVkTW9kZShhLCBwcmVkTW9kZS5tX3ZhbHVlKTtcbiAgICAgICAgICAgIHRpbWVyLlRvYygpO1xuICAgICAgICAgICAgc3RhdHMubV90aW1lSW50QXR0cmlidXRlW2FdID0gdGltZXIuR2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgICAgIHN0YXRzLm1fc3RyZWFtU2l6ZUludEF0dHJpYnV0ZVthXSA9IGl0ZXJhdG9yLm1fY291bnQgLSBzdGF0cy5tX3N0cmVhbVNpemVJbnRBdHRyaWJ1dGVbYV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldCAhPT0gbW9kdWxlLk8zREdDX09LKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyLlRpYygpO1xuICAgICAgICB0aGlzLm1fdHJpYW5nbGVMaXN0RGVjb2Rlci5SZW9yZGVyKCk7XG4gICAgICAgIHRpbWVyLlRvYygpO1xuICAgICAgICBzdGF0cy5tX3RpbWVSZW9yZGVyID0gdGltZXIuR2V0RWxhcHNlZFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICAgIC8vIERWRW5jb2RlUGFyYW1zIGNsYXNzXG4gICAgbW9kdWxlLkRWRW5jb2RlUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fZW5jb2RlTW9kZSA9IGxvY2FsLk8zREdDX0RZTkFNSUNfVkVDVE9SX0VOQ09ERV9NT0RFX0xJRlQ7XG4gICAgICAgIHRoaXMubV9zdHJlYW1UeXBlTW9kZSA9IGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0FTQ0lJO1xuICAgICAgICB0aGlzLm1fcXVhbnRCaXRzID0gMTA7XG4gICAgfTtcbiAgICBtb2R1bGUuRFZFbmNvZGVQYXJhbXMucHJvdG90eXBlLkdldFN0cmVhbVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fc3RyZWFtVHlwZU1vZGU7XG4gICAgfTtcbiAgICBtb2R1bGUuRFZFbmNvZGVQYXJhbXMucHJvdG90eXBlLkdldEVuY29kZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZW5jb2RlTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5EVkVuY29kZVBhcmFtcy5wcm90b3R5cGUuR2V0UXVhbnRCaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3F1YW50Qml0cztcbiAgICB9O1xuICAgIG1vZHVsZS5EVkVuY29kZVBhcmFtcy5wcm90b3R5cGUuU2V0U3RyZWFtVHlwZSA9IGZ1bmN0aW9uIChzdHJlYW1UeXBlTW9kZSkge1xuICAgICAgICB0aGlzLm1fc3RyZWFtVHlwZU1vZGUgPSBzdHJlYW1UeXBlTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5EVkVuY29kZVBhcmFtcy5wcm90b3R5cGUuU2V0RW5jb2RlTW9kZSA9IGZ1bmN0aW9uIChlbmNvZGVNb2RlKSB7XG4gICAgICAgIHRoaXMubV9lbmNvZGVNb2RlID0gZW5jb2RlTW9kZTtcbiAgICB9O1xuICAgIG1vZHVsZS5EVkVuY29kZVBhcmFtcy5wcm90b3R5cGUuU2V0UXVhbnRCaXRzID0gZnVuY3Rpb24gKHF1YW50Qml0cykge1xuICAgICAgICB0aGlzLm1fcXVhbnRCaXRzID0gcXVhbnRCaXRzO1xuICAgIH07XG4gICAgLy8gRHluYW1pY1ZlY3RvciBjbGFzc1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fbnVtID0gMDtcbiAgICAgICAgdGhpcy5tX2RpbSA9IDA7XG4gICAgICAgIHRoaXMubV9zdHJpZGUgPSAwO1xuICAgICAgICB0aGlzLm1fbWF4ID0ge307XG4gICAgICAgIHRoaXMubV9taW4gPSB7fTtcbiAgICAgICAgdGhpcy5tX3ZlY3RvcnMgPSB7fTtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yLnByb3RvdHlwZS5HZXROVmVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX251bTtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yLnByb3RvdHlwZS5HZXREaW1WZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fZGltO1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3IucHJvdG90eXBlLkdldFN0cmlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9zdHJpZGU7XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3Rvci5wcm90b3R5cGUuR2V0TWluQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1fbWluO1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3IucHJvdG90eXBlLkdldE1heEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX21heDtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yLnByb3RvdHlwZS5HZXRWZWN0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tX3ZlY3RvcnM7XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3Rvci5wcm90b3R5cGUuR2V0TWluID0gZnVuY3Rpb24gKGopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9taW5bal07XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3Rvci5wcm90b3R5cGUuR2V0TWF4ID0gZnVuY3Rpb24gKGopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9tYXhbal07XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3Rvci5wcm90b3R5cGUuU2V0TlZlY3RvciA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgdGhpcy5tX251bSA9IG51bTtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yLnByb3RvdHlwZS5TZXREaW1WZWN0b3IgPSBmdW5jdGlvbiAoZGltKSB7XG4gICAgICAgIHRoaXMubV9kaW0gPSBkaW07XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3Rvci5wcm90b3R5cGUuU2V0U3RyaWRlID0gZnVuY3Rpb24gKHN0cmlkZSkge1xuICAgICAgICB0aGlzLm1fc3RyaWRlID0gc3RyaWRlO1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3IucHJvdG90eXBlLlNldE1pbkFycmF5ID0gZnVuY3Rpb24gKG1pbikge1xuICAgICAgICB0aGlzLm1fbWluID0gbWluO1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3IucHJvdG90eXBlLlNldE1heEFycmF5ID0gZnVuY3Rpb24gKG1heCkge1xuICAgICAgICB0aGlzLm1fbWF4ID0gbWF4O1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3IucHJvdG90eXBlLlNldE1pbiA9IGZ1bmN0aW9uIChqLCBtaW4pIHtcbiAgICAgICAgdGhpcy5tX21pbltqXSA9IG1pbjtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yLnByb3RvdHlwZS5TZXRNYXggPSBmdW5jdGlvbiAoaiwgbWF4KSB7XG4gICAgICAgIHRoaXMubV9tYXhbal0gPSBtYXg7XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3Rvci5wcm90b3R5cGUuU2V0VmVjdG9ycyA9IGZ1bmN0aW9uICh2ZWN0b3JzKSB7XG4gICAgICAgIHRoaXMubV92ZWN0b3JzID0gdmVjdG9ycztcbiAgICB9O1xuICAgIC8vIER5bmFtaWNWZWN0b3JEZWNvZGVyIGNsYXNzXG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3JEZWNvZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1fc3RyZWFtU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMubV9tYXhOdW1WZWN0b3JzID0gMDtcbiAgICAgICAgdGhpcy5tX251bVZlY3RvcnMgPSAwO1xuICAgICAgICB0aGlzLm1fZGltVmVjdG9ycyA9IDA7XG4gICAgICAgIHRoaXMubV9xdWFudFZlY3RvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5tX2l0ZXJhdG9yID0gbmV3IG1vZHVsZS5JdGVyYXRvcigpO1xuICAgICAgICB0aGlzLm1fc3RyZWFtVHlwZSA9IGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX1VOS09XTjtcbiAgICAgICAgdGhpcy5tX3BhcmFtcyA9IG5ldyBtb2R1bGUuRFZFbmNvZGVQYXJhbXMoKTtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yRGVjb2Rlci5wcm90b3R5cGUuR2V0U3RyZWFtVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9zdHJlYW1UeXBlO1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3JEZWNvZGVyLnByb3RvdHlwZS5HZXRJdGVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubV9pdGVyYXRvcjtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yRGVjb2Rlci5wcm90b3R5cGUuU2V0U3RyZWFtVHlwZSA9IGZ1bmN0aW9uIChzdHJlYW1UeXBlKSB7XG4gICAgICAgIHRoaXMubV9zdHJlYW1UeXBlID0gc3RyZWFtVHlwZTtcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yRGVjb2Rlci5wcm90b3R5cGUuU2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5tX2l0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3RvckRlY29kZXIucHJvdG90eXBlLklVcGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgc2hpZnQsIHNpemUpIHtcbiAgICAgICAgdmFyIHAsIHNpemUxO1xuICAgICAgICBzaXplMSA9IHNpemUgLSAxO1xuICAgICAgICBwID0gMjtcbiAgICAgICAgZGF0YVtzaGlmdF0gLT0gZGF0YVtzaGlmdCArIDFdID4+IDE7XG4gICAgICAgIHdoaWxlIChwIDwgc2l6ZTEpIHtcbiAgICAgICAgICAgIGRhdGFbc2hpZnQgKyBwXSAtPSAoZGF0YVtzaGlmdCArIHAgLSAxXSArIGRhdGFbc2hpZnQgKyBwICsgMV0gKyAyKSA+PiAyO1xuICAgICAgICAgICAgcCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSBzaXplMSkge1xuICAgICAgICAgICAgZGF0YVtzaGlmdCArIHBdIC09IGRhdGFbc2hpZnQgKyBwIC0gMV0gPj4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3JEZWNvZGVyLnByb3RvdHlwZS5JUHJlZGljdCA9IGZ1bmN0aW9uIChkYXRhLCBzaGlmdCwgc2l6ZSkge1xuICAgICAgICB2YXIgcCwgc2l6ZTE7XG4gICAgICAgIHNpemUxID0gc2l6ZSAtIDE7XG4gICAgICAgIHAgPSAxO1xuICAgICAgICB3aGlsZSAocCA8IHNpemUxKSB7XG4gICAgICAgICAgICBkYXRhW3NoaWZ0ICsgcF0gKz0gKGRhdGFbc2hpZnQgKyBwIC0gMV0gKyBkYXRhW3NoaWZ0ICsgcCArIDFdICsgMSkgPj4gMTtcbiAgICAgICAgICAgIHAgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gc2l6ZTEpIHtcbiAgICAgICAgICAgIGRhdGFbc2hpZnQgKyBwXSArPSBkYXRhW3NoaWZ0ICsgcCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3RvckRlY29kZXIucHJvdG90eXBlLk1lcmdlID0gZnVuY3Rpb24gKGRhdGEsIHNoaWZ0LCBzaXplKSB7XG4gICAgICAgIHZhciBpLCBoLCBhLCBiLCB0bXA7XG4gICAgICAgIGggPSAoc2l6ZSA+PiAxKSArIChzaXplICYgMSk7XG4gICAgICAgIGEgPSBoIC0gMTtcbiAgICAgICAgYiA9IGg7XG4gICAgICAgIHdoaWxlIChhID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gYTsgaSA8IGI7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHRtcCA9IGRhdGFbc2hpZnQgKyBpXTtcbiAgICAgICAgICAgICAgICBkYXRhW3NoaWZ0ICsgaV0gPSBkYXRhW3NoaWZ0ICsgaSArIDFdO1xuICAgICAgICAgICAgICAgIGRhdGFbc2hpZnQgKyBpICsgMV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAtLWE7XG4gICAgICAgICAgICArK2I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5PM0RHQ19PSztcbiAgICB9O1xuICAgIG1vZHVsZS5EeW5hbWljVmVjdG9yRGVjb2Rlci5wcm90b3R5cGUuSVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChkYXRhLCBzaGlmdCwgc2l6ZSkge1xuICAgICAgICB2YXIgbiwgZXZlbiwgaywgaTtcbiAgICAgICAgbiA9IHNpemU7XG4gICAgICAgIGV2ZW4gPSAwO1xuICAgICAgICBrID0gMDtcbiAgICAgICAgZXZlbiArPSAoKG4gJiAxKSA8PCBrKyspID4+PiAwO1xuICAgICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgICAgIG4gPSAobiA+PiAxKSArICgobiAmIDEpID4+PiAwKTtcbiAgICAgICAgICAgIGV2ZW4gKz0gKChuICYgMSkgPDwgaysrKSA+Pj4gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBrIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIG4gPSAoKG4gPDwgMSkgPj4+IDApIC0gKCgoZXZlbiA+Pj4gaSkgJiAxKSkgPj4+IDA7XG4gICAgICAgICAgICB0aGlzLk1lcmdlKGRhdGEsIHNoaWZ0LCBuKTtcbiAgICAgICAgICAgIHRoaXMuSVVwZGF0ZShkYXRhLCBzaGlmdCwgbik7XG4gICAgICAgICAgICB0aGlzLklQcmVkaWN0KGRhdGEsIHNoaWZ0LCBuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlLk8zREdDX09LO1xuICAgIH07XG4gICAgbW9kdWxlLkR5bmFtaWNWZWN0b3JEZWNvZGVyLnByb3RvdHlwZS5JUXVhbnRpemUgPSBmdW5jdGlvbiAoZmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1GbG9hdEFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbUZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkZsb2F0QXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RmxvYXRBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuUUJpdHMpIHtcbiAgICAgICAgdmFyIHF1YW50VmVjdG9ycywgciwgaWRlbHRhLCBzaXplLCBkLCB2O1xuICAgICAgICBxdWFudFZlY3RvcnMgPSB0aGlzLm1fcXVhbnRWZWN0b3JzO1xuICAgICAgICBzaXplID0gbnVtRmxvYXRBcnJheSAqIGRpbUZsb2F0QXJyYXk7XG4gICAgICAgIGZvciAoZCA9IDA7IGQgPCBkaW1GbG9hdEFycmF5OyArK2QpIHtcbiAgICAgICAgICAgIHIgPSBtYXhGbG9hdEFycmF5W2RdIC0gbWluRmxvYXRBcnJheVtkXTtcbiAgICAgICAgICAgIGlmIChyID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgaWRlbHRhID0gciAvICgoKDEgPDwgblFCaXRzKSA+Pj4gMCkgLSAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWRlbHRhID0gMS4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2ID0gMDsgdiA8IG51bUZsb2F0QXJyYXk7ICsrdikge1xuICAgICAgICAgICAgICAgIGZsb2F0QXJyYXlbdiAqIHN0cmlkZSArIGRdID0gcXVhbnRWZWN0b3JzW3YgKyBkICogbnVtRmxvYXRBcnJheV0gKiBpZGVsdGEgKyBtaW5GbG9hdEFycmF5W2RdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3RvckRlY29kZXIucHJvdG90eXBlLkRlY29kZUhlYWRlciA9IGZ1bmN0aW9uIChkeW5hbWljVmVjdG9yLCBic3RyZWFtKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciwgYzAsIHN0YXJ0X2NvZGUsIHN0cmVhbVR5cGU7XG4gICAgICAgIGl0ZXJhdG9yID0gdGhpcy5tX2l0ZXJhdG9yO1xuICAgICAgICBjMCA9IGl0ZXJhdG9yLm1fY291bnQ7XG4gICAgICAgIHN0YXJ0X2NvZGUgPSBic3RyZWFtLlJlYWRVSW50MzIoaXRlcmF0b3IsIGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0JJTkFSWSk7XG4gICAgICAgIGlmIChzdGFydF9jb2RlICE9PSBsb2NhbC5PM0RHQ19EVl9TVEFSVF9DT0RFKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5tX2NvdW50ID0gYzA7XG4gICAgICAgICAgICBzdGFydF9jb2RlID0gYnN0cmVhbS5SZWFkVUludDMyKGl0ZXJhdG9yLCBsb2NhbC5PM0RHQ19TVFJFQU1fVFlQRV9BU0NJSSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRfY29kZSAhPT0gbG9jYWwuTzNER0NfRFZfU1RBUlRfQ09ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfRVJST1JfQ09SUlVQVEVEX1NUUkVBTTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubV9zdHJlYW1UeXBlID0gbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfQVNDSUk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1fc3RyZWFtVHlwZSA9IGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0JJTkFSWTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1UeXBlID0gdGhpcy5tX3N0cmVhbVR5cGU7XG4gICAgICAgIHRoaXMubV9zdHJlYW1TaXplID0gYnN0cmVhbS5SZWFkVUludDMyKGl0ZXJhdG9yLCBzdHJlYW1UeXBlKTtcbiAgICAgICAgdGhpcy5tX3BhcmFtcy5TZXRFbmNvZGVNb2RlKGJzdHJlYW0uUmVhZFVDaGFyKGl0ZXJhdG9yLCBzdHJlYW1UeXBlKSk7XG4gICAgICAgIGR5bmFtaWNWZWN0b3IuU2V0TlZlY3Rvcihic3RyZWFtLlJlYWRVSW50MzIoaXRlcmF0b3IsIHN0cmVhbVR5cGUpKTtcbiAgICAgICAgaWYgKGR5bmFtaWNWZWN0b3IuR2V0TlZlY3RvcigpID4gMCkge1xuICAgICAgICAgICAgZHluYW1pY1ZlY3Rvci5TZXREaW1WZWN0b3IoYnN0cmVhbS5SZWFkVUludDMyKGl0ZXJhdG9yLCBzdHJlYW1UeXBlKSk7XG4gICAgICAgICAgICB0aGlzLm1fcGFyYW1zLlNldFF1YW50Qml0cyhic3RyZWFtLlJlYWRVQ2hhcihpdGVyYXRvciwgc3RyZWFtVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUuTzNER0NfT0s7XG4gICAgfTtcbiAgICBtb2R1bGUuRHluYW1pY1ZlY3RvckRlY29kZXIucHJvdG90eXBlLkRlY29kZVBsYXlsb2FkID0gZnVuY3Rpb24gKGR5bmFtaWNWZWN0b3IsIGJzdHJlYW0pIHtcbiAgICAgICAgdmFyIHNpemUsIGl0ZXJhdG9yLCBzdHJlYW1UeXBlLCByZXQsIHN0YXJ0LCBzdHJlYW1TaXplLCBkaW0sIG51bSwgaiwgYWNkLCBiTW9kZWwwLCBiTW9kZWwxLCBleHBfaywgTSwgYnVmZmVyLCBtTW9kZWxWYWx1ZXMsIHF1YW50VmVjdG9ycywgdiwgZDtcbiAgICAgICAgaXRlcmF0b3IgPSB0aGlzLm1faXRlcmF0b3I7XG4gICAgICAgIHN0cmVhbVR5cGUgPSB0aGlzLm1fc3RyZWFtVHlwZTtcbiAgICAgICAgcmV0ID0gbW9kdWxlLk8zREdDX09LO1xuICAgICAgICBzdGFydCA9IGl0ZXJhdG9yLm1fY291bnQ7XG4gICAgICAgIHN0cmVhbVNpemUgPSBic3RyZWFtLlJlYWRVSW50MzIoaXRlcmF0b3IsIHN0cmVhbVR5cGUpO1xuICAgICAgICBkaW0gPSBkeW5hbWljVmVjdG9yLkdldERpbVZlY3RvcigpO1xuICAgICAgICBudW0gPSBkeW5hbWljVmVjdG9yLkdldE5WZWN0b3IoKTtcbiAgICAgICAgc2l6ZSA9IGRpbSAqIG51bTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGR5bmFtaWNWZWN0b3IuR2V0RGltVmVjdG9yKCk7ICsraikge1xuICAgICAgICAgICAgZHluYW1pY1ZlY3Rvci5TZXRNaW4oaiwgYnN0cmVhbS5SZWFkRmxvYXQzMihpdGVyYXRvciwgc3RyZWFtVHlwZSkpO1xuICAgICAgICAgICAgZHluYW1pY1ZlY3Rvci5TZXRNYXgoaiwgYnN0cmVhbS5SZWFkRmxvYXQzMihpdGVyYXRvciwgc3RyZWFtVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGFjZCA9IG5ldyBtb2R1bGUuQXJpdGhtZXRpY0RlY29kZXIoKTtcbiAgICAgICAgYk1vZGVsMCA9IG5ldyBtb2R1bGUuU3RhdGljQml0TW9kZWwoKTtcbiAgICAgICAgYk1vZGVsMSA9IG5ldyBtb2R1bGUuQWRhcHRpdmVCaXRNb2RlbCgpO1xuICAgICAgICBzdHJlYW1TaXplIC09IChpdGVyYXRvci5tX2NvdW50IC0gc3RhcnQpO1xuICAgICAgICBleHBfayA9IDA7XG4gICAgICAgIE0gPSAwO1xuICAgICAgICBpZiAoc3RyZWFtVHlwZSA9PT0gbG9jYWwuTzNER0NfU1RSRUFNX1RZUEVfQklOQVJZKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBic3RyZWFtLkdldEJ1ZmZlcihpdGVyYXRvciwgc3RyZWFtU2l6ZSk7XG4gICAgICAgICAgICBpdGVyYXRvci5tX2NvdW50ICs9IHN0cmVhbVNpemU7XG4gICAgICAgICAgICBhY2QuU2V0QnVmZmVyKHN0cmVhbVNpemUsIGJ1ZmZlcik7XG4gICAgICAgICAgICBhY2QuU3RhcnREZWNvZGVyKCk7XG4gICAgICAgICAgICBleHBfayA9IGFjZC5FeHBHb2xvbWJEZWNvZGUoMCwgYk1vZGVsMCwgYk1vZGVsMSk7XG4gICAgICAgICAgICBNID0gYWNkLkV4cEdvbG9tYkRlY29kZSgwLCBiTW9kZWwwLCBiTW9kZWwxKTtcbiAgICAgICAgfVxuICAgICAgICBtTW9kZWxWYWx1ZXMgPSBuZXcgbW9kdWxlLkFkYXB0aXZlRGF0YU1vZGVsKCk7XG4gICAgICAgIG1Nb2RlbFZhbHVlcy5TZXRBbHBoYWJldChNICsgMik7XG4gICAgICAgIGlmICh0aGlzLm1fbWF4TnVtVmVjdG9ycyA8IHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubV9tYXhOdW1WZWN0b3JzID0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMubV9xdWFudFZlY3RvcnMgPSBuZXcgSW50MzJBcnJheSh0aGlzLm1fbWF4TnVtVmVjdG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcXVhbnRWZWN0b3JzID0gdGhpcy5tX3F1YW50VmVjdG9ycztcbiAgICAgICAgaWYgKHN0cmVhbVR5cGUgPT09IGxvY2FsLk8zREdDX1NUUkVBTV9UWVBFX0FTQ0lJKSB7XG4gICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDwgbnVtOyArK3YpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRWZWN0b3JzW2QgKiBudW0gKyB2XSA9IGJzdHJlYW0uUmVhZEludEFTQ0lJKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHYgPSAwOyB2IDwgbnVtOyArK3YpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGQgPSAwOyBkIDwgZGltOyArK2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRWZWN0b3JzW2QgKiBudW0gKyB2XSA9IGFjZC5EZWNvZGVJbnRBQ0VHQyhtTW9kZWxWYWx1ZXMsIGJNb2RlbDAsIGJNb2RlbDEsIGV4cF9rLCBNKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChkID0gMDsgZCA8IGRpbTsgKytkKSB7XG4gICAgICAgICAgICB0aGlzLklUcmFuc2Zvcm0ocXVhbnRWZWN0b3JzLCBkICogbnVtLCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuSVF1YW50aXplKGR5bmFtaWNWZWN0b3IuR2V0VmVjdG9ycygpLCBudW0sIGRpbSxcbiAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1ZlY3Rvci5HZXRTdHJpZGUoKSwgZHluYW1pY1ZlY3Rvci5HZXRNaW5BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljVmVjdG9yLkdldE1heEFycmF5KCksIHRoaXMubV9wYXJhbXMuR2V0UXVhbnRCaXRzKCkpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICByZXR1cm4gbW9kdWxlO1xufSkoKTtcblxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG5pZiAoIXByb2Nlc3MuYnJvd3Nlcilcblx0ZXhwb3J0cy50b0J1ZmZlciA9IHJlcXVpcmUoXCIuL2J1aWxkL1JlbGVhc2UvXCIgKyBcIm9wZW5jdG1cIik7XG5cbmV4cG9ydHMuZnJvbUJ1ZmZlciA9IHJlcXVpcmUoXCIuL2xpYi9mcm9tX2J1ZmZlclwiKTtcblxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIi9Vc2Vycy9qYW4vZGV2ZWxvcG1lbnQveG1sM2RfYmxhc3RfbG9hZGVyL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSkiLCJcbnZhciBMWk1BID0gcmVxdWlyZShcIi4vbHptYVwiKTtcblxudmFyIENUTSA9IG1vZHVsZS5leHBvcnRzO1xuXG5DVE0uQ29tcHJlc3Npb25NZXRob2QgPSB7XG4gIFJBVzogMHgwMDU3NDE1MixcbiAgTUcxOiAweDAwMzE0NzRkLFxuICBNRzI6IDB4MDAzMjQ3NGRcbn07XG5cbkNUTS5GbGFncyA9IHtcbiAgTk9STUFMUzogMHgwMDAwMDAwMVxufTtcblxuQ1RNLkZpbGUgPSBmdW5jdGlvbihzdHJlYW0pe1xuICB0aGlzLmxvYWQoc3RyZWFtKTtcbn07XG5cbkNUTS5GaWxlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24oc3RyZWFtKXtcbiAgdGhpcy5oZWFkZXIgPSBuZXcgQ1RNLkZpbGVIZWFkZXIoc3RyZWFtKTtcblxuICB0aGlzLmJvZHkgPSBuZXcgQ1RNLkZpbGVCb2R5KHRoaXMuaGVhZGVyKTtcblxuICB0aGlzLmdldFJlYWRlcigpLnJlYWQoc3RyZWFtLCB0aGlzLmJvZHkpO1xufTtcblxuQ1RNLkZpbGUucHJvdG90eXBlLmdldFJlYWRlciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZWFkZXI7XG5cbiAgc3dpdGNoKHRoaXMuaGVhZGVyLmNvbXByZXNzaW9uTWV0aG9kKXtcbiAgICBjYXNlIENUTS5Db21wcmVzc2lvbk1ldGhvZC5SQVc6XG4gICAgICByZWFkZXIgPSBuZXcgQ1RNLlJlYWRlclJBVygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDVE0uQ29tcHJlc3Npb25NZXRob2QuTUcxOlxuICAgICAgcmVhZGVyID0gbmV3IENUTS5SZWFkZXJNRzEoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ1RNLkNvbXByZXNzaW9uTWV0aG9kLk1HMjpcbiAgICAgIHJlYWRlciA9IG5ldyBDVE0uUmVhZGVyTUcyKCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiByZWFkZXI7XG59O1xuXG5DVE0uRmlsZUhlYWRlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgbWFnaWMgPSBzdHJlYW0ucmVhZEludDMyKCk7IC8vbWFnaWMgXCJPQ1RNXCJcbiAgaWYgKG1hZ2ljICE9PSAweDRkNTQ0MzRmKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhIE9wZW5DVE0gc3RyZWFtLCBtYWdpYyBudW1iZXIgc2hvdWxkIGJlIDB4NGQ1NDQzNGYgKCdPQ1RNJylcIik7XG4gIHRoaXMuZmlsZUZvcm1hdCA9IHN0cmVhbS5yZWFkSW50MzIoKTtcbiAgdGhpcy5jb21wcmVzc2lvbk1ldGhvZCA9IHN0cmVhbS5yZWFkSW50MzIoKTtcbiAgdGhpcy52ZXJ0ZXhDb3VudCA9IHN0cmVhbS5yZWFkSW50MzIoKTtcbiAgdGhpcy50cmlhbmdsZUNvdW50ID0gc3RyZWFtLnJlYWRJbnQzMigpO1xuICB0aGlzLnV2TWFwQ291bnQgPSBzdHJlYW0ucmVhZEludDMyKCk7XG4gIHRoaXMuYXR0ck1hcENvdW50ID0gc3RyZWFtLnJlYWRJbnQzMigpO1xuICB0aGlzLmZsYWdzID0gc3RyZWFtLnJlYWRJbnQzMigpO1xuICB0aGlzLmNvbW1lbnQgPSBzdHJlYW0ucmVhZFN0cmluZygpO1xufTtcblxuQ1RNLkZpbGVIZWFkZXIucHJvdG90eXBlLmhhc05vcm1hbHMgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5mbGFncyAmIENUTS5GbGFncy5OT1JNQUxTO1xufTtcblxuQ1RNLkZpbGVCb2R5ID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgdmFyIGkgPSBoZWFkZXIudHJpYW5nbGVDb3VudCAqIDMsXG4gICAgICB2ID0gaGVhZGVyLnZlcnRleENvdW50ICogMyxcbiAgICAgIG4gPSBoZWFkZXIuaGFzTm9ybWFscygpPyBoZWFkZXIudmVydGV4Q291bnQgKiAzOiAwLFxuICAgICAgdSA9IGhlYWRlci52ZXJ0ZXhDb3VudCAqIDIsXG4gICAgICBhID0gaGVhZGVyLnZlcnRleENvdW50ICogNCxcbiAgICAgIGogPSAwO1xuXG4gIHZhciBkYXRhID0gbmV3IEFycmF5QnVmZmVyKFxuICAgIChpICsgdiArIG4gKyAodSAqIGhlYWRlci51dk1hcENvdW50KSArIChhICogaGVhZGVyLmF0dHJNYXBDb3VudCkgKSAqIDQpO1xuXG4gIHRoaXMuaW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShkYXRhLCAwLCBpKTtcblxuICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLCBpICogNCwgdik7XG5cbiAgaWYgKCBoZWFkZXIuaGFzTm9ybWFscygpICl7XG4gICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLCAoaSArIHYpICogNCwgbik7XG4gIH1cblxuICBpZiAoaGVhZGVyLnV2TWFwQ291bnQpe1xuICAgIHRoaXMudXZNYXBzID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IGhlYWRlci51dk1hcENvdW50OyArKyBqKXtcbiAgICAgIHRoaXMudXZNYXBzW2pdID0ge3V2OiBuZXcgRmxvYXQzMkFycmF5KGRhdGEsXG4gICAgICAgIChpICsgdiArIG4gKyAoaiAqIHUpICkgKiA0LCB1KSB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChoZWFkZXIuYXR0ck1hcENvdW50KXtcbiAgICB0aGlzLmF0dHJNYXBzID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IGhlYWRlci5hdHRyTWFwQ291bnQ7ICsrIGope1xuICAgICAgdGhpcy5hdHRyTWFwc1tqXSA9IHthdHRyOiBuZXcgRmxvYXQzMkFycmF5KGRhdGEsXG4gICAgICAgIChpICsgdiArIG4gKyAodSAqIGhlYWRlci51dk1hcENvdW50KSArIChqICogYSkgKSAqIDQsIGEpIH07XG4gICAgfVxuICB9XG59O1xuXG5DVE0uRmlsZU1HMkhlYWRlciA9IGZ1bmN0aW9uKHN0cmVhbSl7XG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIk1HMkhcIlxuICB0aGlzLnZlcnRleFByZWNpc2lvbiA9IHN0cmVhbS5yZWFkRmxvYXQzMigpO1xuICB0aGlzLm5vcm1hbFByZWNpc2lvbiA9IHN0cmVhbS5yZWFkRmxvYXQzMigpO1xuICB0aGlzLmxvd2VyQm91bmR4ID0gc3RyZWFtLnJlYWRGbG9hdDMyKCk7XG4gIHRoaXMubG93ZXJCb3VuZHkgPSBzdHJlYW0ucmVhZEZsb2F0MzIoKTtcbiAgdGhpcy5sb3dlckJvdW5keiA9IHN0cmVhbS5yZWFkRmxvYXQzMigpO1xuICB0aGlzLmhpZ2hlckJvdW5keCA9IHN0cmVhbS5yZWFkRmxvYXQzMigpO1xuICB0aGlzLmhpZ2hlckJvdW5keSA9IHN0cmVhbS5yZWFkRmxvYXQzMigpO1xuICB0aGlzLmhpZ2hlckJvdW5keiA9IHN0cmVhbS5yZWFkRmxvYXQzMigpO1xuICB0aGlzLmRpdnggPSBzdHJlYW0ucmVhZEludDMyKCk7XG4gIHRoaXMuZGl2eSA9IHN0cmVhbS5yZWFkSW50MzIoKTtcbiAgdGhpcy5kaXZ6ID0gc3RyZWFtLnJlYWRJbnQzMigpO1xuXG4gIHRoaXMuc2l6ZXggPSAodGhpcy5oaWdoZXJCb3VuZHggLSB0aGlzLmxvd2VyQm91bmR4KSAvIHRoaXMuZGl2eDtcbiAgdGhpcy5zaXpleSA9ICh0aGlzLmhpZ2hlckJvdW5keSAtIHRoaXMubG93ZXJCb3VuZHkpIC8gdGhpcy5kaXZ5O1xuICB0aGlzLnNpemV6ID0gKHRoaXMuaGlnaGVyQm91bmR6IC0gdGhpcy5sb3dlckJvdW5keikgLyB0aGlzLmRpdno7XG59O1xuXG5DVE0uUmVhZGVyUkFXID0gZnVuY3Rpb24oKXtcbn07XG5cbkNUTS5SZWFkZXJSQVcucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzdHJlYW0sIGJvZHkpe1xuICB0aGlzLnJlYWRJbmRpY2VzKHN0cmVhbSwgYm9keS5pbmRpY2VzKTtcbiAgdGhpcy5yZWFkVmVydGljZXMoc3RyZWFtLCBib2R5LnZlcnRpY2VzKTtcblxuICBpZiAoYm9keS5ub3JtYWxzKXtcbiAgICB0aGlzLnJlYWROb3JtYWxzKHN0cmVhbSwgYm9keS5ub3JtYWxzKTtcbiAgfVxuICBpZiAoYm9keS51dk1hcHMpe1xuICAgIHRoaXMucmVhZFVWTWFwcyhzdHJlYW0sIGJvZHkudXZNYXBzKTtcbiAgfVxuICBpZiAoYm9keS5hdHRyTWFwcyl7XG4gICAgdGhpcy5yZWFkQXR0ck1hcHMoc3RyZWFtLCBib2R5LmF0dHJNYXBzKTtcbiAgfVxufTtcblxuQ1RNLlJlYWRlclJBVy5wcm90b3R5cGUucmVhZEluZGljZXMgPSBmdW5jdGlvbihzdHJlYW0sIGluZGljZXMpe1xuICBzdHJlYW0ucmVhZEludDMyKCk7IC8vbWFnaWMgXCJJTkRYXCJcbiAgc3RyZWFtLnJlYWRBcnJheUludDMyKGluZGljZXMpO1xufTtcblxuQ1RNLlJlYWRlclJBVy5wcm90b3R5cGUucmVhZFZlcnRpY2VzID0gZnVuY3Rpb24oc3RyZWFtLCB2ZXJ0aWNlcyl7XG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIlZFUlRcIlxuICBzdHJlYW0ucmVhZEFycmF5RmxvYXQzMih2ZXJ0aWNlcyk7XG59O1xuXG5DVE0uUmVhZGVyUkFXLnByb3RvdHlwZS5yZWFkTm9ybWFscyA9IGZ1bmN0aW9uKHN0cmVhbSwgbm9ybWFscyl7XG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIk5PUk1cIlxuICBzdHJlYW0ucmVhZEFycmF5RmxvYXQzMihub3JtYWxzKTtcbn07XG5cbkNUTS5SZWFkZXJSQVcucHJvdG90eXBlLnJlYWRVVk1hcHMgPSBmdW5jdGlvbihzdHJlYW0sIHV2TWFwcyl7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCB1dk1hcHMubGVuZ3RoOyArKyBpKXtcbiAgICBzdHJlYW0ucmVhZEludDMyKCk7IC8vbWFnaWMgXCJURVhDXCJcblxuICAgIHV2TWFwc1tpXS5uYW1lID0gc3RyZWFtLnJlYWRTdHJpbmcoKTtcbiAgICB1dk1hcHNbaV0uZmlsZW5hbWUgPSBzdHJlYW0ucmVhZFN0cmluZygpO1xuICAgIHN0cmVhbS5yZWFkQXJyYXlGbG9hdDMyKHV2TWFwc1tpXS51dik7XG4gIH1cbn07XG5cbkNUTS5SZWFkZXJSQVcucHJvdG90eXBlLnJlYWRBdHRyTWFwcyA9IGZ1bmN0aW9uKHN0cmVhbSwgYXR0ck1hcHMpe1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgYXR0ck1hcHMubGVuZ3RoOyArKyBpKXtcbiAgICBzdHJlYW0ucmVhZEludDMyKCk7IC8vbWFnaWMgXCJBVFRSXCJcblxuICAgIGF0dHJNYXBzW2ldLm5hbWUgPSBzdHJlYW0ucmVhZFN0cmluZygpO1xuICAgIHN0cmVhbS5yZWFkQXJyYXlGbG9hdDMyKGF0dHJNYXBzW2ldLmF0dHIpO1xuICB9XG59O1xuXG5DVE0uUmVhZGVyTUcxID0gZnVuY3Rpb24oKXtcbn07XG5cbkNUTS5SZWFkZXJNRzEucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzdHJlYW0sIGJvZHkpe1xuICB0aGlzLnJlYWRJbmRpY2VzKHN0cmVhbSwgYm9keS5pbmRpY2VzKTtcbiAgdGhpcy5yZWFkVmVydGljZXMoc3RyZWFtLCBib2R5LnZlcnRpY2VzKTtcblxuICBpZiAoYm9keS5ub3JtYWxzKXtcbiAgICB0aGlzLnJlYWROb3JtYWxzKHN0cmVhbSwgYm9keS5ub3JtYWxzKTtcbiAgfVxuICBpZiAoYm9keS51dk1hcHMpe1xuICAgIHRoaXMucmVhZFVWTWFwcyhzdHJlYW0sIGJvZHkudXZNYXBzKTtcbiAgfVxuICBpZiAoYm9keS5hdHRyTWFwcyl7XG4gICAgdGhpcy5yZWFkQXR0ck1hcHMoc3RyZWFtLCBib2R5LmF0dHJNYXBzKTtcbiAgfVxufTtcblxuQ1RNLlJlYWRlck1HMS5wcm90b3R5cGUucmVhZEluZGljZXMgPSBmdW5jdGlvbihzdHJlYW0sIGluZGljZXMpe1xuICBzdHJlYW0ucmVhZEludDMyKCk7IC8vbWFnaWMgXCJJTkRYXCJcbiAgc3RyZWFtLnJlYWRJbnQzMigpOyAvL3BhY2tlZCBzaXplXG5cbiAgdmFyIGludGVybGVhdmVkID0gbmV3IENUTS5JbnRlcmxlYXZlZFN0cmVhbShpbmRpY2VzLCAzKTtcbiAgTFpNQS5kZWNvbXByZXNzKHN0cmVhbSwgc3RyZWFtLCBpbnRlcmxlYXZlZCwgaW50ZXJsZWF2ZWQuZGF0YS5sZW5ndGgpO1xuXG4gIENUTS5yZXN0b3JlSW5kaWNlcyhpbmRpY2VzLCBpbmRpY2VzLmxlbmd0aCk7XG59O1xuXG5DVE0uUmVhZGVyTUcxLnByb3RvdHlwZS5yZWFkVmVydGljZXMgPSBmdW5jdGlvbihzdHJlYW0sIHZlcnRpY2VzKXtcbiAgc3RyZWFtLnJlYWRJbnQzMigpOyAvL21hZ2ljIFwiVkVSVFwiXG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9wYWNrZWQgc2l6ZVxuXG4gIHZhciBpbnRlcmxlYXZlZCA9IG5ldyBDVE0uSW50ZXJsZWF2ZWRTdHJlYW0odmVydGljZXMsIDEpO1xuICBMWk1BLmRlY29tcHJlc3Moc3RyZWFtLCBzdHJlYW0sIGludGVybGVhdmVkLCBpbnRlcmxlYXZlZC5kYXRhLmxlbmd0aCk7XG59O1xuXG5DVE0uUmVhZGVyTUcxLnByb3RvdHlwZS5yZWFkTm9ybWFscyA9IGZ1bmN0aW9uKHN0cmVhbSwgbm9ybWFscyl7XG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIk5PUk1cIlxuICBzdHJlYW0ucmVhZEludDMyKCk7IC8vcGFja2VkIHNpemVcblxuICB2YXIgaW50ZXJsZWF2ZWQgPSBuZXcgQ1RNLkludGVybGVhdmVkU3RyZWFtKG5vcm1hbHMsIDMpO1xuICBMWk1BLmRlY29tcHJlc3Moc3RyZWFtLCBzdHJlYW0sIGludGVybGVhdmVkLCBpbnRlcmxlYXZlZC5kYXRhLmxlbmd0aCk7XG59O1xuXG5DVE0uUmVhZGVyTUcxLnByb3RvdHlwZS5yZWFkVVZNYXBzID0gZnVuY3Rpb24oc3RyZWFtLCB1dk1hcHMpe1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgdXZNYXBzLmxlbmd0aDsgKysgaSl7XG4gICAgc3RyZWFtLnJlYWRJbnQzMigpOyAvL21hZ2ljIFwiVEVYQ1wiXG5cbiAgICB1dk1hcHNbaV0ubmFtZSA9IHN0cmVhbS5yZWFkU3RyaW5nKCk7XG4gICAgdXZNYXBzW2ldLmZpbGVuYW1lID0gc3RyZWFtLnJlYWRTdHJpbmcoKTtcblxuICAgIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9wYWNrZWQgc2l6ZVxuXG4gICAgdmFyIGludGVybGVhdmVkID0gbmV3IENUTS5JbnRlcmxlYXZlZFN0cmVhbSh1dk1hcHNbaV0udXYsIDIpO1xuICAgIExaTUEuZGVjb21wcmVzcyhzdHJlYW0sIHN0cmVhbSwgaW50ZXJsZWF2ZWQsIGludGVybGVhdmVkLmRhdGEubGVuZ3RoKTtcbiAgfVxufTtcblxuQ1RNLlJlYWRlck1HMS5wcm90b3R5cGUucmVhZEF0dHJNYXBzID0gZnVuY3Rpb24oc3RyZWFtLCBhdHRyTWFwcyl7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBhdHRyTWFwcy5sZW5ndGg7ICsrIGkpe1xuICAgIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIkFUVFJcIlxuXG4gICAgYXR0ck1hcHNbaV0ubmFtZSA9IHN0cmVhbS5yZWFkU3RyaW5nKCk7XG5cbiAgICBzdHJlYW0ucmVhZEludDMyKCk7IC8vcGFja2VkIHNpemVcblxuICAgIHZhciBpbnRlcmxlYXZlZCA9IG5ldyBDVE0uSW50ZXJsZWF2ZWRTdHJlYW0oYXR0ck1hcHNbaV0uYXR0ciwgNCk7XG4gICAgTFpNQS5kZWNvbXByZXNzKHN0cmVhbSwgc3RyZWFtLCBpbnRlcmxlYXZlZCwgaW50ZXJsZWF2ZWQuZGF0YS5sZW5ndGgpO1xuICB9XG59O1xuXG5DVE0uUmVhZGVyTUcyID0gZnVuY3Rpb24oKXtcbn07XG5cbkNUTS5SZWFkZXJNRzIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzdHJlYW0sIGJvZHkpe1xuICB0aGlzLk1HMkhlYWRlciA9IG5ldyBDVE0uRmlsZU1HMkhlYWRlcihzdHJlYW0pO1xuXG4gIHRoaXMucmVhZFZlcnRpY2VzKHN0cmVhbSwgYm9keS52ZXJ0aWNlcyk7XG4gIHRoaXMucmVhZEluZGljZXMoc3RyZWFtLCBib2R5LmluZGljZXMpO1xuXG4gIGlmIChib2R5Lm5vcm1hbHMpe1xuICAgIHRoaXMucmVhZE5vcm1hbHMoc3RyZWFtLCBib2R5KTtcbiAgfVxuICBpZiAoYm9keS51dk1hcHMpe1xuICAgIHRoaXMucmVhZFVWTWFwcyhzdHJlYW0sIGJvZHkudXZNYXBzKTtcbiAgfVxuICBpZiAoYm9keS5hdHRyTWFwcyl7XG4gICAgdGhpcy5yZWFkQXR0ck1hcHMoc3RyZWFtLCBib2R5LmF0dHJNYXBzKTtcbiAgfVxufTtcblxuQ1RNLlJlYWRlck1HMi5wcm90b3R5cGUucmVhZFZlcnRpY2VzID0gZnVuY3Rpb24oc3RyZWFtLCB2ZXJ0aWNlcyl7XG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIlZFUlRcIlxuICBzdHJlYW0ucmVhZEludDMyKCk7IC8vcGFja2VkIHNpemVcblxuICB2YXIgaW50ZXJsZWF2ZWQgPSBuZXcgQ1RNLkludGVybGVhdmVkU3RyZWFtKHZlcnRpY2VzLCAzKTtcbiAgTFpNQS5kZWNvbXByZXNzKHN0cmVhbSwgc3RyZWFtLCBpbnRlcmxlYXZlZCwgaW50ZXJsZWF2ZWQuZGF0YS5sZW5ndGgpO1xuXG4gIHZhciBncmlkSW5kaWNlcyA9IHRoaXMucmVhZEdyaWRJbmRpY2VzKHN0cmVhbSwgdmVydGljZXMpO1xuXG4gIENUTS5yZXN0b3JlVmVydGljZXModmVydGljZXMsIHRoaXMuTUcySGVhZGVyLCBncmlkSW5kaWNlcywgdGhpcy5NRzJIZWFkZXIudmVydGV4UHJlY2lzaW9uKTtcbn07XG5cbkNUTS5SZWFkZXJNRzIucHJvdG90eXBlLnJlYWRHcmlkSW5kaWNlcyA9IGZ1bmN0aW9uKHN0cmVhbSwgdmVydGljZXMpe1xuICBzdHJlYW0ucmVhZEludDMyKCk7IC8vbWFnaWMgXCJHSURYXCJcbiAgc3RyZWFtLnJlYWRJbnQzMigpOyAvL3BhY2tlZCBzaXplXG5cbiAgdmFyIGdyaWRJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCAvIDMpO1xuXG4gIHZhciBpbnRlcmxlYXZlZCA9IG5ldyBDVE0uSW50ZXJsZWF2ZWRTdHJlYW0oZ3JpZEluZGljZXMsIDEpO1xuICBMWk1BLmRlY29tcHJlc3Moc3RyZWFtLCBzdHJlYW0sIGludGVybGVhdmVkLCBpbnRlcmxlYXZlZC5kYXRhLmxlbmd0aCk7XG5cbiAgQ1RNLnJlc3RvcmVHcmlkSW5kaWNlcyhncmlkSW5kaWNlcywgZ3JpZEluZGljZXMubGVuZ3RoKTtcblxuICByZXR1cm4gZ3JpZEluZGljZXM7XG59O1xuXG5DVE0uUmVhZGVyTUcyLnByb3RvdHlwZS5yZWFkSW5kaWNlcyA9IGZ1bmN0aW9uKHN0cmVhbSwgaW5kaWNlcyl7XG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIklORFhcIlxuICBzdHJlYW0ucmVhZEludDMyKCk7IC8vcGFja2VkIHNpemVcblxuICB2YXIgaW50ZXJsZWF2ZWQgPSBuZXcgQ1RNLkludGVybGVhdmVkU3RyZWFtKGluZGljZXMsIDMpO1xuICBMWk1BLmRlY29tcHJlc3Moc3RyZWFtLCBzdHJlYW0sIGludGVybGVhdmVkLCBpbnRlcmxlYXZlZC5kYXRhLmxlbmd0aCk7XG5cbiAgQ1RNLnJlc3RvcmVJbmRpY2VzKGluZGljZXMsIGluZGljZXMubGVuZ3RoKTtcbn07XG5cbkNUTS5SZWFkZXJNRzIucHJvdG90eXBlLnJlYWROb3JtYWxzID0gZnVuY3Rpb24oc3RyZWFtLCBib2R5KXtcbiAgc3RyZWFtLnJlYWRJbnQzMigpOyAvL21hZ2ljIFwiTk9STVwiXG4gIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9wYWNrZWQgc2l6ZVxuXG4gIHZhciBpbnRlcmxlYXZlZCA9IG5ldyBDVE0uSW50ZXJsZWF2ZWRTdHJlYW0oYm9keS5ub3JtYWxzLCAzKTtcbiAgTFpNQS5kZWNvbXByZXNzKHN0cmVhbSwgc3RyZWFtLCBpbnRlcmxlYXZlZCwgaW50ZXJsZWF2ZWQuZGF0YS5sZW5ndGgpO1xuXG4gIHZhciBzbW9vdGggPSBDVE0uY2FsY1Ntb290aE5vcm1hbHMoYm9keS5pbmRpY2VzLCBib2R5LnZlcnRpY2VzKTtcblxuICBDVE0ucmVzdG9yZU5vcm1hbHMoYm9keS5ub3JtYWxzLCBzbW9vdGgsIHRoaXMuTUcySGVhZGVyLm5vcm1hbFByZWNpc2lvbik7XG59O1xuXG5DVE0uUmVhZGVyTUcyLnByb3RvdHlwZS5yZWFkVVZNYXBzID0gZnVuY3Rpb24oc3RyZWFtLCB1dk1hcHMpe1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgdXZNYXBzLmxlbmd0aDsgKysgaSl7XG4gICAgc3RyZWFtLnJlYWRJbnQzMigpOyAvL21hZ2ljIFwiVEVYQ1wiXG5cbiAgICB1dk1hcHNbaV0ubmFtZSA9IHN0cmVhbS5yZWFkU3RyaW5nKCk7XG4gICAgdXZNYXBzW2ldLmZpbGVuYW1lID0gc3RyZWFtLnJlYWRTdHJpbmcoKTtcblxuICAgIHZhciBwcmVjaXNpb24gPSBzdHJlYW0ucmVhZEZsb2F0MzIoKTtcblxuICAgIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9wYWNrZWQgc2l6ZVxuXG4gICAgdmFyIGludGVybGVhdmVkID0gbmV3IENUTS5JbnRlcmxlYXZlZFN0cmVhbSh1dk1hcHNbaV0udXYsIDIpO1xuICAgIExaTUEuZGVjb21wcmVzcyhzdHJlYW0sIHN0cmVhbSwgaW50ZXJsZWF2ZWQsIGludGVybGVhdmVkLmRhdGEubGVuZ3RoKTtcblxuICAgIENUTS5yZXN0b3JlTWFwKHV2TWFwc1tpXS51diwgMiwgcHJlY2lzaW9uKTtcbiAgfVxufTtcblxuQ1RNLlJlYWRlck1HMi5wcm90b3R5cGUucmVhZEF0dHJNYXBzID0gZnVuY3Rpb24oc3RyZWFtLCBhdHRyTWFwcyl7XG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCBhdHRyTWFwcy5sZW5ndGg7ICsrIGkpe1xuICAgIHN0cmVhbS5yZWFkSW50MzIoKTsgLy9tYWdpYyBcIkFUVFJcIlxuXG4gICAgYXR0ck1hcHNbaV0ubmFtZSA9IHN0cmVhbS5yZWFkU3RyaW5nKCk7XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gc3RyZWFtLnJlYWRGbG9hdDMyKCk7XG5cbiAgICBzdHJlYW0ucmVhZEludDMyKCk7IC8vcGFja2VkIHNpemVcblxuICAgIHZhciBpbnRlcmxlYXZlZCA9IG5ldyBDVE0uSW50ZXJsZWF2ZWRTdHJlYW0oYXR0ck1hcHNbaV0uYXR0ciwgNCk7XG4gICAgTFpNQS5kZWNvbXByZXNzKHN0cmVhbSwgc3RyZWFtLCBpbnRlcmxlYXZlZCwgaW50ZXJsZWF2ZWQuZGF0YS5sZW5ndGgpO1xuXG4gICAgQ1RNLnJlc3RvcmVNYXAoYXR0ck1hcHNbaV0uYXR0ciwgNCwgcHJlY2lzaW9uKTtcbiAgfVxufTtcblxuQ1RNLnJlc3RvcmVJbmRpY2VzID0gZnVuY3Rpb24oaW5kaWNlcywgbGVuKXtcbiAgdmFyIGkgPSAzO1xuICBpZiAobGVuID4gMCl7XG4gICAgaW5kaWNlc1syXSArPSBpbmRpY2VzWzBdO1xuICB9XG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IDMpe1xuICAgIGluZGljZXNbaV0gKz0gaW5kaWNlc1tpIC0gM107XG5cbiAgICBpZiAoaW5kaWNlc1tpXSA9PT0gaW5kaWNlc1tpIC0gM10pe1xuICAgICAgaW5kaWNlc1tpICsgMV0gKz0gaW5kaWNlc1tpIC0gMl07XG4gICAgfWVsc2V7XG4gICAgICBpbmRpY2VzW2kgKyAxXSArPSBpbmRpY2VzW2ldO1xuICAgIH1cblxuICAgIGluZGljZXNbaSArIDJdICs9IGluZGljZXNbaV07XG4gIH1cbn07XG5cbkNUTS5yZXN0b3JlR3JpZEluZGljZXMgPSBmdW5jdGlvbihncmlkSW5kaWNlcywgbGVuKXtcbiAgdmFyIGkgPSAxO1xuICBmb3IgKDsgaSA8IGxlbjsgKysgaSl7XG4gICAgZ3JpZEluZGljZXNbaV0gKz0gZ3JpZEluZGljZXNbaSAtIDFdO1xuICB9XG59O1xuXG5DVE0ucmVzdG9yZVZlcnRpY2VzID0gZnVuY3Rpb24odmVydGljZXMsIGdyaWQsIGdyaWRJbmRpY2VzLCBwcmVjaXNpb24pe1xuICB2YXIgZ3JpZElkeCwgZGVsdGEsIHgsIHksIHosXG4gICAgICBpbnRWZXJ0aWNlcyA9IG5ldyBVaW50MzJBcnJheSh2ZXJ0aWNlcy5idWZmZXIsIHZlcnRpY2VzLmJ5dGVPZmZzZXQsIHZlcnRpY2VzLmxlbmd0aCksXG4gICAgICB5ZGl2ID0gZ3JpZC5kaXZ4LCB6ZGl2ID0geWRpdiAqIGdyaWQuZGl2eSxcbiAgICAgIHByZXZHcmlkSWR4ID0gMHg3ZmZmZmZmZiwgcHJldkRlbHRhID0gMCxcbiAgICAgIGkgPSAwLCBqID0gMCwgbGVuID0gZ3JpZEluZGljZXMubGVuZ3RoO1xuXG4gIGZvciAoOyBpIDwgbGVuOyBqICs9IDMpe1xuICAgIHggPSBncmlkSWR4ID0gZ3JpZEluZGljZXNbaSArK107XG5cbiAgICB6ID0gfn4oeCAvIHpkaXYpO1xuICAgIHggLT0gfn4oeiAqIHpkaXYpO1xuICAgIHkgPSB+fih4IC8geWRpdik7XG4gICAgeCAtPSB+fih5ICogeWRpdik7XG5cbiAgICBkZWx0YSA9IGludFZlcnRpY2VzW2pdO1xuICAgIGlmIChncmlkSWR4ID09PSBwcmV2R3JpZElkeCl7XG4gICAgICBkZWx0YSArPSBwcmV2RGVsdGE7XG4gICAgfVxuXG4gICAgdmVydGljZXNbal0gICAgID0gZ3JpZC5sb3dlckJvdW5keCArXG4gICAgICB4ICogZ3JpZC5zaXpleCArIHByZWNpc2lvbiAqIGRlbHRhO1xuICAgIHZlcnRpY2VzW2ogKyAxXSA9IGdyaWQubG93ZXJCb3VuZHkgK1xuICAgICAgeSAqIGdyaWQuc2l6ZXkgKyBwcmVjaXNpb24gKiBpbnRWZXJ0aWNlc1tqICsgMV07XG4gICAgdmVydGljZXNbaiArIDJdID0gZ3JpZC5sb3dlckJvdW5keiArXG4gICAgICB6ICogZ3JpZC5zaXpleiArIHByZWNpc2lvbiAqIGludFZlcnRpY2VzW2ogKyAyXTtcblxuICAgIHByZXZHcmlkSWR4ID0gZ3JpZElkeDtcbiAgICBwcmV2RGVsdGEgPSBkZWx0YTtcbiAgfVxufTtcblxuQ1RNLnJlc3RvcmVOb3JtYWxzID0gZnVuY3Rpb24obm9ybWFscywgc21vb3RoLCBwcmVjaXNpb24pe1xuICB2YXIgcm8sIHBoaSwgdGhldGEsIHNpblBoaSxcbiAgICAgIG54LCBueSwgbnosIGJ5LCBieiwgbGVuLFxuICAgICAgaW50Tm9ybWFscyA9IG5ldyBVaW50MzJBcnJheShub3JtYWxzLmJ1ZmZlciwgbm9ybWFscy5ieXRlT2Zmc2V0LCBub3JtYWxzLmxlbmd0aCksXG4gICAgICBpID0gMCwgayA9IG5vcm1hbHMubGVuZ3RoLFxuICAgICAgUElfRElWXzIgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MyAqIDAuNTtcblxuICBmb3IgKDsgaSA8IGs7IGkgKz0gMyl7XG4gICAgcm8gPSBpbnROb3JtYWxzW2ldICogcHJlY2lzaW9uO1xuICAgIHBoaSA9IGludE5vcm1hbHNbaSArIDFdO1xuXG4gICAgaWYgKHBoaSA9PT0gMCl7XG4gICAgICBub3JtYWxzW2ldICAgICA9IHNtb290aFtpXSAgICAgKiBybztcbiAgICAgIG5vcm1hbHNbaSArIDFdID0gc21vb3RoW2kgKyAxXSAqIHJvO1xuICAgICAgbm9ybWFsc1tpICsgMl0gPSBzbW9vdGhbaSArIDJdICogcm87XG4gICAgfWVsc2V7XG5cbiAgICAgIGlmIChwaGkgPD0gNCl7XG4gICAgICAgIHRoZXRhID0gKGludE5vcm1hbHNbaSArIDJdIC0gMikgKiBQSV9ESVZfMjtcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGV0YSA9ICggKGludE5vcm1hbHNbaSArIDJdICogNCAvIHBoaSkgLSAyKSAqIFBJX0RJVl8yO1xuICAgICAgfVxuXG4gICAgICBwaGkgKj0gcHJlY2lzaW9uICogUElfRElWXzI7XG4gICAgICBzaW5QaGkgPSBybyAqIE1hdGguc2luKHBoaSk7XG5cbiAgICAgIG54ID0gc2luUGhpICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgbnkgPSBzaW5QaGkgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICBueiA9IHJvICogTWF0aC5jb3MocGhpKTtcblxuICAgICAgYnogPSBzbW9vdGhbaSArIDFdO1xuICAgICAgYnkgPSBzbW9vdGhbaV0gLSBzbW9vdGhbaSArIDJdO1xuXG4gICAgICBsZW4gPSBNYXRoLnNxcnQoMiAqIGJ6ICogYnogKyBieSAqIGJ5KTtcbiAgICAgIGlmIChsZW4gPiAxZS0yMCl7XG4gICAgICAgIGJ5IC89IGxlbjtcbiAgICAgICAgYnogLz0gbGVuO1xuICAgICAgfVxuXG4gICAgICBub3JtYWxzW2ldICAgICA9IHNtb290aFtpXSAgICAgKiBueiArXG4gICAgICAgIChzbW9vdGhbaSArIDFdICogYnogLSBzbW9vdGhbaSArIDJdICogYnkpICogbnkgLSBieiAqIG54O1xuICAgICAgbm9ybWFsc1tpICsgMV0gPSBzbW9vdGhbaSArIDFdICogbnogLVxuICAgICAgICAoc21vb3RoW2kgKyAyXSAgICAgICsgc21vb3RoW2ldICAgKSAqIGJ6ICAqIG55ICsgYnkgKiBueDtcbiAgICAgIG5vcm1hbHNbaSArIDJdID0gc21vb3RoW2kgKyAyXSAqIG56ICtcbiAgICAgICAgKHNtb290aFtpXSAgICAgKiBieSArIHNtb290aFtpICsgMV0gKiBieikgKiBueSArIGJ6ICogbng7XG4gICAgfVxuICB9XG59O1xuXG5DVE0ucmVzdG9yZU1hcCA9IGZ1bmN0aW9uKG1hcCwgY291bnQsIHByZWNpc2lvbil7XG4gIHZhciBkZWx0YSwgdmFsdWUsXG4gICAgICBpbnRNYXAgPSBuZXcgVWludDMyQXJyYXkobWFwLmJ1ZmZlciwgbWFwLmJ5dGVPZmZzZXQsIG1hcC5sZW5ndGgpLFxuICAgICAgaSA9IDAsIGosIGxlbiA9IG1hcC5sZW5ndGg7XG5cbiAgZm9yICg7IGkgPCBjb3VudDsgKysgaSl7XG4gICAgZGVsdGEgPSAwO1xuXG4gICAgZm9yIChqID0gaTsgaiA8IGxlbjsgaiArPSBjb3VudCl7XG4gICAgICB2YWx1ZSA9IGludE1hcFtqXTtcblxuICAgICAgZGVsdGEgKz0gdmFsdWUgJiAxPyAtKCAodmFsdWUgKyAxKSA+PiAxKTogdmFsdWUgPj4gMTtcblxuICAgICAgbWFwW2pdID0gZGVsdGEgKiBwcmVjaXNpb247XG4gICAgfVxuICB9XG59O1xuXG5DVE0uY2FsY1Ntb290aE5vcm1hbHMgPSBmdW5jdGlvbihpbmRpY2VzLCB2ZXJ0aWNlcyl7XG4gIHZhciBzbW9vdGggPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCksXG4gICAgICBpbmR4LCBpbmR5LCBpbmR6LCBueCwgbnksIG56LFxuICAgICAgdjF4LCB2MXksIHYxeiwgdjJ4LCB2MnksIHYyeiwgbGVuLFxuICAgICAgaSwgaztcblxuICBmb3IgKGkgPSAwLCBrID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBrOyl7XG4gICAgaW5keCA9IGluZGljZXNbaSArK10gKiAzO1xuICAgIGluZHkgPSBpbmRpY2VzW2kgKytdICogMztcbiAgICBpbmR6ID0gaW5kaWNlc1tpICsrXSAqIDM7XG5cbiAgICB2MXggPSB2ZXJ0aWNlc1tpbmR5XSAgICAgLSB2ZXJ0aWNlc1tpbmR4XTtcbiAgICB2MnggPSB2ZXJ0aWNlc1tpbmR6XSAgICAgLSB2ZXJ0aWNlc1tpbmR4XTtcbiAgICB2MXkgPSB2ZXJ0aWNlc1tpbmR5ICsgMV0gLSB2ZXJ0aWNlc1tpbmR4ICsgMV07XG4gICAgdjJ5ID0gdmVydGljZXNbaW5keiArIDFdIC0gdmVydGljZXNbaW5keCArIDFdO1xuICAgIHYxeiA9IHZlcnRpY2VzW2luZHkgKyAyXSAtIHZlcnRpY2VzW2luZHggKyAyXTtcbiAgICB2MnogPSB2ZXJ0aWNlc1tpbmR6ICsgMl0gLSB2ZXJ0aWNlc1tpbmR4ICsgMl07XG5cbiAgICBueCA9IHYxeSAqIHYyeiAtIHYxeiAqIHYyeTtcbiAgICBueSA9IHYxeiAqIHYyeCAtIHYxeCAqIHYyejtcbiAgICBueiA9IHYxeCAqIHYyeSAtIHYxeSAqIHYyeDtcblxuICAgIGxlbiA9IE1hdGguc3FydChueCAqIG54ICsgbnkgKiBueSArIG56ICogbnopO1xuICAgIGlmIChsZW4gPiAxZS0xMCl7XG4gICAgICBueCAvPSBsZW47XG4gICAgICBueSAvPSBsZW47XG4gICAgICBueiAvPSBsZW47XG4gICAgfVxuXG4gICAgc21vb3RoW2luZHhdICAgICArPSBueDtcbiAgICBzbW9vdGhbaW5keCArIDFdICs9IG55O1xuICAgIHNtb290aFtpbmR4ICsgMl0gKz0gbno7XG4gICAgc21vb3RoW2luZHldICAgICArPSBueDtcbiAgICBzbW9vdGhbaW5keSArIDFdICs9IG55O1xuICAgIHNtb290aFtpbmR5ICsgMl0gKz0gbno7XG4gICAgc21vb3RoW2luZHpdICAgICArPSBueDtcbiAgICBzbW9vdGhbaW5keiArIDFdICs9IG55O1xuICAgIHNtb290aFtpbmR6ICsgMl0gKz0gbno7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBrID0gc21vb3RoLmxlbmd0aDsgaSA8IGs7IGkgKz0gMyl7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHNtb290aFtpXSAqIHNtb290aFtpXSArXG4gICAgICBzbW9vdGhbaSArIDFdICogc21vb3RoW2kgKyAxXSArXG4gICAgICBzbW9vdGhbaSArIDJdICogc21vb3RoW2kgKyAyXSk7XG5cbiAgICBpZihsZW4gPiAxZS0xMCl7XG4gICAgICBzbW9vdGhbaV0gICAgIC89IGxlbjtcbiAgICAgIHNtb290aFtpICsgMV0gLz0gbGVuO1xuICAgICAgc21vb3RoW2kgKyAyXSAvPSBsZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNtb290aDtcbn07XG5cbkNUTS5pc0xpdHRsZUVuZGlhbiA9IChmdW5jdGlvbigpe1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDIpLFxuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpLFxuICAgICAgaW50cyA9IG5ldyBVaW50MTZBcnJheShidWZmZXIpO1xuXG4gIGJ5dGVzWzBdID0gMTtcblxuICByZXR1cm4gaW50c1swXSA9PT0gMTtcbn0oKSk7XG5cbkNUTS5JbnRlcmxlYXZlZFN0cmVhbSA9IGZ1bmN0aW9uKGRhdGEsIGNvdW50KXtcbiAgdGhpcy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgdGhpcy5vZmZzZXQgPSBDVE0uaXNMaXR0bGVFbmRpYW4/IDM6IDA7XG4gIHRoaXMuY291bnQgPSBjb3VudCAqIDQ7XG4gIHRoaXMubGVuID0gdGhpcy5kYXRhLmxlbmd0aDtcbn07XG5cbkNUTS5JbnRlcmxlYXZlZFN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlID0gZnVuY3Rpb24odmFsdWUpe1xuICB0aGlzLmRhdGFbdGhpcy5vZmZzZXRdID0gdmFsdWU7XG5cbiAgdGhpcy5vZmZzZXQgKz0gdGhpcy5jb3VudDtcbiAgaWYgKHRoaXMub2Zmc2V0ID49IHRoaXMubGVuKXtcblxuICAgIHRoaXMub2Zmc2V0IC09IHRoaXMubGVuIC0gNDtcbiAgICBpZiAodGhpcy5vZmZzZXQgPj0gdGhpcy5jb3VudCl7XG5cbiAgICAgIHRoaXMub2Zmc2V0IC09IHRoaXMuY291bnQgKyAoQ1RNLmlzTGl0dGxlRW5kaWFuPyAxOiAtMSk7XG4gICAgfVxuICB9XG59O1xuXG5DVE0uU3RyZWFtID0gZnVuY3Rpb24oZGF0YSl7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuICB0aGlzLm9mZnNldCA9IDA7XG59O1xuXG5DVE0uU3RyZWFtLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldDtcbn07XG5cbkNUTS5TdHJlYW0ucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG59O1xuXG5DVE0uU3RyZWFtLnByb3RvdHlwZS5UV09fUE9XX01JTlVTMjMgPSBNYXRoLnBvdygyLCAtMjMpO1xuXG5DVE0uU3RyZWFtLnByb3RvdHlwZS5UV09fUE9XX01JTlVTMTI2ID0gTWF0aC5wb3coMiwgLTEyNik7XG5cbkNUTS5TdHJlYW0ucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLm9mZnNldCArK107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMub2Zmc2V0ICsrKSAmIDB4ZmY7XG4gICAgfVxufTtcblxuQ1RNLlN0cmVhbS5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSB0aGlzLnJlYWRCeXRlKCk7XG4gIGkgfD0gdGhpcy5yZWFkQnl0ZSgpIDw8IDg7XG4gIGkgfD0gdGhpcy5yZWFkQnl0ZSgpIDw8IDE2O1xuICByZXR1cm4gaSB8ICh0aGlzLnJlYWRCeXRlKCkgPDwgMjQpO1xufTtcblxuQ1RNLlN0cmVhbS5wcm90b3R5cGUucmVhZEZsb2F0MzIgPSBmdW5jdGlvbigpe1xuICB2YXIgbSA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgbSArPSB0aGlzLnJlYWRCeXRlKCkgPDwgODtcblxuICB2YXIgYjEgPSB0aGlzLnJlYWRCeXRlKCk7XG4gIHZhciBiMiA9IHRoaXMucmVhZEJ5dGUoKTtcblxuICBtICs9IChiMSAmIDB4N2YpIDw8IDE2O1xuICB2YXIgZSA9ICggKGIyICYgMHg3ZikgPDwgMSkgfCAoIChiMSAmIDB4ODApID4+PiA3KTtcbiAgdmFyIHMgPSBiMiAmIDB4ODA/IC0xOiAxO1xuXG4gIGlmIChlID09PSAyNTUpe1xuICAgIHJldHVybiBtICE9PSAwPyBOYU46IHMgKiBJbmZpbml0eTtcbiAgfVxuICBpZiAoZSA+IDApe1xuICAgIHJldHVybiBzICogKDEgKyAobSAqIHRoaXMuVFdPX1BPV19NSU5VUzIzKSApICogTWF0aC5wb3coMiwgZSAtIDEyNyk7XG4gIH1cbiAgaWYgKG0gIT09IDApe1xuICAgIHJldHVybiBzICogbSAqIHRoaXMuVFdPX1BPV19NSU5VUzEyNjtcbiAgfVxuICByZXR1cm4gcyAqIDA7XG59O1xuXG5DVE0uU3RyZWFtLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIGxlbiA9IHRoaXMucmVhZEludDMyKCk7XG5cbiAgdGhpcy5vZmZzZXQgKz0gbGVuO1xuICBpZiAodGhpcy5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdmFyIHBvcyA9IHRoaXMub2Zmc2V0IC0gbGVuO1xuICAgICAgdmFyIGJ1ZiA9IFwiXCI7XG4gICAgICBmb3IgKHZhciBpID0gcG9zOyBpIDwgcG9zK2xlbjsgKytpKSB7XG4gICAgICAgICAgYnVmICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5kYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLnN1YnN0cih0aGlzLm9mZnNldCAtIGxlbiwgbGVuKTtcbiAgfVxufTtcblxuQ1RNLlN0cmVhbS5wcm90b3R5cGUucmVhZEFycmF5SW50MzIgPSBmdW5jdGlvbihhcnJheSl7XG4gIHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlKGkgPCBsZW4pe1xuICAgIGFycmF5W2kgKytdID0gdGhpcy5yZWFkSW50MzIoKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn07XG5cbkNUTS5TdHJlYW0ucHJvdG90eXBlLnJlYWRBcnJheUZsb2F0MzIgPSBmdW5jdGlvbihhcnJheSl7XG4gIHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlKGkgPCBsZW4pe1xuICAgIGFycmF5W2kgKytdID0gdGhpcy5yZWFkRmxvYXQzMigpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgQ1RNID0gcmVxdWlyZShcIi4vY3RtXCIpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHR0cnkge1xuXHRcdHZhciBzdHJlYW0gPSBuZXcgQ1RNLlN0cmVhbShkYXRhKTtcblx0XHR2YXIgZmlsZSA9IG5ldyBDVE0uRmlsZShzdHJlYW0pO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHByb2Nlc3MgT3BlbkNUTSBmaWxlLlwiKTtcblx0fVxuXG5cdHZhciBpbmRleCA9IG5ldyBJbnQzMkFycmF5KGZpbGUuYm9keS5pbmRpY2VzLmJ1ZmZlciwgZmlsZS5ib2R5LmluZGljZXMuYnl0ZU9mZnNldCwgZmlsZS5ib2R5LmluZGljZXMubGVuZ3RoKTtcblx0dmFyIHBvc2l0aW9uID0gZmlsZS5ib2R5LnZlcnRpY2VzO1xuXHR2YXIgbm9ybWFsICA9IGZpbGUuYm9keS5ub3JtYWxzO1xuXHR2YXIgdGV4Y29vcmQgPSBmaWxlLmJvZHkudXZNYXBzID8gZmlsZS5ib2R5LnV2TWFwc1swXS51diA6IHVuZGVmaW5lZDtcblx0dmFyIHRhbmdlbnQgPSBleHRyYWN0QXR0cmlidXRlKGZpbGUsIFwidGFuZ2VudFwiKTtcblx0dmFyIGNvbG9yID0gZXh0cmFjdEF0dHJpYnV0ZShmaWxlLCBcImNvbG9yXCIpO1xuXHRyZXR1cm4ge1xuXHRcdGluZGV4OiBpbmRleCAsXG5cdFx0cG9zaXRpb246IHBvc2l0aW9uLFxuXHRcdG5vcm1hbDogbm9ybWFsLFxuXHRcdHRleGNvb3JkOiB0ZXhjb29yZCxcblx0XHR0YW5nZW50OiB0YW5nZW50ID8gcmVtb3ZlRm91ckJ5dGVQYWRkaW5nKHRhbmdlbnQpIDogdW5kZWZpbmVkLFxuXHRcdGNvbG9yOiBjb2xvclxuXHR9O1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QXR0cmlidXRlKGZpbGUsIGF0dHJpYnV0ZU5hbWUpIHtcblx0aWYgKCFmaWxlLmJvZHkuYXR0ck1hcHMpXG5cdFx0cmV0dXJuO1xuXG5cdGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGZpbGUuYm9keS5hdHRyTWFwcy5sZW5ndGg7ICsraWR4KVxuXHRcdGlmIChmaWxlLmJvZHkuYXR0ck1hcHNbaWR4XS5uYW1lID09PSBhdHRyaWJ1dGVOYW1lKVxuXHRcdFx0cmV0dXJuIGZpbGUuYm9keS5hdHRyTWFwc1tpZHhdLmF0dHI7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZvdXJCeXRlUGFkZGluZyhwYWRkZWREYXRhKSB7XG5cdHZhciBkYXRhV2l0aG91dFBhZGRpbmcgPSBuZXcgcGFkZGVkRGF0YS5jb25zdHJ1Y3RvcihwYWRkZWREYXRhLmxlbmd0aCAvIDQgKiAzKTtcblx0Zm9yICh2YXIgcGFkZGVkSWR4ID0gMCwgaWR4ID0gMDsgcGFkZGVkSWR4IDwgcGFkZGVkRGF0YS5sZW5ndGg7IHBhZGRlZElkeCArPSA0LCBpZHggKz0gMykge1xuXHRcdGRhdGFXaXRob3V0UGFkZGluZ1tpZHhdID0gcGFkZGVkRGF0YVtwYWRkZWRJZHhdO1xuXHRcdGRhdGFXaXRob3V0UGFkZGluZ1tpZHggKyAxXSA9IHBhZGRlZERhdGFbcGFkZGVkSWR4ICsgMV07XG5cdFx0ZGF0YVdpdGhvdXRQYWRkaW5nW2lkeCArIDJdID0gcGFkZGVkRGF0YVtwYWRkZWRJZHggKyAyXTtcblx0fVxuXG5cdHJldHVybiBkYXRhV2l0aG91dFBhZGRpbmc7XG59XG4iLCJcbnZhciBMWk1BID0gbW9kdWxlLmV4cG9ydHM7XG5cbkxaTUEuT3V0V2luZG93ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5fd2luZG93U2l6ZSA9IDA7XG59O1xuXG5MWk1BLk91dFdpbmRvdy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24od2luZG93U2l6ZSl7XG4gIGlmICggKCF0aGlzLl9idWZmZXIpIHx8ICh0aGlzLl93aW5kb3dTaXplICE9PSB3aW5kb3dTaXplKSApe1xuICAgIHRoaXMuX2J1ZmZlciA9IFtdO1xuICB9XG4gIHRoaXMuX3dpbmRvd1NpemUgPSB3aW5kb3dTaXplO1xuICB0aGlzLl9wb3MgPSAwO1xuICB0aGlzLl9zdHJlYW1Qb3MgPSAwO1xufTtcblxuTFpNQS5PdXRXaW5kb3cucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNpemUgPSB0aGlzLl9wb3MgLSB0aGlzLl9zdHJlYW1Qb3M7XG4gIGlmIChzaXplICE9PSAwKXtcbiAgICB3aGlsZShzaXplIC0tKXtcbiAgICAgIHRoaXMuX3N0cmVhbS53cml0ZUJ5dGUodGhpcy5fYnVmZmVyW3RoaXMuX3N0cmVhbVBvcyArK10pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcG9zID49IHRoaXMuX3dpbmRvd1NpemUpe1xuICAgICAgdGhpcy5fcG9zID0gMDtcbiAgICB9XG4gICAgdGhpcy5fc3RyZWFtUG9zID0gdGhpcy5fcG9zO1xuICB9XG59O1xuXG5MWk1BLk91dFdpbmRvdy5wcm90b3R5cGUucmVsZWFzZVN0cmVhbSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZmx1c2goKTtcbiAgdGhpcy5fc3RyZWFtID0gbnVsbDtcbn07XG5cbkxaTUEuT3V0V2luZG93LnByb3RvdHlwZS5zZXRTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pe1xuICB0aGlzLnJlbGVhc2VTdHJlYW0oKTtcbiAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xufTtcblxuTFpNQS5PdXRXaW5kb3cucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihzb2xpZCl7XG4gIGlmICghc29saWQpe1xuICAgIHRoaXMuX3N0cmVhbVBvcyA9IDA7XG4gICAgdGhpcy5fcG9zID0gMDtcbiAgfVxufTtcblxuTFpNQS5PdXRXaW5kb3cucHJvdG90eXBlLmNvcHlCbG9jayA9IGZ1bmN0aW9uKGRpc3RhbmNlLCBsZW4pe1xuICB2YXIgcG9zID0gdGhpcy5fcG9zIC0gZGlzdGFuY2UgLSAxO1xuICBpZiAocG9zIDwgMCl7XG4gICAgcG9zICs9IHRoaXMuX3dpbmRvd1NpemU7XG4gIH1cbiAgd2hpbGUobGVuIC0tKXtcbiAgICBpZiAocG9zID49IHRoaXMuX3dpbmRvd1NpemUpe1xuICAgICAgcG9zID0gMDtcbiAgICB9XG4gICAgdGhpcy5fYnVmZmVyW3RoaXMuX3BvcyArK10gPSB0aGlzLl9idWZmZXJbcG9zICsrXTtcbiAgICBpZiAodGhpcy5fcG9zID49IHRoaXMuX3dpbmRvd1NpemUpe1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuTFpNQS5PdXRXaW5kb3cucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKXtcbiAgdGhpcy5fYnVmZmVyW3RoaXMuX3BvcyArK10gPSBiO1xuICBpZiAodGhpcy5fcG9zID49IHRoaXMuX3dpbmRvd1NpemUpe1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuTFpNQS5PdXRXaW5kb3cucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbihkaXN0YW5jZSl7XG4gIHZhciBwb3MgPSB0aGlzLl9wb3MgLSBkaXN0YW5jZSAtIDE7XG4gIGlmIChwb3MgPCAwKXtcbiAgICBwb3MgKz0gdGhpcy5fd2luZG93U2l6ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYnVmZmVyW3Bvc107XG59O1xuXG5MWk1BLlJhbmdlRGVjb2RlciA9IGZ1bmN0aW9uKCl7XG59O1xuXG5MWk1BLlJhbmdlRGVjb2Rlci5wcm90b3R5cGUuc2V0U3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKXtcbiAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xufTtcblxuTFpNQS5SYW5nZURlY29kZXIucHJvdG90eXBlLnJlbGVhc2VTdHJlYW0gPSBmdW5jdGlvbigpe1xuICB0aGlzLl9zdHJlYW0gPSBudWxsO1xufTtcblxuTFpNQS5SYW5nZURlY29kZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpe1xuICB2YXIgaSA9IDU7XG5cbiAgdGhpcy5fY29kZSA9IDA7XG4gIHRoaXMuX3JhbmdlID0gLTE7XG5cbiAgd2hpbGUoaSAtLSl7XG4gICAgdGhpcy5fY29kZSA9ICh0aGlzLl9jb2RlIDw8IDgpIHwgdGhpcy5fc3RyZWFtLnJlYWRCeXRlKCk7XG4gIH1cbn07XG5cbkxaTUEuUmFuZ2VEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVEaXJlY3RCaXRzID0gZnVuY3Rpb24obnVtVG90YWxCaXRzKXtcbiAgdmFyIHJlc3VsdCA9IDAsIGkgPSBudW1Ub3RhbEJpdHMsIHQ7XG5cbiAgd2hpbGUoaSAtLSl7XG4gICAgdGhpcy5fcmFuZ2UgPj4+PSAxO1xuICAgIHQgPSAodGhpcy5fY29kZSAtIHRoaXMuX3JhbmdlKSA+Pj4gMzE7XG4gICAgdGhpcy5fY29kZSAtPSB0aGlzLl9yYW5nZSAmICh0IC0gMSk7XG4gICAgcmVzdWx0ID0gKHJlc3VsdCA8PCAxKSB8ICgxIC0gdCk7XG5cbiAgICBpZiAoICh0aGlzLl9yYW5nZSAmIDB4ZmYwMDAwMDApID09PSAwKXtcbiAgICAgIHRoaXMuX2NvZGUgPSAodGhpcy5fY29kZSA8PCA4KSB8IHRoaXMuX3N0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgdGhpcy5fcmFuZ2UgPDw9IDg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkxaTUEuUmFuZ2VEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVCaXQgPSBmdW5jdGlvbihwcm9icywgaW5kZXgpe1xuICB2YXIgcHJvYiA9IHByb2JzW2luZGV4XSxcbiAgICAgIG5ld0JvdW5kID0gKHRoaXMuX3JhbmdlID4+PiAxMSkgKiBwcm9iO1xuXG4gIGlmICggKHRoaXMuX2NvZGUgXiAweDgwMDAwMDAwKSA8IChuZXdCb3VuZCBeIDB4ODAwMDAwMDApICl7XG4gICAgdGhpcy5fcmFuZ2UgPSBuZXdCb3VuZDtcbiAgICBwcm9ic1tpbmRleF0gKz0gKDIwNDggLSBwcm9iKSA+Pj4gNTtcbiAgICBpZiAoICh0aGlzLl9yYW5nZSAmIDB4ZmYwMDAwMDApID09PSAwKXtcbiAgICAgIHRoaXMuX2NvZGUgPSAodGhpcy5fY29kZSA8PCA4KSB8IHRoaXMuX3N0cmVhbS5yZWFkQnl0ZSgpO1xuICAgICAgdGhpcy5fcmFuZ2UgPDw9IDg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdGhpcy5fcmFuZ2UgLT0gbmV3Qm91bmQ7XG4gIHRoaXMuX2NvZGUgLT0gbmV3Qm91bmQ7XG4gIHByb2JzW2luZGV4XSAtPSBwcm9iID4+PiA1O1xuICBpZiAoICh0aGlzLl9yYW5nZSAmIDB4ZmYwMDAwMDApID09PSAwKXtcbiAgICB0aGlzLl9jb2RlID0gKHRoaXMuX2NvZGUgPDwgOCkgfCB0aGlzLl9zdHJlYW0ucmVhZEJ5dGUoKTtcbiAgICB0aGlzLl9yYW5nZSA8PD0gODtcbiAgfVxuICByZXR1cm4gMTtcbn07XG5cbkxaTUEuaW5pdEJpdE1vZGVscyA9IGZ1bmN0aW9uKHByb2JzLCBsZW4pe1xuICB3aGlsZShsZW4gLS0pe1xuICAgIHByb2JzW2xlbl0gPSAxMDI0O1xuICB9XG59O1xuXG5MWk1BLkJpdFRyZWVEZWNvZGVyID0gZnVuY3Rpb24obnVtQml0TGV2ZWxzKXtcbiAgdGhpcy5fbW9kZWxzID0gW107XG4gIHRoaXMuX251bUJpdExldmVscyA9IG51bUJpdExldmVscztcbn07XG5cbkxaTUEuQml0VHJlZURlY29kZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpe1xuICBMWk1BLmluaXRCaXRNb2RlbHModGhpcy5fbW9kZWxzLCAxIDw8IHRoaXMuX251bUJpdExldmVscyk7XG59O1xuXG5MWk1BLkJpdFRyZWVEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihyYW5nZURlY29kZXIpe1xuICB2YXIgbSA9IDEsIGkgPSB0aGlzLl9udW1CaXRMZXZlbHM7XG5cbiAgd2hpbGUoaSAtLSl7XG4gICAgbSA9IChtIDw8IDEpIHwgcmFuZ2VEZWNvZGVyLmRlY29kZUJpdCh0aGlzLl9tb2RlbHMsIG0pO1xuICB9XG4gIHJldHVybiBtIC0gKDEgPDwgdGhpcy5fbnVtQml0TGV2ZWxzKTtcbn07XG5cbkxaTUEuQml0VHJlZURlY29kZXIucHJvdG90eXBlLnJldmVyc2VEZWNvZGUgPSBmdW5jdGlvbihyYW5nZURlY29kZXIpe1xuICB2YXIgbSA9IDEsIHN5bWJvbCA9IDAsIGkgPSAwLCBiaXQ7XG5cbiAgZm9yICg7IGkgPCB0aGlzLl9udW1CaXRMZXZlbHM7ICsrIGkpe1xuICAgIGJpdCA9IHJhbmdlRGVjb2Rlci5kZWNvZGVCaXQodGhpcy5fbW9kZWxzLCBtKTtcbiAgICBtID0gKG0gPDwgMSkgfCBiaXQ7XG4gICAgc3ltYm9sIHw9IGJpdCA8PCBpO1xuICB9XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG5MWk1BLnJldmVyc2VEZWNvZGUyID0gZnVuY3Rpb24obW9kZWxzLCBzdGFydEluZGV4LCByYW5nZURlY29kZXIsIG51bUJpdExldmVscyl7XG4gIHZhciBtID0gMSwgc3ltYm9sID0gMCwgaSA9IDAsIGJpdDtcblxuICBmb3IgKDsgaSA8IG51bUJpdExldmVsczsgKysgaSl7XG4gICAgYml0ID0gcmFuZ2VEZWNvZGVyLmRlY29kZUJpdChtb2RlbHMsIHN0YXJ0SW5kZXggKyBtKTtcbiAgICBtID0gKG0gPDwgMSkgfCBiaXQ7XG4gICAgc3ltYm9sIHw9IGJpdCA8PCBpO1xuICB9XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG5MWk1BLkxlbkRlY29kZXIgPSBmdW5jdGlvbigpe1xuICB0aGlzLl9jaG9pY2UgPSBbXTtcbiAgdGhpcy5fbG93Q29kZXIgPSBbXTtcbiAgdGhpcy5fbWlkQ29kZXIgPSBbXTtcbiAgdGhpcy5faGlnaENvZGVyID0gbmV3IExaTUEuQml0VHJlZURlY29kZXIoOCk7XG4gIHRoaXMuX251bVBvc1N0YXRlcyA9IDA7XG59O1xuXG5MWk1BLkxlbkRlY29kZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKG51bVBvc1N0YXRlcyl7XG4gIGZvciAoOyB0aGlzLl9udW1Qb3NTdGF0ZXMgPCBudW1Qb3NTdGF0ZXM7ICsrIHRoaXMuX251bVBvc1N0YXRlcyl7XG4gICAgdGhpcy5fbG93Q29kZXJbdGhpcy5fbnVtUG9zU3RhdGVzXSA9IG5ldyBMWk1BLkJpdFRyZWVEZWNvZGVyKDMpO1xuICAgIHRoaXMuX21pZENvZGVyW3RoaXMuX251bVBvc1N0YXRlc10gPSBuZXcgTFpNQS5CaXRUcmVlRGVjb2RlcigzKTtcbiAgfVxufTtcblxuTFpNQS5MZW5EZWNvZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSB0aGlzLl9udW1Qb3NTdGF0ZXM7XG4gIExaTUEuaW5pdEJpdE1vZGVscyh0aGlzLl9jaG9pY2UsIDIpO1xuICB3aGlsZShpIC0tKXtcbiAgICB0aGlzLl9sb3dDb2RlcltpXS5pbml0KCk7XG4gICAgdGhpcy5fbWlkQ29kZXJbaV0uaW5pdCgpO1xuICB9XG4gIHRoaXMuX2hpZ2hDb2Rlci5pbml0KCk7XG59O1xuXG5MWk1BLkxlbkRlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHJhbmdlRGVjb2RlciwgcG9zU3RhdGUpe1xuICBpZiAocmFuZ2VEZWNvZGVyLmRlY29kZUJpdCh0aGlzLl9jaG9pY2UsIDApID09PSAwKXtcbiAgICByZXR1cm4gdGhpcy5fbG93Q29kZXJbcG9zU3RhdGVdLmRlY29kZShyYW5nZURlY29kZXIpO1xuICB9XG4gIGlmIChyYW5nZURlY29kZXIuZGVjb2RlQml0KHRoaXMuX2Nob2ljZSwgMSkgPT09IDApe1xuICAgIHJldHVybiA4ICsgdGhpcy5fbWlkQ29kZXJbcG9zU3RhdGVdLmRlY29kZShyYW5nZURlY29kZXIpO1xuICB9XG4gIHJldHVybiAxNiArIHRoaXMuX2hpZ2hDb2Rlci5kZWNvZGUocmFuZ2VEZWNvZGVyKTtcbn07XG5cbkxaTUEuRGVjb2RlcjIgPSBmdW5jdGlvbigpe1xuICB0aGlzLl9kZWNvZGVycyA9IFtdO1xufTtcblxuTFpNQS5EZWNvZGVyMi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCl7XG4gIExaTUEuaW5pdEJpdE1vZGVscyh0aGlzLl9kZWNvZGVycywgMHgzMDApO1xufTtcblxuTFpNQS5EZWNvZGVyMi5wcm90b3R5cGUuZGVjb2RlTm9ybWFsID0gZnVuY3Rpb24ocmFuZ2VEZWNvZGVyKXtcbiAgdmFyIHN5bWJvbCA9IDE7XG5cbiAgZG97XG4gICAgc3ltYm9sID0gKHN5bWJvbCA8PCAxKSB8IHJhbmdlRGVjb2Rlci5kZWNvZGVCaXQodGhpcy5fZGVjb2RlcnMsIHN5bWJvbCk7XG4gIH13aGlsZShzeW1ib2wgPCAweDEwMCk7XG5cbiAgcmV0dXJuIHN5bWJvbCAmIDB4ZmY7XG59O1xuXG5MWk1BLkRlY29kZXIyLnByb3RvdHlwZS5kZWNvZGVXaXRoTWF0Y2hCeXRlID0gZnVuY3Rpb24ocmFuZ2VEZWNvZGVyLCBtYXRjaEJ5dGUpe1xuICB2YXIgc3ltYm9sID0gMSwgbWF0Y2hCaXQsIGJpdDtcblxuICBkb3tcbiAgICBtYXRjaEJpdCA9IChtYXRjaEJ5dGUgPj4gNykgJiAxO1xuICAgIG1hdGNoQnl0ZSA8PD0gMTtcbiAgICBiaXQgPSByYW5nZURlY29kZXIuZGVjb2RlQml0KHRoaXMuX2RlY29kZXJzLCAoICgxICsgbWF0Y2hCaXQpIDw8IDgpICsgc3ltYm9sKTtcbiAgICBzeW1ib2wgPSAoc3ltYm9sIDw8IDEpIHwgYml0O1xuICAgIGlmIChtYXRjaEJpdCAhPT0gYml0KXtcbiAgICAgIHdoaWxlKHN5bWJvbCA8IDB4MTAwKXtcbiAgICAgICAgc3ltYm9sID0gKHN5bWJvbCA8PCAxKSB8IHJhbmdlRGVjb2Rlci5kZWNvZGVCaXQodGhpcy5fZGVjb2RlcnMsIHN5bWJvbCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH13aGlsZShzeW1ib2wgPCAweDEwMCk7XG5cbiAgcmV0dXJuIHN5bWJvbCAmIDB4ZmY7XG59O1xuXG5MWk1BLkxpdGVyYWxEZWNvZGVyID0gZnVuY3Rpb24oKXtcbn07XG5cbkxaTUEuTGl0ZXJhbERlY29kZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKG51bVBvc0JpdHMsIG51bVByZXZCaXRzKXtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMuX2NvZGVyc1xuICAgICYmICh0aGlzLl9udW1QcmV2Qml0cyA9PT0gbnVtUHJldkJpdHMpXG4gICAgJiYgKHRoaXMuX251bVBvc0JpdHMgPT09IG51bVBvc0JpdHMpICl7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX251bVBvc0JpdHMgPSBudW1Qb3NCaXRzO1xuICB0aGlzLl9wb3NNYXNrID0gKDEgPDwgbnVtUG9zQml0cykgLSAxO1xuICB0aGlzLl9udW1QcmV2Qml0cyA9IG51bVByZXZCaXRzO1xuXG4gIHRoaXMuX2NvZGVycyA9IFtdO1xuXG4gIGkgPSAxIDw8ICh0aGlzLl9udW1QcmV2Qml0cyArIHRoaXMuX251bVBvc0JpdHMpO1xuICB3aGlsZShpIC0tKXtcbiAgICB0aGlzLl9jb2RlcnNbaV0gPSBuZXcgTFpNQS5EZWNvZGVyMigpO1xuICB9XG59O1xuXG5MWk1BLkxpdGVyYWxEZWNvZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSAxIDw8ICh0aGlzLl9udW1QcmV2Qml0cyArIHRoaXMuX251bVBvc0JpdHMpO1xuICB3aGlsZShpIC0tKXtcbiAgICB0aGlzLl9jb2RlcnNbaV0uaW5pdCgpO1xuICB9XG59O1xuXG5MWk1BLkxpdGVyYWxEZWNvZGVyLnByb3RvdHlwZS5nZXREZWNvZGVyID0gZnVuY3Rpb24ocG9zLCBwcmV2Qnl0ZSl7XG4gIHJldHVybiB0aGlzLl9jb2RlcnNbKCAocG9zICYgdGhpcy5fcG9zTWFzaykgPDwgdGhpcy5fbnVtUHJldkJpdHMpXG4gICAgKyAoIChwcmV2Qnl0ZSAmIDB4ZmYpID4+PiAoOCAtIHRoaXMuX251bVByZXZCaXRzKSApXTtcbn07XG5cbkxaTUEuRGVjb2RlciA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuX291dFdpbmRvdyA9IG5ldyBMWk1BLk91dFdpbmRvdygpO1xuICB0aGlzLl9yYW5nZURlY29kZXIgPSBuZXcgTFpNQS5SYW5nZURlY29kZXIoKTtcbiAgdGhpcy5faXNNYXRjaERlY29kZXJzID0gW107XG4gIHRoaXMuX2lzUmVwRGVjb2RlcnMgPSBbXTtcbiAgdGhpcy5faXNSZXBHMERlY29kZXJzID0gW107XG4gIHRoaXMuX2lzUmVwRzFEZWNvZGVycyA9IFtdO1xuICB0aGlzLl9pc1JlcEcyRGVjb2RlcnMgPSBbXTtcbiAgdGhpcy5faXNSZXAwTG9uZ0RlY29kZXJzID0gW107XG4gIHRoaXMuX3Bvc1Nsb3REZWNvZGVyID0gW107XG4gIHRoaXMuX3Bvc0RlY29kZXJzID0gW107XG4gIHRoaXMuX3Bvc0FsaWduRGVjb2RlciA9IG5ldyBMWk1BLkJpdFRyZWVEZWNvZGVyKDQpO1xuICB0aGlzLl9sZW5EZWNvZGVyID0gbmV3IExaTUEuTGVuRGVjb2RlcigpO1xuICB0aGlzLl9yZXBMZW5EZWNvZGVyID0gbmV3IExaTUEuTGVuRGVjb2RlcigpO1xuICB0aGlzLl9saXRlcmFsRGVjb2RlciA9IG5ldyBMWk1BLkxpdGVyYWxEZWNvZGVyKCk7XG4gIHRoaXMuX2RpY3Rpb25hcnlTaXplID0gLTE7XG4gIHRoaXMuX2RpY3Rpb25hcnlTaXplQ2hlY2sgPSAtMTtcblxuICB0aGlzLl9wb3NTbG90RGVjb2RlclswXSA9IG5ldyBMWk1BLkJpdFRyZWVEZWNvZGVyKDYpO1xuICB0aGlzLl9wb3NTbG90RGVjb2RlclsxXSA9IG5ldyBMWk1BLkJpdFRyZWVEZWNvZGVyKDYpO1xuICB0aGlzLl9wb3NTbG90RGVjb2RlclsyXSA9IG5ldyBMWk1BLkJpdFRyZWVEZWNvZGVyKDYpO1xuICB0aGlzLl9wb3NTbG90RGVjb2RlclszXSA9IG5ldyBMWk1BLkJpdFRyZWVEZWNvZGVyKDYpO1xufTtcblxuTFpNQS5EZWNvZGVyLnByb3RvdHlwZS5zZXREaWN0aW9uYXJ5U2l6ZSA9IGZ1bmN0aW9uKGRpY3Rpb25hcnlTaXplKXtcbiAgaWYgKGRpY3Rpb25hcnlTaXplIDwgMCl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9kaWN0aW9uYXJ5U2l6ZSAhPT0gZGljdGlvbmFyeVNpemUpe1xuICAgIHRoaXMuX2RpY3Rpb25hcnlTaXplID0gZGljdGlvbmFyeVNpemU7XG4gICAgdGhpcy5fZGljdGlvbmFyeVNpemVDaGVjayA9IE1hdGgubWF4KHRoaXMuX2RpY3Rpb25hcnlTaXplLCAxKTtcbiAgICB0aGlzLl9vdXRXaW5kb3cuY3JlYXRlKCBNYXRoLm1heCh0aGlzLl9kaWN0aW9uYXJ5U2l6ZUNoZWNrLCA0MDk2KSApO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuTFpNQS5EZWNvZGVyLnByb3RvdHlwZS5zZXRMY0xwUGIgPSBmdW5jdGlvbihsYywgbHAsIHBiKXtcbiAgdmFyIG51bVBvc1N0YXRlcyA9IDEgPDwgcGI7XG5cbiAgaWYgKGxjID4gOCB8fCBscCA+IDQgfHwgcGIgPiA0KXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9saXRlcmFsRGVjb2Rlci5jcmVhdGUobHAsIGxjKTtcblxuICB0aGlzLl9sZW5EZWNvZGVyLmNyZWF0ZShudW1Qb3NTdGF0ZXMpO1xuICB0aGlzLl9yZXBMZW5EZWNvZGVyLmNyZWF0ZShudW1Qb3NTdGF0ZXMpO1xuICB0aGlzLl9wb3NTdGF0ZU1hc2sgPSBudW1Qb3NTdGF0ZXMgLSAxO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuTFpNQS5EZWNvZGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSA0O1xuXG4gIHRoaXMuX291dFdpbmRvdy5pbml0KGZhbHNlKTtcblxuICBMWk1BLmluaXRCaXRNb2RlbHModGhpcy5faXNNYXRjaERlY29kZXJzLCAxOTIpO1xuICBMWk1BLmluaXRCaXRNb2RlbHModGhpcy5faXNSZXAwTG9uZ0RlY29kZXJzLCAxOTIpO1xuICBMWk1BLmluaXRCaXRNb2RlbHModGhpcy5faXNSZXBEZWNvZGVycywgMTIpO1xuICBMWk1BLmluaXRCaXRNb2RlbHModGhpcy5faXNSZXBHMERlY29kZXJzLCAxMik7XG4gIExaTUEuaW5pdEJpdE1vZGVscyh0aGlzLl9pc1JlcEcxRGVjb2RlcnMsIDEyKTtcbiAgTFpNQS5pbml0Qml0TW9kZWxzKHRoaXMuX2lzUmVwRzJEZWNvZGVycywgMTIpO1xuICBMWk1BLmluaXRCaXRNb2RlbHModGhpcy5fcG9zRGVjb2RlcnMsIDExNCk7XG5cbiAgdGhpcy5fbGl0ZXJhbERlY29kZXIuaW5pdCgpO1xuXG4gIHdoaWxlKGkgLS0pe1xuICAgIHRoaXMuX3Bvc1Nsb3REZWNvZGVyW2ldLmluaXQoKTtcbiAgfVxuXG4gIHRoaXMuX2xlbkRlY29kZXIuaW5pdCgpO1xuICB0aGlzLl9yZXBMZW5EZWNvZGVyLmluaXQoKTtcbiAgdGhpcy5fcG9zQWxpZ25EZWNvZGVyLmluaXQoKTtcbiAgdGhpcy5fcmFuZ2VEZWNvZGVyLmluaXQoKTtcbn07XG5cbkxaTUEuRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oaW5TdHJlYW0sIG91dFN0cmVhbSwgb3V0U2l6ZSl7XG4gIHZhciBzdGF0ZSA9IDAsIHJlcDAgPSAwLCByZXAxID0gMCwgcmVwMiA9IDAsIHJlcDMgPSAwLCBub3dQb3M2NCA9IDAsIHByZXZCeXRlID0gMCxcbiAgICAgIHBvc1N0YXRlLCBkZWNvZGVyMiwgbGVuLCBkaXN0YW5jZSwgcG9zU2xvdCwgbnVtRGlyZWN0Qml0cztcblxuICB0aGlzLl9yYW5nZURlY29kZXIuc2V0U3RyZWFtKGluU3RyZWFtKTtcbiAgdGhpcy5fb3V0V2luZG93LnNldFN0cmVhbShvdXRTdHJlYW0pO1xuXG4gIHRoaXMuaW5pdCgpO1xuXG4gIHdoaWxlKG91dFNpemUgPCAwIHx8IG5vd1BvczY0IDwgb3V0U2l6ZSl7XG4gICAgcG9zU3RhdGUgPSBub3dQb3M2NCAmIHRoaXMuX3Bvc1N0YXRlTWFzaztcblxuICAgIGlmICh0aGlzLl9yYW5nZURlY29kZXIuZGVjb2RlQml0KHRoaXMuX2lzTWF0Y2hEZWNvZGVycywgKHN0YXRlIDw8IDQpICsgcG9zU3RhdGUpID09PSAwKXtcbiAgICAgIGRlY29kZXIyID0gdGhpcy5fbGl0ZXJhbERlY29kZXIuZ2V0RGVjb2Rlcihub3dQb3M2NCArKywgcHJldkJ5dGUpO1xuXG4gICAgICBpZiAoc3RhdGUgPj0gNyl7XG4gICAgICAgIHByZXZCeXRlID0gZGVjb2RlcjIuZGVjb2RlV2l0aE1hdGNoQnl0ZSh0aGlzLl9yYW5nZURlY29kZXIsIHRoaXMuX291dFdpbmRvdy5nZXRCeXRlKHJlcDApICk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcHJldkJ5dGUgPSBkZWNvZGVyMi5kZWNvZGVOb3JtYWwodGhpcy5fcmFuZ2VEZWNvZGVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX291dFdpbmRvdy5wdXRCeXRlKHByZXZCeXRlKTtcblxuICAgICAgc3RhdGUgPSBzdGF0ZSA8IDQ/IDA6IHN0YXRlIC0gKHN0YXRlIDwgMTA/IDM6IDYpO1xuXG4gICAgfWVsc2V7XG5cbiAgICAgIGlmICh0aGlzLl9yYW5nZURlY29kZXIuZGVjb2RlQml0KHRoaXMuX2lzUmVwRGVjb2RlcnMsIHN0YXRlKSA9PT0gMSl7XG4gICAgICAgIGxlbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9yYW5nZURlY29kZXIuZGVjb2RlQml0KHRoaXMuX2lzUmVwRzBEZWNvZGVycywgc3RhdGUpID09PSAwKXtcbiAgICAgICAgICBpZiAodGhpcy5fcmFuZ2VEZWNvZGVyLmRlY29kZUJpdCh0aGlzLl9pc1JlcDBMb25nRGVjb2RlcnMsIChzdGF0ZSA8PCA0KSArIHBvc1N0YXRlKSA9PT0gMCl7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlIDwgNz8gOTogMTE7XG4gICAgICAgICAgICBsZW4gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgaWYgKHRoaXMuX3JhbmdlRGVjb2Rlci5kZWNvZGVCaXQodGhpcy5faXNSZXBHMURlY29kZXJzLCBzdGF0ZSkgPT09IDApe1xuICAgICAgICAgICAgZGlzdGFuY2UgPSByZXAxO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JhbmdlRGVjb2Rlci5kZWNvZGVCaXQodGhpcy5faXNSZXBHMkRlY29kZXJzLCBzdGF0ZSkgPT09IDApe1xuICAgICAgICAgICAgICBkaXN0YW5jZSA9IHJlcDI7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgZGlzdGFuY2UgPSByZXAzO1xuICAgICAgICAgICAgICByZXAzID0gcmVwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcDIgPSByZXAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXAxID0gcmVwMDtcbiAgICAgICAgICByZXAwID0gZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gMCl7XG4gICAgICAgICAgbGVuID0gMiArIHRoaXMuX3JlcExlbkRlY29kZXIuZGVjb2RlKHRoaXMuX3JhbmdlRGVjb2RlciwgcG9zU3RhdGUpO1xuICAgICAgICAgIHN0YXRlID0gc3RhdGUgPCA3PyA4OiAxMTtcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHJlcDMgPSByZXAyO1xuICAgICAgICByZXAyID0gcmVwMTtcbiAgICAgICAgcmVwMSA9IHJlcDA7XG5cbiAgICAgICAgbGVuID0gMiArIHRoaXMuX2xlbkRlY29kZXIuZGVjb2RlKHRoaXMuX3JhbmdlRGVjb2RlciwgcG9zU3RhdGUpO1xuICAgICAgICBzdGF0ZSA9IHN0YXRlIDwgNz8gNzogMTA7XG5cbiAgICAgICAgcG9zU2xvdCA9IHRoaXMuX3Bvc1Nsb3REZWNvZGVyW2xlbiA8PSA1PyBsZW4gLSAyOiAzXS5kZWNvZGUodGhpcy5fcmFuZ2VEZWNvZGVyKTtcbiAgICAgICAgaWYgKHBvc1Nsb3QgPj0gNCl7XG5cbiAgICAgICAgICBudW1EaXJlY3RCaXRzID0gKHBvc1Nsb3QgPj4gMSkgLSAxO1xuICAgICAgICAgIHJlcDAgPSAoMiB8IChwb3NTbG90ICYgMSkgKSA8PCBudW1EaXJlY3RCaXRzO1xuXG4gICAgICAgICAgaWYgKHBvc1Nsb3QgPCAxNCl7XG4gICAgICAgICAgICByZXAwICs9IExaTUEucmV2ZXJzZURlY29kZTIodGhpcy5fcG9zRGVjb2RlcnMsXG4gICAgICAgICAgICAgICAgcmVwMCAtIHBvc1Nsb3QgLSAxLCB0aGlzLl9yYW5nZURlY29kZXIsIG51bURpcmVjdEJpdHMpO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmVwMCArPSB0aGlzLl9yYW5nZURlY29kZXIuZGVjb2RlRGlyZWN0Qml0cyhudW1EaXJlY3RCaXRzIC0gNCkgPDwgNDtcbiAgICAgICAgICAgIHJlcDAgKz0gdGhpcy5fcG9zQWxpZ25EZWNvZGVyLnJldmVyc2VEZWNvZGUodGhpcy5fcmFuZ2VEZWNvZGVyKTtcbiAgICAgICAgICAgIGlmIChyZXAwIDwgMCl7XG4gICAgICAgICAgICAgIGlmIChyZXAwID09PSAtMSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgcmVwMCA9IHBvc1Nsb3Q7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlcDAgPj0gbm93UG9zNjQgfHwgcmVwMCA+PSB0aGlzLl9kaWN0aW9uYXJ5U2l6ZUNoZWNrKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vdXRXaW5kb3cuY29weUJsb2NrKHJlcDAsIGxlbik7XG4gICAgICBub3dQb3M2NCArPSBsZW47XG4gICAgICBwcmV2Qnl0ZSA9IHRoaXMuX291dFdpbmRvdy5nZXRCeXRlKDApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX291dFdpbmRvdy5mbHVzaCgpO1xuICB0aGlzLl9vdXRXaW5kb3cucmVsZWFzZVN0cmVhbSgpO1xuICB0aGlzLl9yYW5nZURlY29kZXIucmVsZWFzZVN0cmVhbSgpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuTFpNQS5EZWNvZGVyLnByb3RvdHlwZS5zZXREZWNvZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpe1xuICB2YXIgdmFsdWUsIGxjLCBscCwgcGIsIGRpY3Rpb25hcnlTaXplO1xuXG4gIGlmIChwcm9wZXJ0aWVzLnNpemUgPCA1KXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YWx1ZSA9IHByb3BlcnRpZXMucmVhZEJ5dGUoKTtcbiAgbGMgPSB2YWx1ZSAlIDk7XG4gIHZhbHVlID0gfn4odmFsdWUgLyA5KTtcbiAgbHAgPSB2YWx1ZSAlIDU7XG4gIHBiID0gfn4odmFsdWUgLyA1KTtcblxuICBpZiAoICF0aGlzLnNldExjTHBQYihsYywgbHAsIHBiKSApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRpY3Rpb25hcnlTaXplID0gcHJvcGVydGllcy5yZWFkQnl0ZSgpO1xuICBkaWN0aW9uYXJ5U2l6ZSB8PSBwcm9wZXJ0aWVzLnJlYWRCeXRlKCkgPDwgODtcbiAgZGljdGlvbmFyeVNpemUgfD0gcHJvcGVydGllcy5yZWFkQnl0ZSgpIDw8IDE2O1xuICBkaWN0aW9uYXJ5U2l6ZSArPSBwcm9wZXJ0aWVzLnJlYWRCeXRlKCkgKiAxNjc3NzIxNjtcblxuICByZXR1cm4gdGhpcy5zZXREaWN0aW9uYXJ5U2l6ZShkaWN0aW9uYXJ5U2l6ZSk7XG59O1xuXG5MWk1BLmRlY29tcHJlc3MgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBpblN0cmVhbSwgb3V0U3RyZWFtLCBvdXRTaXplKXtcbiAgdmFyIGRlY29kZXIgPSBuZXcgTFpNQS5EZWNvZGVyKCk7XG5cbiAgaWYgKCAhZGVjb2Rlci5zZXREZWNvZGVyUHJvcGVydGllcyhwcm9wZXJ0aWVzKSApe1xuICAgIHRocm93IFwiSW5jb3JyZWN0IHN0cmVhbSBwcm9wZXJ0aWVzXCI7XG4gIH1cblxuICBpZiAoICFkZWNvZGVyLmRlY29kZShpblN0cmVhbSwgb3V0U3RyZWFtLCBvdXRTaXplKSApe1xuICAgIHRocm93IFwiRXJyb3IgaW4gZGF0YSBzdHJlYW1cIjtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9rZW5pemUgPSByZXF1aXJlKFwiLi9sZXhpbmdcIik7XG52YXIgcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzaW5nXCIpO1xuXG52YXIgSlBhdGhJbnZhbGlkRXNjYXBlU2VxdWVuY2VFcnJvciA9IHJlcXVpcmUoXCIuL2ludmFsaWRfZXNjYXBlX3NlcXVlbmNlX2Vycm9yXCIpO1xudmFyIEpQYXRoUGFyc2luZ0Vycm9yID0gcmVxdWlyZShcIi4vcGFyc2luZ19lcnJvclwiKTtcbnZhciBKUGF0aFN5bnRheEVycm9yID0gcmVxdWlyZShcIi4vc3ludGF4X2Vycm9yXCIpO1xuXG5mdW5jdGlvbiBoaWdobGlnaHRFcnJvbmVvdXNQYXJ0KGV4cHJlc3Npb24sIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICB2YXIgYmVmb3JlID0gZXhwcmVzc2lvbi5zdWJzdHJpbmcoMCwgc3RhcnRJZHgpO1xuICAgIHZhciBlcnJvbmVvdXNQYXJ0ID0gZXhwcmVzc2lvbi5zdWJzdHJpbmcoc3RhcnRJZHgsIGVuZElkeCk7XG4gICAgdmFyIGFmdGVyID0gZXhwcmVzc2lvbi5zdWJzdHJpbmcoZW5kSWR4KTtcbiAgICByZXR1cm4gYmVmb3JlICsgXCI+XCIgKyBlcnJvbmVvdXNQYXJ0ICsgXCI8XCIgKyBhZnRlcjtcbn1cblxuZnVuY3Rpb24gY29tcGlsZShwYXRoRXhwcmVzc2lvbikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwYXJzZSh0b2tlbml6ZShwYXRoRXhwcmVzc2lvbikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKUGF0aEludmFsaWRFc2NhcGVTZXF1ZW5jZUVycm9yKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRJZHggPSBwYXRoRXhwcmVzc2lvbi5pbmRleE9mKGUuaW52YWxpZFNlcXVlbmNlKTtcbiAgICAgICAgICAgIHZhciBlbmRJZHggPSBzdGFydElkeCArIGUuaW52YWxpZFNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgICAgIHRocm93IG5ldyBKUGF0aFN5bnRheEVycm9yKHtcbiAgICAgICAgICAgICAgICByZWFzb246IEpQYXRoU3ludGF4RXJyb3IucmVhc29ucy5pbnZhbGlkRXNjYXBlU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgc3RhcnRJZHg6IHN0YXJ0SWR4LFxuICAgICAgICAgICAgICAgIGVuZElkeDogZW5kSWR4LFxuICAgICAgICAgICAgICAgIGFjdHVhbDogZS5pbnZhbGlkU2VxdWVuY2UsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGUuZXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogXCIgKyBoaWdobGlnaHRFcnJvbmVvdXNQYXJ0KHBhdGhFeHByZXNzaW9uLCBzdGFydElkeCwgZW5kSWR4KSArIFwiISBHb3Q6IFwiICsgZS5pbnZhbGlkU2VxdWVuY2UgKyBcIiwgZXhwZWN0ZWQ6IFwiICsgZS5leHBlY3RlZC5qb2luKFwiIG9yIFwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKUGF0aFBhcnNpbmdFcnJvcikge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgc3dpdGNoIChlLnJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgSlBhdGhQYXJzaW5nRXJyb3IucmVhc29ucy5taXNzaW5nQ2xvc2luZ0JyYWNrZXQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk1pc3NpbmcgY2xvc2luZyBicmFja2V0OiBcIiArIGhpZ2hsaWdodEVycm9uZW91c1BhcnQocGF0aEV4cHJlc3Npb24sIGUuc3RhcnRJZHgsIGUuZW5kSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBKUGF0aFBhcnNpbmdFcnJvci5yZWFzb25zLnVubWF0Y2hlZENsb3NpbmdCcmFja2V0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJNaXNzaW5nIG9wZW5pbmcgYnJhY2tldDogXCIgKyBoaWdobGlnaHRFcnJvbmVvdXNQYXJ0KHBhdGhFeHByZXNzaW9uLCBlLnN0YXJ0SWR4LCBlLmVuZElkeCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgSlBhdGhQYXJzaW5nRXJyb3IucmVhc29ucy5taXNzaW5nQ2xvc2luZ1BhcmVudGhlc2VzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzZXM6IFwiICsgaGlnaGxpZ2h0RXJyb25lb3VzUGFydChwYXRoRXhwcmVzc2lvbiwgZS5zdGFydElkeCwgZS5lbmRJZHgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEpQYXRoUGFyc2luZ0Vycm9yLnJlYXNvbnMudW5tYXRjaGVkQ2xvc2luZ1BhcmVudGhlc2VzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJNaXNzaW5nIG9wZW5pbmcgcGFyZW50aGVzZXM6IFwiICsgaGlnaGxpZ2h0RXJyb25lb3VzUGFydChwYXRoRXhwcmVzc2lvbiwgZS5zdGFydElkeCwgZS5lbmRJZHgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEpQYXRoUGFyc2luZ0Vycm9yLnJlYXNvbnMudW5leHBlY3RlZFRva2VuOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFRva2VuOiBcIiArIGhpZ2hsaWdodEVycm9uZW91c1BhcnQocGF0aEV4cHJlc3Npb24sIGUuc3RhcnRJZHgsIGUuZW5kSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBKUGF0aFBhcnNpbmdFcnJvci5yZWFzb25zLmludmFsaWRFeHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGV4cHJlc3Npb246IFwiICsgaGlnaGxpZ2h0RXJyb25lb3VzUGFydChwYXRoRXhwcmVzc2lvbiwgZS5zdGFydElkeCwgZS5lbmRJZHgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBKUGF0aFN5bnRheEVycm9yKHtcbiAgICAgICAgICAgICAgICByZWFzb246IGUucmVhc29uLFxuICAgICAgICAgICAgICAgIHN0YXJ0SWR4OiBlLnN0YXJ0SWR4LFxuICAgICAgICAgICAgICAgIGVuZElkeDogZS5lbmRJZHgsXG4gICAgICAgICAgICAgICAgYWN0dWFsOiBlLmludmFsaWRTZXF1ZW5jZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogZS5leHBlY3RlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY29tcGlsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIEV2YWx1YXRpb25SZXN1bHQgPSByZXF1aXJlKFwiLi9ldmFsdWF0aW9uX3Jlc3VsdFwiKTtcclxuXHJcbmZ1bmN0aW9uIENvbnN0YW50VmFsdWVFeHByZXNzaW9uKHZhbHVlKSB7XHJcblx0dGhpcy5fdmFsdWUgPSBbbmV3IEV2YWx1YXRpb25SZXN1bHQodmFsdWUpXTtcclxufVxyXG5cclxuQ29uc3RhbnRWYWx1ZUV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKF8pIHtcclxuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxufTtcclxuXHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENvbnN0YW50VmFsdWVFeHByZXNzaW9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEV2YWx1YXRpb25SZXN1bHQgPSByZXF1aXJlKFwiLi9ldmFsdWF0aW9uX3Jlc3VsdFwiKTtcblxuZnVuY3Rpb24gQ29udGV4dChyb290LCBjdXJyZW50KSB7XG5cdHRoaXMuX3Jvb3QgPSByb290O1xuXHR0aGlzLl9jdXJyZW50ID0gY3VycmVudCA/IGN1cnJlbnQgOiBbbmV3IEV2YWx1YXRpb25SZXN1bHQodGhpcy5fcm9vdCldO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb250ZXh0LnByb3RvdHlwZSwge1xuXHRyb290OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcm9vdDtcblx0XHR9XG5cdH0sXG5cdGN1cnJlbnQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9jdXJyZW50O1xuXHRcdH1cblx0fVxufSk7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXZhbHVhdGUgPSByZXF1aXJlKFwiLi9ldmFsdWF0aW9uXCIpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG4gICAgdmFyIGNvdmVyYWdlT2JqZWN0ID0ge307IC8vY3JlYXRlQ292ZXJhZ2VPYmplY3Qob2JqZWN0KTtcblxuICAgIHZhciByb290T2JqZWN0TWF0Y2hlZCA9IGZhbHNlO1xuICAgIHZhciBkZWZpbmVkUmVzdWx0cyA9IGV2YWx1YXRlKHBhdGgsIG9iamVjdCkuZGVmaW5lZFJlc3VsdHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZpbmVkUmVzdWx0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gIGRlZmluZWRSZXN1bHRzW2ldO1xuICAgICAgICBpZiAocmVzdWx0LmlzUm9vdCkge1xuICAgICAgICAgICAgcm9vdE9iamVjdE1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXZhbHVhdGUocmVzdWx0LnBhdGgsIGNvdmVyYWdlT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyb290T2JqZWN0TWF0Y2hlZClcbiAgICAgICAgcmV0dXJuIHt9O1xuXG4gICAgcmV0dXJuIGV4dHJhY3RVbmNvdmVyZWRQYXJ0cyhvYmplY3QsIGNvdmVyYWdlT2JqZWN0KTtcbn07XG5cbmZ1bmN0aW9uIGV4dHJhY3RVbmNvdmVyZWRQYXJ0cyhvYmplY3QsIGNvdmVyYWdlKSB7XG4gICAgdmFyIHVuY292ZXJlZCA9IHt9O1xuXG4gICAgaWYgKG9iamVjdC5idWZmZXIgJiYgb2JqZWN0LkJZVEVTX1BFUl9FTEVNRU5UKSB7XG4gICAgICAgIHZhciBjb3ZlcmVkSW5kaWNlc0xlbmd0aCA9IGNvdmVyYWdlLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICB1bmNvdmVyZWQgPSBuZXcgb2JqZWN0LmNvbnN0cnVjdG9yKG9iamVjdC5sZW5ndGggLSBjb3ZlcmVkSW5kaWNlc0xlbmd0aCk7XG5cbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgdW5jb3ZlcmVkSWR4ID0gMDsgaWR4IDwgb2JqZWN0Lmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGlmICghY292ZXJhZ2VbaWR4XSlcbiAgICAgICAgICAgICAgICB1bmNvdmVyZWRbdW5jb3ZlcmVkSWR4KytdID0gb2JqZWN0W2lkeF07XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKVxuICAgICAgICAgICAgdW5jb3ZlcmVkPSBbXTtcblxuICAgICAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb3ZlcmFnZVtrZXldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHVuY292ZXJlZFtrZXldID0gZXh0cmFjdFVuY292ZXJlZFBhcnRzKG9iamVjdFtrZXldLCBjb3ZlcmFnZVtrZXldKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjb3ZlcmFnZVtrZXldKVxuICAgICAgICAgICAgICAgIHVuY292ZXJlZFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiB1bmNvdmVyZWRba2V5XSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyh1bmNvdmVyZWRba2V5XSkubGVuZ3RoID09PSAwKSB8fCAoQXJyYXkuaXNBcnJheSh1bmNvdmVyZWRba2V5XSkgJiYgdW5jb3ZlcmVkW2tleV0ubGVuZ3RoID09PSAwKSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdW5jb3ZlcmVkW2tleV07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmNvdmVyZWQ7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZhbHVhdGlvblJlc3VsdCA9IHJlcXVpcmUoXCIuL2V2YWx1YXRpb25fcmVzdWx0XCIpO1xuXG5mdW5jdGlvbiBEZXNjZW50RXhwcmVzc2lvbigpIHt9XG5cbkRlc2NlbnRFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdHZhciB4ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY29udGV4dC5jdXJyZW50LmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuaXNEZWZpbmVkKCk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0LnZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50cy5wdXNoKG5ldyBFdmFsdWF0aW9uUmVzdWx0KHJlc3VsdCwga2V5KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZXNjZW5kYW50cztcblx0fSkpO1xuICAgIHJldHVybiB4O1xufTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRGVzY2VudEV4cHJlc3Npb247XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gIyBKUGF0aEVycm9yXHJcblxyXG4vLyBKUGF0aEVycm9yIHJlcHJlc2VudHMgdGhlIGJhc2UgY2xhc3Mgb2YgdGhlIGVycm9yIGhpZXJhcmNoeS5cclxuLy8gSXQgdGFrZXMgYSBwcmludGFibGUgbWVzc2FnZSBhbmQgYSBjb25zdHJ1Y3RvciB0byBidWlsZCBhIHN0YWNrIHRyYWNlLlxyXG4vLyBJdCBpbmhlcml0cyBmcm9tIG5vZGUncyBnZW5lcmljIEVycm9yIGNsYXNzIHRvIGFsbG93IGZvciBjYXRjaCBhbGwgaGFuZGxlcnMuXHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIEpQYXRoRXJyb3IuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAdHlwZSBKUGF0aEVycm9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEN1c3RvbSBlcnJvciBtZXNzYWdlIGZvciBsb2dnaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gSlBhdGhFcnJvcihtZXNzYWdlKSB7XHJcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xyXG4gICAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpXHJcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XHJcbiAgICAvLyBJZiBubyBjdXN0b20gZXJyb3IgbWVzc2FnZSB3YXMgZGVmaW5lZCB1c2UgYSBnZW5lcmljIG9uZS5cclxuICAgIHRoaXMubWVzc2FnZSA9IChtZXNzYWdlICYmIG1lc3NhZ2UudG9TdHJpbmcoKSkgfHwgXCJKUGF0aCBFcnJvclwiO1xyXG59XHJcblxyXG4vLyBJbmhlcml0IHRoZSBkZWZhdWx0IEVycm9yIHByb3RvdHlwZS5cclxudXRpbC5pbmhlcml0cyhKUGF0aEVycm9yLCBFcnJvcik7XHJcblxyXG4vLyBTZXQgYSBuYW1lIGZvciB0aGUgZXJyb3IuXHJcbkpQYXRoRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIkpQYXRoIEVycm9yXCI7XHJcblxyXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKUGF0aEVycm9yO1xyXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIi8vICMgUHJvcGVydHkgbmFtZSBlc2NhcGluZ1xuXG4vLyBJbiBhIEpQYXRoIHRoZSBjaGFyYWN0ZXJzIGAvLCBbLCBdLCA6LCAqYCBoYXZlIHNwZWNpYWwgbWVhbmluZ3MsIGJ1dCBhcmUgdmFsaWQgSlNPTiBwcm9wZXJ0eSBuYW1lcy5cbi8vIElmIG9uZSB3YW50cyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIHN1Y2ggYSBjaGFyYWN0ZXIgdGhleSBoYXZlIHRvIGJlIGVzY2FwZWQuXG4vLyBFc2NhcGUgc2VxdWVuY2VzIHN0YXJ0IHdpdGggYSB0aWxkZSwgYH5gIGZvbGxvd2VkIGJ5IGEgbnVtYmVyIGluIHRoZSByYW5nZSBbMSwgNV0uXG4vLyBUaGUgc2luZ2xlIHRpbGRlIGNoYXJhY3RlciBpcyBlc2NhcGVkIGFzIGEgZG91YmxlIHRpbGRlLlxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEpQYXRoSW52YWxpZEVzY2FwZVNlcXVlbmNlRXJyb3IgPSByZXF1aXJlKFwiLi9pbnZhbGlkX2VzY2FwZV9zZXF1ZW5jZV9lcnJvclwiKTtcbnZhciBzZXBhcmF0b3JUb2tlbk1hcHBpbmcgPSByZXF1aXJlKFwiLi9zZXBhcmF0b3JfdG9rZW5fbWFwcGluZ1wiKTtcblxudmFyIGVzY2FwZVByZWZpeCA9IFwiflwiO1xudmFyIGNoYXJhY3RlckVzY2FwZVNlcXVlbmNlTWFwID0ge307XG52YXIgZXNjYXBlU2VxdWVuY2VDaGFyYWN0ZXJNYXAgPSB7fTtcbk9iamVjdC5rZXlzKHNlcGFyYXRvclRva2VuTWFwcGluZykuZm9yRWFjaChmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XG5cdGNoYXJhY3RlckVzY2FwZVNlcXVlbmNlTWFwW2NoYXJhY3Rlcl0gPSBlc2NhcGVQcmVmaXggKyBzZXBhcmF0b3JUb2tlbk1hcHBpbmdbY2hhcmFjdGVyXTtcblx0ZXNjYXBlU2VxdWVuY2VDaGFyYWN0ZXJNYXBbZXNjYXBlUHJlZml4ICsgc2VwYXJhdG9yVG9rZW5NYXBwaW5nW2NoYXJhY3Rlcl1dID0gY2hhcmFjdGVyO1xufSk7XG5cblxuLyoqXG4gKiBFc2NhcGVzIHRoZSBnaXZlbiBwcm9wZXJ0eSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgVGhlIHByb3BlcnR5IG5hbWUgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVzY2FwZWQgcHJvcGVydHkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSkge1xuICAgIC8vIFdlIGl0ZXJhdGUgb3ZlciB0aGUgZXNjYXBlIHNlcXVlbmNlIHRhYmxlIGFuZCByZXBsYWNlIGV2ZXJ5IHJlc2VydmVkIGNoYXJhY3RlciBieSBpdHMgZXNjYXBlIHNlcXVlbmNlLlxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0aGF0IGEgdGlsZGUgaXMgZXNjYXBlZCBmaXJzdCFcbiAgICAvLyBcIn5bXCIgc2hvdWxkIGJlIG1hcHBlZCB0byBcIn5+fjJcIi5cbiAgICAvLyBJZiB3ZSB3b3VsZCBkZWNvZGUgXCJ+IH5cIiBsYXN0LCB0aGlzIHdvdWxkIGJlIGRlY29kZWQgaW50byBcIn5+MlwiIHRoZW4gaW50byBcIn5+fn4yXCIsXG4gICAgLy8gYmVjYXVzZSBvZiB0aGUgZ2xvYmFsIHJlZ2V4IGJhc2VkIHJlcGxhY2UuXG4gICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSByZXNlcnZlZENoYXJhY3RlciBpbnRvIGJyYWNrZXRzIHRvIGVzY2FwZSBub24gdmFsaWQgcmVndWxhciBleHByZXNzaW9uIGNoYXJhY3RlcnMuXG4gICAgLy8gV2UgYWxzbyBoYXZlIHVzZSBhIGRvdWJsZSBiYWNrc2xhc2ggYmVjYXVzZSBvZiB0aGUgYF1gIGNoYXJhY3Rlci5cblx0dmFyIGVzY2FwZWRQcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWUucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVByZWZpeCwgXCJnXCIpLCBlc2NhcGVQcmVmaXggKyBlc2NhcGVQcmVmaXgpO1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoY2hhcmFjdGVyRXNjYXBlU2VxdWVuY2VNYXApLnJlZHVjZShmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBjaGFyYWN0ZXIpIHtcblx0XHRyZXR1cm4gcHJvcGVydHlOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIltcXFxcXCIgKyBjaGFyYWN0ZXIgKyBcIl1cIiwgXCJnXCIpLCBjaGFyYWN0ZXJFc2NhcGVTZXF1ZW5jZU1hcFtjaGFyYWN0ZXJdKTtcblx0fSwgZXNjYXBlZFByb3BlcnR5TmFtZSk7XG59XG5cbi8qKlxuICogVW5lc2NhcGVzIGEgZ2l2ZW4gcHJvcGVydHkgbmFtZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZnVuY3Rpb24gdW5lc2NhcGVQcm9wZXJ0eU5hbWVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXNjYXBlZFByb3BlcnR5TmFtZSBUaGUgcHJvcGVydHkgbmFtZSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB1bmVzY2FwZWQgcHJvcGVydHkgbmFtZS5cbiAqIEB0aHJvd3Mge0pQYXRoSW52YWxpZEVzY2FwZVNlcXVlbmNlRXJyb3J9IGlmIGVzY2FwZWRQcm9wZXJ0eU5hbWUgY29udGFpbnMgYW4gaW52YWxpZCBlc2NhcGUgc2VxdWVuY2UsXG4gKiBlLmcuIGEgdGlsZGUgZm9sbG93ZWQgYnkgYSBudW1iZXIgbm90IGluIHRoZSB2YWxpZCByYW5nZSBbMSwgNV0uXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlUHJvcGVydHlOYW1lKGVzY2FwZWRQcm9wZXJ0eU5hbWUpIHtcbiAgICAvLyBXZSBpdGVyYXRlIG92ZXIgdGhlIGVzY2FwZWRQcm9wZXJ0eU5hbWUgY2hhcmFjdGVyIGJ5IGNoYXJhY3RlciBhbmQgbWFwIGV2ZXJ5IGVzY2FwZSBzZXF1ZW5jZSBiYWNrIHRvIHRoZWlyIG9yaWdpbmFsIHZhbHVlLlxuICAgIHZhciB1bmVzY2FwZWRDaGFyYWN0ZXJzID0gW107XG4gICAgdmFyIGRlY29kZWRDaGFyID1cIlwiO1xuICAgIHZhciBpZHggPSAwO1xuXHR2YXIgZXNjYXBlU2VxdWVuY2VzID0gT2JqZWN0LmtleXMoZXNjYXBlU2VxdWVuY2VDaGFyYWN0ZXJNYXApO1xuICAgIHdoaWxlIChpZHggPCBlc2NhcGVkUHJvcGVydHlOYW1lLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudENoYXIgPSBlc2NhcGVkUHJvcGVydHlOYW1lW2lkeF07XG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gZXNjYXBlUHJlZml4KSB7XG4gICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBlc2NhcGVkUHJvcGVydHlOYW1lW2lkeCArIDFdO1xuXG4gICAgICAgICAgICAvLyBBIHNpbmdsZSBgfmAgb3IgYSBgfmAgZm9sbG93ZWQgYnkgYSBudW1iZXIgZ3JlYXRlciBvdXRzaWRlIHRoZSBpbnRlcnZhbCBbMSwgT2JqZWN0LmtleXMoY2hhcmFjdGVyRXNjYXBlU2VxdWVuY2VNYXApLmxlbmd0aF1cbiAgICAgICAgICAgIC8vIGNhbiBuZXZlciBvY2N1ciBpbiBhIHdlbGwgZXNjYXBlZCBwcm9wZXJ0eSBuYW1lLlxuICAgICAgICAgICAgdmFyIG4gPSBwYXJzZUludChuZXh0Q2hhciwgMTApO1xuICAgICAgICAgICAgaWYgKG5leHRDaGFyICE9PSBlc2NhcGVQcmVmaXggJiYgKGlzTmFOKG4pIHx8ICFpc0Zpbml0ZShuKSB8fCBuIDwgMCB8fCBuID4gZXNjYXBlU2VxdWVuY2VzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpQYXRoSW52YWxpZEVzY2FwZVNlcXVlbmNlRXJyb3IoZXNjYXBlUHJlZml4ICsgbmV4dENoYXIsIGVzY2FwZVNlcXVlbmNlcyk7XG5cblx0XHRcdGlmIChuZXh0Q2hhciA9PT0gZXNjYXBlUHJlZml4KVxuXHRcdFx0XHRkZWNvZGVkQ2hhciA9IGVzY2FwZVByZWZpeDtcblx0XHRcdGVsc2Vcblx0XHRcdFx0ZGVjb2RlZENoYXIgPSBlc2NhcGVTZXF1ZW5jZUNoYXJhY3Rlck1hcFtlc2NhcGVQcmVmaXggKyBuZXh0Q2hhcl07XG5cbiAgICAgICAgICAgIC8vIFNraXAgYnkgdHdvIHRvIG5vdCBkZWNvZGUgfn4xIGludG8gfi8uXG4gICAgICAgICAgICBpZHggKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gY3VycmVudENoYXI7XG4gICAgICAgICAgICArK2lkeDtcbiAgICAgICAgfVxuICAgICAgICB1bmVzY2FwZWRDaGFyYWN0ZXJzLnB1c2goZGVjb2RlZENoYXIpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmVzY2FwZWRDaGFyYWN0ZXJzLmpvaW4oXCJcIik7XG59XG5cbmV4cG9ydHMuZXNjYXBlUHJvcGVydHlOYW1lID0gZXNjYXBlUHJvcGVydHlOYW1lO1xuZXhwb3J0cy51bmVzY2FwZVByb3BlcnR5TmFtZSA9IHVuZXNjYXBlUHJvcGVydHlOYW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vY29tcGlsaW5nXCIpO1xudmFyIENvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0XCIpO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGF0aCwgb2JqZWN0KSB7XG5cdHZhciBwYXRoRXhwcmVzc2lvbiA9IGNvbXBpbGUocGF0aCk7XG4gICAgcmV0dXJuIGF1Z21lbnRBcnJheShwYXRoRXhwcmVzc2lvbi5ldmFsdWF0ZShuZXcgQ29udGV4dChvYmplY3QpKSk7XG59O1xuXG5mdW5jdGlvbiBhdWdtZW50QXJyYXkoYXJyYXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhcnJheSwge1xuICAgICAgICBkZWZpbmVkUmVzdWx0czoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pc0RlZmluZWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZpbmVkUmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5lZFJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5wYXRoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBqb2luID0gcmVxdWlyZShcIi4vam9pbmluZ1wiKTtcblxuZnVuY3Rpb24gRXZhbHVhdGlvblJlc3VsdChwYXJlbnQsIHByb3BlcnR5TmFtZSwgaXNBcnJheUFjY2Vzcykge1xuICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIEV2YWx1YXRpb25SZXN1bHQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJlbnQsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaXNSb290XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG5cblx0dGhpcy5fcHJvcGVydHlOYW1lID0gdHlwZW9mIHByb3BlcnR5TmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHByb3BlcnR5TmFtZSA6IFwiXCI7XG4gICAgdGhpcy5faXNBcnJheUFjY2VzcyA9IGlzQXJyYXlBY2Nlc3M7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2YWx1YXRpb25SZXN1bHQucHJvdG90eXBlLCB7XG5cdHZhbHVlOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3BhcmVudC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LnZhbHVlW3RoaXMuX3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BhcmVudC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQudmFsdWUgPSB0aGlzLl9pc0FycmF5QWNjZXNzID8gW10gOiB7fTtcblx0XHRcdHRoaXMuX3BhcmVudC52YWx1ZVt0aGlzLl9wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuICAgIHBhdGg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvaW4odGhpcy5fcGFyZW50LnBhdGgsIHRoaXMuX3Byb3BlcnR5TmFtZSwgdGhpcy5faXNBcnJheUFjY2Vzcyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnR5TmFtZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5FdmFsdWF0aW9uUmVzdWx0LnByb3RvdHlwZS5pc0RlZmluZWQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpcy52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIjtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEV2YWx1YXRpb25SZXN1bHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVzY2FwaW5nID0gcmVxdWlyZShcIi4vZXNjYXBpbmdcIik7XG5leHBvcnRzLmVzY2FwZVByb3BlcnR5TmFtZSA9IGVzY2FwaW5nLmVzY2FwZVByb3BlcnR5TmFtZTtcbmV4cG9ydHMudW5lc2NhcGVQcm9wZXJ0eU5hbWUgPSBlc2NhcGluZy51bmVzY2FwZVByb3BlcnR5TmFtZTtcbmV4cG9ydHMuSW52YWxpZEVzY2FwZVNlcXVlbmNlRXJyb3IgPSByZXF1aXJlKFwiLi9pbnZhbGlkX2VzY2FwZV9zZXF1ZW5jZV9lcnJvclwiKTtcbmV4cG9ydHMuc2VwYXJ0b3JUb2tlbk1hcHBpbmcgPSByZXF1aXJlKFwiLi9zZXBhcmF0b3JfdG9rZW5fbWFwcGluZ1wiKTtcblxuZXhwb3J0cy5Ub2tlbiA9IHJlcXVpcmUoXCIuL3Rva2VuXCIpO1xuZXhwb3J0cy50b2tlbml6ZSA9IHJlcXVpcmUoXCIuL2xleGluZ1wiKTtcbmV4cG9ydHMuam9pbiA9IHJlcXVpcmUoXCIuL2pvaW5pbmdcIik7XG5cbmV4cG9ydHMucGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzaW5nXCIpO1xuZXhwb3J0cy5QYXJzaW5nRXJyb3IgPSByZXF1aXJlKFwiLi9wYXJzaW5nX2Vycm9yXCIpO1xuXG5leHBvcnRzLkNvbnN0YW50VmFsdWVFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vY29uc3RhbnRfdmFsdWVfZXhwcmVzc2lvblwiKTtcbmV4cG9ydHMuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vcHJvcGVydHlfYWNjZXNzX2V4cHJlc3Npb25cIik7XG5leHBvcnRzLlJhbmdlRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL3JhbmdlX2V4cHJlc3Npb25cIik7XG5leHBvcnRzLkRlc2NlbnRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vZGVzY2VudF9leHByZXNzaW9uXCIpO1xuZXhwb3J0cy5SZWN1cnNpdmVEZXNjZW50RXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL3JlY3Vyc2l2ZV9kZXNjZW50X2V4cHJlc3Npb25cIik7XG5leHBvcnRzLlBhdGhFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vcGF0aF9leHByZXNzaW9uXCIpO1xuXG5leHBvcnRzLmV2YWx1YXRlID0gcmVxdWlyZShcIi4vZXZhbHVhdGlvblwiKTtcblxuZXhwb3J0cy5leHRyYWN0VW5jb3ZlcmVkUGFydHMgPSByZXF1aXJlKFwiLi9jb3ZlcmFnZVwiKTtcbiIsIi8vICMgSW52YWxpZEVzY2FwZVNlcXVlbmNlRXJyb3JcblxuLy8gVGhpcyBjbGFzcyBpcyBvbmx5IHVzZWQgaW50ZXJuYWxseS5cbi8vIEl0IGlzIHRoZSBlcnJvciB0aGF0IGlzIHRocm93biBieSB0aGUgYHVuZXNjYXBlYCBmdW5jdGlvbiwgaWYgYW4gaW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgaXMgZm91bmQuXG4vLyBJdCBzaG91bGQgYmUgY2F0Y2hlZCBhbiByZXRocm93biBhcyBhIHN5bnRheCBlcnJvcnMgdG8gY2FycnkgbW9yZSBpbmZvcm1hdGlvbi5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5cbnZhciBKUGF0aEVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBJbnZhbGlkRXNjYXBlU2VxdWVuY2VFcnJvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW52YWxpZFNlcXVlbmNlIFRoZSBzZXF1ZW5jZSB0aGF0IGlzIGludmFsaWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydElkeCBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIGludmFsaWQgc2VxdWVuY2UgaW5zaWRlIHRoZSBzdHJpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSW52YWxpZEVzY2FwZVNlcXVlbmNlRXJyb3IoaW52YWxpZFNlcXVlbmNlLCBleHBlY3RlZCkge1xuICAgIEpQYXRoRXJyb3IuY2FsbCh0aGlzLCBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGZvdW5kOiBcIiArIGludmFsaWRTZXF1ZW5jZSk7XG4gICAgdGhpcy5pbnZhbGlkU2VxdWVuY2UgPSBpbnZhbGlkU2VxdWVuY2U7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBJbnZhbGlkRXNjYXBlU2VxdWVuY2VFcnJvcjtcblxudXRpbC5pbmhlcml0cyhJbnZhbGlkRXNjYXBlU2VxdWVuY2VFcnJvciwgSlBhdGhFcnJvcik7XG5cbkludmFsaWRFc2NhcGVTZXF1ZW5jZUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJJbnZhbGlkRXNjYXBlU2VxdWVuY2VFcnJvclwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCBpc0FycmF5SW5kZXgpIHtcbiAgICBpZiAoaXNBcnJheUluZGV4KVxuICAgICAgICBjaGlsZCA9IFwiW1wiICsgY2hpbGQgKyBcIl1cIjtcblxuICAgIHJldHVybiBwYXRoLmpvaW4ocGFyZW50LCBjaGlsZCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1bmVzY2FwZVByb3BlcnR5TmFtZSA9IHJlcXVpcmUoXCIuL2VzY2FwaW5nXCIpLnVuZXNjYXBlUHJvcGVydHlOYW1lO1xudmFyIEludmFsaWRFc2NhcGVTZXF1ZW5jZUVycm9yID0gcmVxdWlyZShcIi4vaW52YWxpZF9lc2NhcGVfc2VxdWVuY2VfZXJyb3JcIik7XG52YXIgSlBhdGhTeW50YXhFcnJvciA9IHJlcXVpcmUoXCIuL3N5bnRheF9lcnJvclwiKTtcbnZhciBUb2tlbiA9IHJlcXVpcmUoXCIuL3Rva2VuXCIpO1xudmFyIHNlcGFyYXRvclRva2VuTWFwcGluZyA9IHJlcXVpcmUoXCIuL3NlcGFyYXRvcl90b2tlbl9tYXBwaW5nXCIpO1xuXG4vLyBUb2tlbml6ZXMgdGhlIGdpdmVuIHBhdGhFeHByZXNzaW9uIHJldHVybmluZyBhbiBhcnJheSBvZiB0b2tlbnMgcmVwcmVzZW50aW5nIHRoZSB0b2tlbiBzdHJlYW0uXG5mdW5jdGlvbiB0b2tlbml6ZShwYXRoRXhwcmVzc2lvbikge1xuICAgIGlmIChwYXRoRXhwcmVzc2lvbi5sZW5ndGggPT09IDApXG4gICAgICAgIHBhdGhFeHByZXNzaW9uID0gXCIvXCI7XG5cbiAgICB2YXIgdG9rZW5TdHJlYW0gPSBbXTtcbiAgICB2YXIgY3VycmVudENoYXJJZHggPSAwO1xuICAgIHdoaWxlIChjdXJyZW50Q2hhcklkeCA8IHBhdGhFeHByZXNzaW9uLmxlbmd0aCl7XG4gICAgICAgIHZhciBjdXJyZW50Q2hhciA9IHBhdGhFeHByZXNzaW9uW2N1cnJlbnRDaGFySWR4XTtcblx0XHRpZiAoaXNUb2tlblNlcGFyYXRpb25DaGFyYWN0ZXIoY3VycmVudENoYXIpKSB7XG5cdFx0XHR0b2tlblN0cmVhbS5wdXNoKG5ldyBUb2tlbih0b2tlbkZvclNlcGFyYXRpb25DaGFyYWN0ZXIoY3VycmVudENoYXIpLCBjdXJyZW50Q2hhcklkeCwgY3VycmVudENoYXJJZHggKyAxLCBjdXJyZW50Q2hhcikpO1xuXHRcdFx0KytjdXJyZW50Q2hhcklkeDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbGl0ZXJhbFxuXHRcdFx0Ly8gUmVhZCAndGlsbCBmaXJzdCBzcGVjaWFsIGNoYXJhY3RlclxuXHRcdFx0dmFyIGxpdGVyYWwgPSBcIlwiO1xuXHRcdFx0dmFyIGxpdGVyYWxTdGFydElkeCA9IGN1cnJlbnRDaGFySWR4O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRsaXRlcmFsICs9IGN1cnJlbnRDaGFyO1xuXHRcdFx0XHQrK2N1cnJlbnRDaGFySWR4O1xuXHRcdFx0XHRjdXJyZW50Q2hhciA9IHBhdGhFeHByZXNzaW9uW2N1cnJlbnRDaGFySWR4XTtcblx0XHRcdH0gd2hpbGUgKGN1cnJlbnRDaGFySWR4IDwgcGF0aEV4cHJlc3Npb24ubGVuZ3RoICYmICFpc1Rva2VuU2VwYXJhdGlvbkNoYXJhY3RlcihjdXJyZW50Q2hhcikpO1xuXG5cdFx0XHR0b2tlblN0cmVhbS5wdXNoKG5ldyBUb2tlbihUb2tlbi50eXBlcy5saXRlcmFsLCBsaXRlcmFsU3RhcnRJZHgsIGN1cnJlbnRDaGFySWR4LCB1bmVzY2FwZVByb3BlcnR5TmFtZShsaXRlcmFsKSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9rZW5TdHJlYW0ucHVzaChuZXcgVG9rZW4oVG9rZW4udHlwZXMuZW90LCBjdXJyZW50Q2hhcklkeCwgY3VycmVudENoYXJJZHgpKTtcbiAgICByZXR1cm4gdG9rZW5TdHJlYW07XG59XG5cbnZhciB0b2tlblNlcGFyYXRpb25DaGFyYWN0ZXJzID0gT2JqZWN0LmtleXMoc2VwYXJhdG9yVG9rZW5NYXBwaW5nKTtcblxuZnVuY3Rpb24gaXNUb2tlblNlcGFyYXRpb25DaGFyYWN0ZXIoY2hhcikge1xuXHRyZXR1cm4gdG9rZW5TZXBhcmF0aW9uQ2hhcmFjdGVycy5pbmRleE9mKGNoYXIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gdG9rZW5Gb3JTZXBhcmF0aW9uQ2hhcmFjdGVyKGNoYXIpIHtcblx0cmV0dXJuIHNlcGFyYXRvclRva2VuTWFwcGluZ1tjaGFyXTtcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdG9rZW5pemU7XG4iLCIvLyAjIFBhcnNpbmdcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoXCIuL3Rva2VuXCIpO1xudmFyIEpQYXRoUGFyc2luZ0Vycm9yID0gcmVxdWlyZShcIi4vcGFyc2luZ19lcnJvclwiKTtcblxudmFyIENvbnN0YW50VmFsdWVFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vY29uc3RhbnRfdmFsdWVfZXhwcmVzc2lvblwiKTtcbnZhciBQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gPSByZXF1aXJlKFwiLi9wcm9wZXJ0eV9hY2Nlc3NfZXhwcmVzc2lvblwiKTtcbnZhciBQYXRoRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL3BhdGhfZXhwcmVzc2lvblwiKTtcbnZhciBSYW5nZUV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi9yYW5nZV9leHByZXNzaW9uXCIpO1xudmFyIERlc2NlbnRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vZGVzY2VudF9leHByZXNzaW9uXCIpO1xudmFyIFJlY3Vyc2l2ZURlc2NlbnRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vcmVjdXJzaXZlX2Rlc2NlbnRfZXhwcmVzc2lvblwiKTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRva2VuIHN0cmVhbS5cbiAqXG4gKiBAcHVibGljXG4gKiBAZnVuY3Rpb24gcGFyc2VcbiAqXG4gKiBAcGFyYW0ge1Rva2VuW119IHRva2VuU3RyZWFtIFRoZSB0b2tlbiBzdHJlYW0gdGhhdCBzaG91bGQgYmUgcGFyc2VkLlxuICogQHJldHVybnMge1BhdGhFeHByZXNzaW9ufSBUaGUgcGFyc2VkIHBhdGggZXhwcmVzc2lvbi5cbiAqIEB0aHJvd3Mge0pQYXRoU3ludGF4RXJyb3J9IGlmIHRoZSBnaXZlbiB0b2tlbiBzdHJlYW0gY29udGFpbnMgYW55IHN5bnRhY3RpY2FsIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gcGFyc2UodG9rZW5TdHJlYW0pIHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRva2VuU3RyZWFtLCBcImZyb250XCIsIHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzWzBdO1xuXHRcdH1cblx0fSk7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVBhdGhFeHByZXNzaW9uKHRva2VuU3RyZWFtKTtcblxuICAgIGlmICh0b2tlblN0cmVhbS5mcm9udC50eXBlICE9PSBUb2tlbi50eXBlcy5lb3QpXG4gICAgICAgIHRocm93IG5ldyBKUGF0aFBhcnNpbmdFcnJvcihKUGF0aFBhcnNpbmdFcnJvci5yZWFzb25zLnVuZXhwZWN0ZWRUb2tlbixcbiAgICAgICAgICAgIHRva2VuU3RyZWFtLmZyb250LnN0YXJ0SWR4LFxuICAgICAgICAgICAgdG9rZW5TdHJlYW0uZnJvbnQuZW5kSWR4LFxuICAgICAgICAgICAgVG9rZW4udHlwZXMuZW90KTtcblxuICAgIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGhFeHByZXNzaW9uKHRva2VuU3RyZWFtKSB7XG5cdHZhciBleHByZXNzaW9ucyA9IFtdO1xuXHR2YXIgaXNBYnNvbHV0ZVBhdGggPSBmYWxzZTtcblxuXHQvLyBJZiB3ZSBoYXZlIGEgc2VwYXJhdG9yIHRoaXMgaXMgYSBhYnNvbHV0ZSBwYXRoIGV4cHJlc3Npb24uXG5cdGlmICh0b2tlblN0cmVhbS5mcm9udC50eXBlID09PSBUb2tlbi50eXBlcy5zZXBhcmF0b3IpIHtcblx0XHRpc0Fic29sdXRlUGF0aCA9IHRydWU7XG5cdFx0dG9rZW5TdHJlYW0uc2hpZnQoKTtcblx0fVxuXG5cdGRvIHtcblx0XHQvLyBDb25zdW1lIHN1cGVyZmx1b3VzIHNlcGFyYXRvciB0b2tlbnMuXG5cdFx0d2hpbGUgKHRva2VuU3RyZWFtLmZyb250LnR5cGUgPT09IFRva2VuLnR5cGVzLnNlcGFyYXRvcilcblx0XHRcdHRva2VuU3RyZWFtLnNoaWZ0KCk7XG5cblx0XHRpZiAodG9rZW5TdHJlYW0uZnJvbnQudHlwZSA9PT0gVG9rZW4udHlwZXMuZW90KVxuXHRcdFx0YnJlYWs7XG5cblx0XHQvLyBQYXJzZSBwYXRoIGNvbXBvbmVudHMgYXMgbG9uZyBhcyB0aGUgbmV4dCB0b2tlbiBhZnRlcndhcmRzIGlzIGEgc2VwYXJhdG9yLlxuXHRcdGV4cHJlc3Npb25zLnB1c2gocGFyc2VQYXRoQ29tcG9uZW50KHRva2VuU3RyZWFtKSk7XG5cdH0gd2hpbGUgKHRva2VuU3RyZWFtLmZyb250LnR5cGUgPT09IFRva2VuLnR5cGVzLnNlcGFyYXRvcik7XG5cblx0cmV0dXJuIG5ldyBQYXRoRXhwcmVzc2lvbihleHByZXNzaW9ucywgaXNBYnNvbHV0ZVBhdGgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGhDb21wb25lbnQodG9rZW5TdHJlYW0pIHtcblx0aWYgKHRva2VuU3RyZWFtLmZyb250LnR5cGUgPT09IFRva2VuLnR5cGVzLmFzdGVyaXNrKVxuXHRcdHJldHVybiBwYXJzZURlc2NlbnRFeHByZXNzaW9uKHRva2VuU3RyZWFtKTtcblxuXHRpZiAodG9rZW5TdHJlYW0uZnJvbnQudHlwZSA9PT0gVG9rZW4udHlwZXMub3BlbkJyYWNrZXQpXG5cdFx0cmV0dXJuIHBhcnNlQXJyYXlBY2Nlc3NFeHByZXNzaW9uKHRva2VuU3RyZWFtKTtcblxuXHRyZXR1cm4gbmV3IFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihwYXJzZVByb3BlcnR5TmFtZUV4cHJlc3Npb24odG9rZW5TdHJlYW0pKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEZXNjZW50RXhwcmVzc2lvbih0b2tlblN0cmVhbSkge1xuXHR0b2tlblN0cmVhbS5zaGlmdCgpO1xuXHRpZiAodG9rZW5TdHJlYW0uZnJvbnQudHlwZSAhPT0gVG9rZW4udHlwZXMuYXN0ZXJpc2spXG5cdFx0cmV0dXJuIG5ldyBEZXNjZW50RXhwcmVzc2lvbigpO1xuXG5cdHRva2VuU3RyZWFtLnNoaWZ0KCk7XG5cdHJldHVybiBuZXcgUmVjdXJzaXZlRGVzY2VudEV4cHJlc3Npb24oKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eU5hbWVFeHByZXNzaW9uKHRva2VuU3RyZWFtKSB7XG5cdHZhciBsZWZ0ID0gcGFyc2VOYW1lRXhwcmVzc2lvbih0b2tlblN0cmVhbSk7XG5cdGlmICh0b2tlblN0cmVhbS5mcm9udC50eXBlID09PSBUb2tlbi50eXBlcy5jb2xvbilcblx0XHRyZXR1cm4gcGFyc2VSYW5nZUV4cHJlc3Npb24obGVmdCwgdG9rZW5TdHJlYW0pO1xuXG5cdHJldHVybiBsZWZ0O1xufVxuXG5mdW5jdGlvbiBwYXJzZU5hbWVFeHByZXNzaW9uKHRva2VuU3RyZWFtKSB7XG5cdGlmICh0b2tlblN0cmVhbS5mcm9udC50eXBlID09PSBUb2tlbi50eXBlcy5saXRlcmFsKVxuXHRcdHJldHVybiBwYXJzZUxpdGVyYWwodG9rZW5TdHJlYW0pO1xuXHRlbHNlIGlmICh0b2tlblN0cmVhbS5mcm9udC50eXBlID09PSBUb2tlbi50eXBlcy5vcGVuUGFyZW50aGVzZXMpXG5cdFx0cmV0dXJuIHBhcnNlU3ViRXhwcmVzc2lvbih0b2tlblN0cmVhbSk7XG5cdGVsc2Vcblx0XHR0aHJvdyBuZXcgSlBhdGhQYXJzaW5nRXJyb3IoSlBhdGhQYXJzaW5nRXJyb3IucmVhc29ucy51bmV4cGVjdGVkVG9rZW4sXG5cdFx0XHR0b2tlblN0cmVhbS5mcm9udC5zdGFydElkeCxcblx0XHRcdHRva2VuU3RyZWFtLmZyb250LmVuZElkeCxcblx0XHRcdFtUb2tlbi50eXBlcy5saXRlcmFsLCBUb2tlbi50eXBlcy5vcGVuUGFyZW50aGVzZXNdKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsKHRva2VuU3RyZWFtKSB7XG5cdHJldHVybiBuZXcgQ29uc3RhbnRWYWx1ZUV4cHJlc3Npb24odG9rZW5TdHJlYW0uc2hpZnQoKS52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3ViRXhwcmVzc2lvbih0b2tlblN0cmVhbSkge1xuXHR2YXIgb3BlblBhcmVudGhlc2VzVG9rZW4gPSB0b2tlblN0cmVhbS5zaGlmdCgpO1xuXG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVBhdGhFeHByZXNzaW9uKHRva2VuU3RyZWFtKTtcblxuXHRpZiAodG9rZW5TdHJlYW0uZnJvbnQudHlwZSAhPT0gVG9rZW4udHlwZXMuY2xvc2VQYXJlbnRoZXNlcylcblx0XHR0aHJvdyBuZXcgSlBhdGhQYXJzaW5nRXJyb3IoSlBhdGhQYXJzaW5nRXJyb3IucmVhc29ucy5taXNzaW5nQ2xvc2luZ1BhcmVudGhlc2VzLFxuXHRcdFx0b3BlblBhcmVudGhlc2VzVG9rZW4uc3RhcnRJZHgsXG5cdFx0XHR0b2tlblN0cmVhbS5mcm9udC5zdGFydElkeCxcblx0XHRcdFRva2VuLnR5cGVzLmNsb3NlUGFyZW50aGVzZXMpO1xuXG5cdHRva2VuU3RyZWFtLnNoaWZ0KCk7XG5cdHJldHVybiBleHByZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJhbmdlRXhwcmVzc2lvbihsZWZ0LCB0b2tlblN0cmVhbSkge1xuXHR0b2tlblN0cmVhbS5zaGlmdCgpO1xuXHR2YXIgcmlnaHQgPSBwYXJzZU5hbWVFeHByZXNzaW9uKHRva2VuU3RyZWFtKTtcblx0cmV0dXJuIG5ldyBSYW5nZUV4cHJlc3Npb24obGVmdCwgcmlnaHQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUFycmF5QWNjZXNzRXhwcmVzc2lvbih0b2tlblN0cmVhbSkge1xuXHR2YXIgb3BlbkJyYWNrZXRUb2tlbiA9IHRva2VuU3RyZWFtLnNoaWZ0KCk7XG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IG5ldyBQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24ocGFyc2VQcm9wZXJ0eU5hbWVFeHByZXNzaW9uKHRva2VuU3RyZWFtKSwgdHJ1ZSk7XG5cblx0aWYgKHRva2VuU3RyZWFtLmZyb250LnR5cGUgIT09IFRva2VuLnR5cGVzLmNsb3NlQnJhY2tldClcblx0XHR0aHJvdyBuZXcgSlBhdGhQYXJzaW5nRXJyb3IoSlBhdGhQYXJzaW5nRXJyb3IucmVhc29ucy5taXNzaW5nQ2xvc2luZ0JyYWNrZXQsXG5cdFx0XHRvcGVuQnJhY2tldFRva2VuLnN0YXJ0SWR4LFxuXHRcdFx0dG9rZW5TdHJlYW0uZnJvbnQuc3RhcnRJZHgsXG5cdFx0XHRUb2tlbi50eXBlcy5jbG9zZUJyYWNrZXQpO1xuXG5cdHRva2VuU3RyZWFtLnNoaWZ0KCk7XG5cdHJldHVybiBleHByZXNzaW9uO1xufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcbiIsIi8vICMgSlBhdGhTeW50YXhFcnJvclxuXG4vLyBUaGlzIGNsYXNzIHJlcHJlc2VudHMgc3ludGFjdGljIGVycm9ycyBpbiBhIEpQYXRoLlxuLy8gU3ludGFjdGljIGVycm9ycyBpbmNsdWRlIHVuYmFsYW5jZWQgYnJhY2tldHMsIGludmFsaWQgZXNjYXBlIHNlcXVlbmNlcyBvciBpbnZhbGlkIGV4cHJlc3Npb25zIGluIGdlbmVyYWwuXG4vLyBBcyBhbGwgZXJyb3JzIGl0IGluaGVyaXRzIGZyb20gdGhlIGdlbmVyYWwgSlBhdGggZXJyb3IuXG4vLyBUaGUgcmVhc29uIGZvciB0aGUgc3ludGF4IGVycm9yIHNob3VsZCBiZSBvbmUgb2YgdGhlIGNvbnN0YW50cyBkZWZpbmVkIGJlbG93LlxuLy8gVGhlIHN0YXJ0IGFuZCBlbmQgaW5kZXggc2hvdWxkIGJlIGNob3NlbiBzdWNoIHRoYXQgYSBzdWJzdHJpbmcgY2FsbCB3aXRoIHRob3NlIGluZGljZXMgb24gdGhlIGlucHV0IHN0cmluZyByZXN1bHRzXG4vLyBpbiB0aGF0IHBhcnQgb2YgdGhlIHN0cmluZyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgc3ludGF4IGVycm9yLlxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcblxudmFyIEpQYXRoRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcblxuZnVuY3Rpb24gSlBhdGhQYXJzaW5nRXJyb3IocmVhc29uLCBzdGFydElkeCwgZW5kSWR4LCBleHBlY3RlZFRva2Vucykge1xuICAgIEpQYXRoRXJyb3IuY2FsbCh0aGlzLCBcIlBhcnNpbmcgRXJyb3JcIik7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5zdGFydElkeCA9IHN0YXJ0SWR4O1xuICAgIHRoaXMuZW5kSWR4ID0gZW5kSWR4O1xuICAgIHRoaXMuZXhwZWN0ZWRUb2tlbnMgPSBBcnJheS5pc0FycmF5KGV4cGVjdGVkVG9rZW5zKSA/IGV4cGVjdGVkVG9rZW5zIDogW2V4cGVjdGVkVG9rZW5zXTtcbn1cblxudXRpbC5pbmhlcml0cyhKUGF0aFBhcnNpbmdFcnJvciwgSlBhdGhFcnJvcik7XG5cbkpQYXRoUGFyc2luZ0Vycm9yLnByb3RvdHlwZS5uYW1lID0gXCJKUGF0aFBhcnNpbmdFcnJvclwiO1xuXG52YXIgcmVhc29ucyA9IHt9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSlBhdGhQYXJzaW5nRXJyb3IsIFwicmVhc29uc1wiLCB7XG4gICAgdmFsdWU6IHJlYXNvbnNcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhyZWFzb25zLCB7XG4gICAgbWlzc2luZ0Nsb3NpbmdCcmFja2V0OiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB1bm1hdGNoZWRDbG9zaW5nQnJhY2tldDoge1xuICAgICAgICB2YWx1ZTogMVxuICAgIH0sXG5cdG1pc3NpbmdDbG9zaW5nUGFyZW50aGVzZXM6IHtcblx0XHR2YWx1ZTogMlxuXHR9LFxuXHR1bm1hdGNoZWRDbG9zaW5nUGFyZW50aGVzZXM6IHtcblx0XHR2YWx1ZTogM1xuXHR9LFxuICAgIHVuZXhwZWN0ZWRUb2tlbjoge1xuICAgICAgICB2YWx1ZTogNFxuICAgIH0sXG4gICAgaW52YWxpZEV4cHJlc3Npb246IHtcbiAgICAgICAgdmFsdWU6IDVcbiAgICB9XG59KTtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSlBhdGhQYXJzaW5nRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIENvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0XCIpO1xuXG5mdW5jdGlvbiBQYXRoRXhwcmVzc2lvbihleHByZXNzaW9ucywgaXNBYnNvbHV0ZVBhdGgpIHtcblx0dGhpcy5fZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcblx0dGhpcy5faXNBYnNvbHV0ZVBhdGggPSBpc0Fic29sdXRlUGF0aDtcbn1cblxuUGF0aEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0aWYgKHRoaXMuX2lzQWJzb2x1dGVQYXRoKVxuXHRcdGNvbnRleHQgPSBuZXcgQ29udGV4dChjb250ZXh0LnJvb3QpO1xuXG5cdHJldHVybiB0aGlzLl9leHByZXNzaW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGNvbnRleHQsIGV4cHJlc3Npb24pIHtcblx0XHRyZXR1cm4gbmV3IENvbnRleHQoY29udGV4dC5yb290LCBleHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpKTtcblx0fSwgY29udGV4dCkuY3VycmVudDtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFBhdGhFeHByZXNzaW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmFsdWF0aW9uUmVzdWx0ID0gcmVxdWlyZShcIi4vZXZhbHVhdGlvbl9yZXN1bHRcIik7XG5cbmZ1bmN0aW9uIFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbihwcm9wZXJ0eU5hbWVzRXhwcmVzc2lvbiwgaXNBcnJheUFjY2Vzcykge1xuXHR0aGlzLl9pc0FycmF5QWNjZXNzID0gaXNBcnJheUFjY2Vzcztcblx0dGhpcy5fcHJvcGVydHlOYW1lc0V4cHJlc3Npb24gPSBwcm9wZXJ0eU5hbWVzRXhwcmVzc2lvbjtcbn1cblxuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGlzQXJyYXlBY2Nlc3MgPSB0aGlzLl9pc0FycmF5QWNjZXNzO1xuXHR2YXIgcHJvcGVydHlOYW1lUmVzdWx0cyA9IHRoaXMuX3Byb3BlcnR5TmFtZXNFeHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpO1xuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgcHJvcGVydHlOYW1lUmVzdWx0cy5tYXAoZnVuY3Rpb24gKHByb3BlcnR5TmFtZVJlc3VsdCkge1xuXHRcdHJldHVybiBjb250ZXh0LmN1cnJlbnQubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdHJldHVybiBuZXcgRXZhbHVhdGlvblJlc3VsdChyZXN1bHQsIHByb3BlcnR5TmFtZVJlc3VsdC52YWx1ZSwgaXNBcnJheUFjY2Vzcyk7XG5cdFx0fSk7XG5cdH0pKTtcbn07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZhbHVhdGlvblJlc3VsdCA9IHJlcXVpcmUoXCIuL2V2YWx1YXRpb25fcmVzdWx0XCIpO1xuXG5mdW5jdGlvbiBSYW5nZUV4cHJlc3Npb24obGVmdEV4cHJlc3Npb24sIHJpZ2h0RXhwcmVzc2lvbikge1xuXHR0aGlzLl9sZWZ0RXhwcmVzc2lvbiA9IGxlZnRFeHByZXNzaW9uO1xuXHR0aGlzLl9yaWdodEV4cHJlc3Npb24gPSByaWdodEV4cHJlc3Npb247XG59XG5cblJhbmdlRXhwcmVzc2lvbi5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXHR2YXIgbGVmdFByb3BlcnR5TmFtZXMgPSB0aGlzLl9sZWZ0RXhwcmVzc2lvbi5ldmFsdWF0ZShjb250ZXh0KTtcblx0dmFyIHJpZ2h0UHJvcGVydHlOYW1lcyA9IHRoaXMuX3JpZ2h0RXhwcmVzc2lvbi5ldmFsdWF0ZShjb250ZXh0KTtcblxuXHRyZXR1cm4gbWFrZVJhbmdlKCtsZWZ0UHJvcGVydHlOYW1lc1swXS52YWx1ZSwgK3JpZ2h0UHJvcGVydHlOYW1lc1swXS52YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiBtYWtlUmFuZ2UobGVmdCwgcmlnaHQpIHtcblx0aWYgKGxlZnQgPiByaWdodCkge1xuXHRcdHZhciB0bXAgPSBsZWZ0O1xuXHRcdGxlZnQgPSByaWdodDtcblx0XHRyaWdodCA9IHRtcDtcblx0fVxuXG5cdHZhciByYW5nZSA9IFtdO1xuXHRmb3JcdCh2YXIgaSA9IGxlZnQ7IGkgPCByaWdodDsgKytpKVxuXHRcdHJhbmdlLnB1c2gobmV3IEV2YWx1YXRpb25SZXN1bHQoaSkpO1xuXG5cdHJldHVybiByYW5nZTtcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUmFuZ2VFeHByZXNzaW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmFsdWF0aW9uUmVzdWx0ID0gcmVxdWlyZShcIi4vZXZhbHVhdGlvbl9yZXN1bHRcIik7XG5cbmZ1bmN0aW9uIFJlY3Vyc2l2ZURlc2NlbnRFeHByZXNzaW9uKCkge31cblxuUmVjdXJzaXZlRGVzY2VudEV4cHJlc3Npb24ucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0ZnVuY3Rpb24gZmluZERlc2NlbmRhbnRzKHJlc3VsdCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0LnZhbHVlO1xuXHRcdHZhciBkZXNjZW5kYW50cyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFtrZXldID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdGRlc2NlbmRhbnRzLnB1c2guYXBwbHkoZGVzY2VuZGFudHMsIGZpbmREZXNjZW5kYW50cyhuZXcgRXZhbHVhdGlvblJlc3VsdChyZXN1bHQsIGtleSkpKTtcbiAgICAgICAgICAgICAgICBkZXNjZW5kYW50cy5wdXNoKG5ldyBFdmFsdWF0aW9uUmVzdWx0KHJlc3VsdCwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXHRcdHJldHVybiBkZXNjZW5kYW50cztcblx0fVxuXG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjb250ZXh0LmN1cnJlbnQuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5pc0RlZmluZWQoKSAmJiB0eXBlb2YgcmVzdWx0LnZhbHVlID09PSBcIm9iamVjdFwiO1xuICAgIH0pLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0cmV0dXJuIGZpbmREZXNjZW5kYW50cyhyZXN1bHQpO1xuXHR9KSk7XG59O1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBSZWN1cnNpdmVEZXNjZW50RXhwcmVzc2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9rZW5UeXBlcyA9IHJlcXVpcmUoXCIuL3Rva2VuXCIpLnR5cGVzO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiL1wiOiB0b2tlblR5cGVzLnNlcGFyYXRvcixcblx0XCJbXCI6IHRva2VuVHlwZXMub3BlbkJyYWNrZXQsXG5cdFwiXVwiOiB0b2tlblR5cGVzLmNsb3NlQnJhY2tldCxcblx0XCIoXCI6IHRva2VuVHlwZXMub3BlblBhcmVudGhlc2VzLFxuXHRcIilcIjogdG9rZW5UeXBlcy5jbG9zZVBhcmVudGhlc2VzLFxuXHRcIipcIjogdG9rZW5UeXBlcy5hc3Rlcmlzayxcblx0XCI6XCI6IHRva2VuVHlwZXMuY29sb25cbn07IiwiLy8gIyBKUGF0aFN5bnRheEVycm9yXHJcblxyXG4vLyBUaGlzIGNsYXNzIHJlcHJlc2VudHMgc3ludGFjdGljIGVycm9ycyBpbiBhIEpQYXRoLlxyXG4vLyBTeW50YWN0aWMgZXJyb3JzIGluY2x1ZGUgdW5iYWxhbmNlZCBicmFja2V0cywgaW52YWxpZCBlc2NhcGUgc2VxdWVuY2VzIG9yIGludmFsaWQgZXhwcmVzc2lvbnMgaW4gZ2VuZXJhbC5cclxuLy8gQXMgYWxsIGVycm9ycyBpdCBpbmhlcml0cyBmcm9tIHRoZSBnZW5lcmFsIEpQYXRoIGVycm9yLlxyXG4vLyBUaGUgcmVhc29uIGZvciB0aGUgc3ludGF4IGVycm9yIHNob3VsZCBiZSBvbmUgb2YgdGhlIGNvbnN0YW50cyBkZWZpbmVkIGJlbG93LlxyXG4vLyBUaGUgc3RhcnQgYW5kIGVuZCBpbmRleCBzaG91bGQgYmUgY2hvc2VuIHN1Y2ggdGhhdCBhIHN1YnN0cmluZyBjYWxsIHdpdGggdGhvc2UgaW5kaWNlcyBvbiB0aGUgaW5wdXQgc3RyaW5nIHJlc3VsdHNcclxuLy8gaW4gdGhhdCBwYXJ0IG9mIHRoZSBzdHJpbmcgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHN5bnRheCBlcnJvci5cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcclxuXHJcbnZhciBKUGF0aEVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XHJcbnZhciBKUGF0aFBhcnNpbmdFcnJvciA9IHJlcXVpcmUoXCIuL3BhcnNpbmdfZXJyb3JcIik7XHJcblxyXG5mdW5jdGlvbiBKUGF0aFN5bnRheEVycm9yKHBhcmFtcykge1xyXG4gICAgSlBhdGhFcnJvci5jYWxsKHRoaXMsIFwiU3ludGF4IGVycm9yXCIpO1xyXG4gICAgdGhpcy5yZWFzb24gPSBwYXJhbXMucmVhc29uO1xyXG4gICAgdGhpcy5zdGFydElkeCA9IHBhcmFtcy5zdGFydElkeDtcclxuICAgIHRoaXMuZW5kSWR4ID0gcGFyYW1zLmVuZElkeDtcclxuICAgIHRoaXMuYWN0dWFsID0gcGFyYW1zLmFjdHVhbDtcclxuICAgIHRoaXMuZXhwZWN0ZWQgPSBwYXJhbXMuZXhwZWN0ZWQ7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBwYXJhbXMubWVzc2FnZTtcclxufVxyXG5cclxudXRpbC5pbmhlcml0cyhKUGF0aFN5bnRheEVycm9yLCBKUGF0aEVycm9yKTtcclxuXHJcbkpQYXRoU3ludGF4RXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIkpQYXRoU3ludGF4RXJyb3JcIjtcclxuXHJcbnZhciByZWFzb25zID0gdXRpbC5fZXh0ZW5kKHt9LCBKUGF0aFBhcnNpbmdFcnJvci5yZWFzb25zKTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShKUGF0aFN5bnRheEVycm9yLCBcInJlYXNvbnNcIiwge1xyXG4gICAgdmFsdWU6IHJlYXNvbnNcclxufSk7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocmVhc29ucywgXCJpbnZhbGlkRXNjYXBlU2VxdWVuY2VcIiwge1xyXG4gICAgdmFsdWU6IEpQYXRoUGFyc2luZ0Vycm9yLnJlYXNvbnMuaW52YWxpZEV4cHJlc3Npb24gKyAxXHJcbn0pO1xyXG5cclxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSlBhdGhTeW50YXhFcnJvcjtcclxuIiwiLy8gIyBUb2tlblxuXG4vLyBSZXByZXNlbnRzIGEgdG9rZW4gYXMgdGhlIHJlc3VsdCBvZiB0aGUgbGV4ZXJzIHNjYW5uaW5nIHByb2Nlc3MuXG4vLyBUaGUgc3RhcnRJZHggYW5kIGVuZElkeCBwYXJhbWV0ZXIgYXJlIGNob3NlbiB0byBzdWNoIHRoYXQgYSBjYWxsIHRvIFN0cmluZyNzdWJzdHJpbmcoc3RhcnRJZHgsIGVuZElkeCkgb24gdGhlIGlucHV0IHN0cmVhbSB3b3VsZCByZXR1cm4gdGhlIHRva2VuJ3MgdmFsdWUuXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBDb25zdHJ1Y3RzIGEgdG9rZW4gd2l0aCB0aGUgZ2l2ZW4gdG9rZW4gdHlwZSwgdGhlIHRva2VucyBzdGFydCBhbmQgZW5kIGluZGV4IGFuZCBpdHMgYWN0dWFsIHN0cmluZyB2YWx1ZS5cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHN0YXJ0SWR4LCBlbmRJZHgsIHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnN0YXJ0SWR4ID0gc3RhcnRJZHg7XG4gICAgdGhpcy5lbmRJZHggPSBlbmRJZHg7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcblxudmFyIHRva2VuVHlwZXMgPSB7fTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRva2VuLCBcInR5cGVzXCIsIHtcbiAgICB2YWx1ZTogdG9rZW5UeXBlc1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRva2VuVHlwZXMsIHtcbiAgICAvLyBUaGUgdG9rZW4gdGhhdCBzZXBhcmF0ZXMgdHdvIHBhdGggY29tcG9uZW50cy5cbiAgICBzZXBhcmF0b3I6IHtcbiAgICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIC8vIEludHJvZHVjZXMgYW4gYXJyYXkgaW5kZXggZXhwcmVzc2lvbi5cbiAgICBvcGVuQnJhY2tldDoge1xuICAgICAgICB2YWx1ZTogMVxuICAgIH0sXG4gICAgLy8gQ2xvc2VzIGFuIGFycmF5IGluZGV4IGV4cHJlc3Npb24gb3IgYSBzdWIgZXhwcmVzc2lvbi5cbiAgICBjbG9zZUJyYWNrZXQ6IHtcbiAgICAgICAgdmFsdWU6IDJcbiAgICB9LFxuXHQvLyBJbnRyb2R1Y2VzIGVpdGhlciBhbiBhcnJheSBpbmRleCBleHByZXNzaW9uIG9yIGEgc3ViIGV4cHJlc3Npb24uXG5cdG9wZW5QYXJlbnRoZXNlczoge1xuXHRcdHZhbHVlOiAzXG5cdH0sXG5cdC8vIENsb3NlcyBhbiBhcnJheSBpbmRleCBleHByZXNzaW9uIG9yIGEgc3ViIGV4cHJlc3Npb24uXG5cdGNsb3NlUGFyZW50aGVzZXM6IHtcblx0XHR2YWx1ZTogNFxuXHR9LFxuICAgIC8vIFRoZSB0b2tlbiB0aGF0IHJlcHJlc2VudHMgYSBkZXNjZW50IG9uZSBsZXZlbCBleHByZXNzaW9uLlxuICAgIGFzdGVyaXNrOiB7XG4gICAgICAgIHZhbHVlOiA1XG4gICAgfSxcbiAgICAvLyBUaGUgdG9rZW4gdXNlZCBpbnNpZGUgYW4gYXJyYXkgaW5kZXggZXhwcmVzc2lvbiB0byBkZWZpbmUgYSBzbGljZSBvcGVyYXRpb24uXG4gICAgY29sb246IHtcbiAgICAgICAgdmFsdWU6IDZcbiAgICB9LFxuICAgIC8vIFRoZSB0b2tlbiBmb3IgYSBsaXRlcmFsLlxuXHRsaXRlcmFsOiB7XG4gICAgICAgIHZhbHVlOiAxMVxuICAgIH0sXG4gICAgLy8gVGhlIHRva2VuIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRyYW5zbWlzc2lvbi90b2tlbnN0cmVhbS5cbiAgICBlb3Q6IHtcbiAgICAgICAgdmFsdWU6IDEwMFxuICAgIH1cbn0pO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHNldEltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJncykge1xuICAgICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gcGFydGlhbGx5QXBwbGllZC5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgc2V0SW1tZWRpYXRlLCBidXRcbiAgICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXF1aXJlcyBubyBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKG5ldyBGdW5jdGlvbihcIlwiICsgaGFuZGxlcikpKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKCk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2socGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufShuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpKSk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsbnVsbCwiLyoqXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgYnVmZmVyYFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLFxuICAgLy8gRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIC8vIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBhZGRpbmcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzPyBJZlxuICAvLyBub3QsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0LiBXZSBuZWVkIHRvIGJlIGFibGUgdG9cbiAgLy8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuXG4gIC8vIEJ1ZyBpbiBGaXJlZm94IDQtMjksIG5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDApXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHN1YmplY3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgVWludDhBcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgJ2xpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBfaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gX2FzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kICE9PSB1bmRlZmluZWQpXG4gICAgPyBOdW1iZXIoZW5kKVxuICAgIDogZW5kID0gc2VsZi5sZW5ndGhcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgLy8gY29weSFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgaSsrKVxuICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIF91dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gX2FzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBfYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gX2FzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBfaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpKzFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCB0aGUgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBhdWdtZW50IChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFpFUk8gICA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUylcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0gpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRtb2R1bGUuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSgpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIikpIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUuanMnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUuanMnKTtcblxuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbkR1cGxleC5wcm90b3R5cGUud3JpdGUgPSBXcml0YWJsZS5wcm90b3R5cGUud3JpdGU7XG5EdXBsZXgucHJvdG90eXBlLmVuZCA9IFdyaXRhYmxlLnByb3RvdHlwZS5lbmQ7XG5EdXBsZXgucHJvdG90eXBlLl93cml0ZSA9IFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGU7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbmQoKTtcbiAgfSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgnLi93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IG4gPT09IG51bGwpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgIWVyKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHNldEltbWVkaWF0ZShlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgLy8gY2hlY2sgZm9yIGxpc3RlbmVycyBiZWZvcmUgZW1pdCByZW1vdmVzIG9uZS10aW1lIGxpc3RlbmVycy5cbiAgdmFyIGVyckxpc3RlbmVycyA9IEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJyk7XG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBpZiAoZXJyTGlzdGVuZXJzID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIGRlc3Qub25jZSgnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdC5hcHBseShzZWxmLCBldiwgeCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2phbi9kZXZlbG9wbWVudC94bWwzZF9ibGFzdF9sb2FkZXIvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXguanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZClcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fZmx1c2gpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxudmFyIGlzVWludDhBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgVWludDhBcnJheSB9XG4gIDogZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LmNvbnN0cnVjdG9yICYmIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknXG4gIH1cbjtcbnZhciBpc0FycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfVxuICA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcidcbiAgfVxuO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW0uRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiBpc1VpbnQ4QXJyYXkoY2h1bmspKVxuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuayk7XG4gIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGNodW5rKSk7XG4gIFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSlcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBzdGF0ZS5uZWVkRHJhaW4gPSAhcmV0O1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgc2V0SW1tZWRpYXRlKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgb2Zmc2V0LCBpKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSAoaSAtIG9mZnNldCk7XG4gICAgb2Zmc2V0ID0gaTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChpID09IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBjaGFyU3RyO1xuXG4gICAgLy8gb3RoZXJ3aXNlIGN1dCBvZmYgdGhlIGNoYXJhY3RlcnMgZW5kIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGlzIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShpLCBidWZmZXIubGVuZ3RoKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHZhciBsZW5JbmNvbXBsZXRlID0gdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSBsZW5JbmNvbXBsZXRlLCBlbmQpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gbGVuSW5jb21wbGV0ZTtcbiAgICBlbmQgLT0gbGVuSW5jb21wbGV0ZTtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIHRoaXMuY2hhckJ1ZmZlci53cml0ZShjaGFyU3RyLmNoYXJBdChjaGFyU3RyLmxlbmd0aCAtIDEpLCB0aGlzLmVuY29kaW5nKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHZhciBpbmNvbXBsZXRlID0gdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gaW5jb21wbGV0ZSA/IDIgOiAwO1xuICByZXR1cm4gaW5jb21wbGV0ZTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHZhciBpbmNvbXBsZXRlID0gdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gaW5jb21wbGV0ZSA/IDMgOiAwO1xuICByZXR1cm4gaW5jb21wbGV0ZTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIvVXNlcnMvamFuL2RldmVsb3BtZW50L3htbDNkX2JsYXN0X2xvYWRlci9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsImFyZ3VtZW50c1s0XVs0MF1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdWzQxXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bNDJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVs0M11bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdWzQ0XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bNDZdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVs0N11bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdWzQ5XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bNTJdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVs1M11bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdWzU1XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bNTZdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSIsImFyZ3VtZW50c1s0XVs1N11bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpIiwiYXJndW1lbnRzWzRdWzU4XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykiLCJhcmd1bWVudHNbNF1bNjBdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKSJdfQ==
